<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode | 677.找前缀总和（Map Sum Pairs）]]></title>
    <url>%2F2017%2F11%2F07%2Fleetcode677%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/map-sum-pairs/description/ 方法一：方法一比较暴力一些，就是创建一个存放键值对的HashMap，其中键就是我们插入的字符串，值就是这个字符串对应的权重。当要求一个前缀在HashMap中所有包括他的字符串对应value的总和时候，只需要遍历这个哈希表，查看每一个字符串是否以这个前缀开头，如果是的话把对应的值加上去就可以了。1234567891011121314151617181920212223242526272829303132333435class MapSum &#123; HashMap&lt;String, Integer&gt; hm; /** Initialize your data structure here. */ public MapSum() &#123; hm = new HashMap&lt;String, Integer&gt;(); &#125; public void insert(String key, int val) &#123; hm.put(key, val); &#125; public int sum(String prefix) &#123; int res = 0; Set&lt;String&gt; keys = hm.keySet(); Iterator it = keys.iterator(); String temp; while(it.hasNext())&#123; temp = (String)it.next(); if(temp.startsWith(prefix))&#123; res += (int)hm.get(temp); &#125; &#125; return res; &#125;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */ 方法二：本方法以及设计到一点字典树（前缀树）的思想，就是每当插入一个单词key，都会现在我们原先的HashMap中查看这个单词有没有。要是没有，就将设置delta = val - map[key]，也就是val，并构造一个Trie，将key从头到尾遍历，并将构造出的前缀的子字符串的score与delta相加，并再次赋给score。要是有这个字符串，也是求一个差值：delta = val - map[key],然后将在这个树中的所有节点的score都和delta相加，就达到更新的效果。 代码：1234567891011121314151617181920212223242526272829303132333435class MapSum &#123; HashMap&lt;String, Integer&gt; hm; //用于存取字典树 HashMap&lt;String, Integer&gt; score; /** Initialize your data structure here. */ public MapSum() &#123; hm = new HashMap&lt;String, Integer&gt;(); score = new HashMap&lt;String, Integer&gt;(); &#125; public void insert(String key, int val) &#123; //先求差值,如果没有这个键值对，就返回0 int delta = val - hm.getOrDefault(key, 0); hm.put(key, val); //先构造一个空串 String prefix = ""; for(char c : key.toCharArray())&#123; prefix += c; score.put(prefix, score.getOrDefault(prefix, 0) + delta); &#125; &#125; public int sum(String prefix) &#123; return score.getOrDefault(prefix, 0); &#125;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */ 方法三：方法三就是利用字典树的数据结构，对prefix中每一个字母的频次进行存取。思路和上面的相同，只不过数据结构变了。Trie树的结构如下： 在上图中，最左的一支代表”to”单词。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MapSum &#123; HashMap&lt;String, Integer&gt; hm; //字典树根节点 TrieNode root; /** Initialize your data structure here. */ public MapSum() &#123; hm = new HashMap&lt;String, Integer&gt;(); root = new TrieNode(); &#125; public void insert(String key, int val) &#123; //先求差值,如果没有这个键值对，就返回0 int delta = val - hm.getOrDefault(key, 0); hm.put(key, val); TrieNode cur = root; cur.score += delta; for(char c : key.toCharArray())&#123; //如果孩子节点没有这个字母，就增加一个 cur.children.putIfAbsent(c, new TrieNode()); //获取这个字母的节点 cur = cur.children.get(c); //增加delta cur.score += delta; &#125; &#125; public int sum(String prefix) &#123; TrieNode cur = root; for(char c : prefix.toCharArray())&#123; if(cur.children.get(c) == null) return 0; //指针下移 cur = cur.children.get(c); &#125; return cur.score; &#125;&#125;//前缀树节点class TrieNode&#123; Map&lt;Character, TrieNode&gt; children = new HashMap(); int score;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字典树</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 553.最佳括号分配]]></title>
    <url>%2F2017%2F11%2F05%2Fleetcode553%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/optimal-division/description/ 方法一：这个方法比较暴力一些，就是利用递归来做。 当数组只有一个数字的时候，就直接把它返回即可 当数组中有两个以上的数字的时候，可以将数组分成左右两部分，那么我们要求的最大值一定就是(左边部分的最大值)/(右边部分的最小值)。所以可以创建一个类T来存储我们的最大值和最小值以及它们对应的字符串结果。 注意在返回构造字符串的时候要注意指针是不是已经走到数组末尾前的一个位置，如果已经到了那个位置，右边部分只有一个数，就不需要给它加括号了。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public String optimalDivision(int[] nums) &#123; int start = 0; int end = nums.length - 1; T t = optimal(start, end, nums); return t.max_str; &#125; class T &#123; float max_val; float min_val; String max_str; String min_str; &#125; public T optimal(int start, int end, int[] nums)&#123; T t = new T(); //如果只有一个数，直接返回自己就可以了 if(start == end) &#123; t.max_val = nums[start]; t.min_val = nums[start]; t.max_str = "" + nums[start]; t.min_str = "" + nums[start]; return t; &#125; t.max_val = Float.MIN_VALUE; t.min_val = Float.MAX_VALUE; t.max_str = ""; t.min_str = ""; //否则的话，依次把数组划分成左右两部分，并且对这两部分求最大值和最小值 for(int i = start; i &lt; end; i++)&#123; T left = optimal(start, i, nums); T right = optimal(i + 1, end, nums); if(t.max_val &lt; left.max_val/right.min_val)&#123; t.max_val = left.max_val/right.min_val; if(i + 1 == end) t.max_str = left.max_str + "/" + right.min_str; else t.max_str = left.max_str + "/(" + right.min_str + ")"; &#125; if(t.min_val &gt; left.min_val/right.max_val)&#123; t.min_val = left.min_val/right.max_val; if(i + 1 == end) t.min_str = left.min_str + "/" + right.max_str; else t.min_str = left.min_str + "/(" + right.max_str + ")"; &#125; &#125; return t; &#125;&#125; 评估：这个算法的时间复杂度是O(n!)级别的，而空间复杂度是O(n^2)级别的（因为需要进行长度为n的分划，而每一次分划内部进行递归是n次，所以需要调用O(n^2)次递归栈） 方法二：方法二是对方法一的修改，就是增加存储二维数组，对每一次已经计算过的start和end之间的结果进行存储，在求解一个start和end之间数组的T时，先看看存储中有没有已经对这部分进行计算，如果已经计算过了，直接返回结果就可以了，没有就再进行方法一的计算，并且对计算结果进行存储。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123; public String optimalDivision(int[] nums) &#123; int start = 0; int end = nums.length - 1; //用于存储已经计算出的T T [][] memo = new T[nums.length][nums.length]; T t = optimal(start, end, nums, memo); return t.max_str; &#125; class T &#123; float max_val; float min_val; String max_str; String min_str; &#125; public T optimal(int start, int end, int[] nums, T[][] memo)&#123; //第一步先进行判断，如果这部分数组已经被计算过了，直接返回已经存储的值即可 if(memo[start][end] != null) return memo[start][end]; T t = new T(); //如果只有一个数，直接返回自己就可以了 if(start == end) &#123; t.max_val = nums[start]; t.min_val = nums[start]; t.max_str = "" + nums[start]; t.min_str = "" + nums[start]; //对计算结果进行存储 memo[start][end] = t; return t; &#125; t.max_val = Float.MIN_VALUE; t.min_val = Float.MAX_VALUE; t.max_str = ""; t.min_str = ""; //否则的话，依次把数组划分成左右两部分，并且对这两部分求最大值和最小值 for(int i = start; i &lt; end; i++)&#123; T left = optimal(start, i, nums, memo); T right = optimal(i + 1, end, nums, memo); if(t.max_val &lt; left.max_val/right.min_val)&#123; t.max_val = left.max_val/right.min_val; if(i + 1 == end) t.max_str = left.max_str + "/" + right.min_str; else t.max_str = left.max_str + "/(" + right.min_str + ")"; &#125; if(t.min_val &gt; left.min_val/right.max_val)&#123; t.min_val = left.min_val/right.max_val; if(i + 1 == end) t.min_str = left.min_str + "/" + right.max_str; else t.min_str = left.min_str + "/(" + right.max_str + ")"; &#125; &#125; //对计算结果进行存储 memo[start][end] = t; return t; &#125;&#125; 评价：这个算法的时间复杂度是O(n^3)的，空间复杂度也是O(n^3) 第三种方式：因为X1/X2/X3…/Xn一定可以转化成一个P/Q的形式，而X1一定在P中，X2一定在Q中，所以上面一定是一个(X1/X2)&#42;Y的形式，而由于X1/(X2/X3…/Xn) = (X1&#42;X3&#42;…Xn)/X2的形式，所以这种情况下Y是最大的，也是整个算式的最优解（原谅我这个等式想了好久才明白…）。所以我们可以直接通过数学定理来求解这个问题： 代码：123456789101112131415class Solution &#123; public String optimalDivision(int[] nums) &#123; if(nums.length == 1) return ""+nums[0]; if(nums.length == 2) return nums[0] + "/" + nums[1]; String res = nums[0]+"/("; for(int i = 1; i &lt;= (nums.length - 2); i++) &#123; res += nums[i] + "/"; &#125; res += nums[nums.length - 1] + ")"; return res; &#125;&#125; 评估：这个代码的时间复杂度是O(n)，空间复杂度也是O(n)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记（四）]]></title>
    <url>%2F2017%2F11%2F03%2Fgitnotes4%2F</url>
    <content type="text"><![CDATA[本篇为git笔记的第四篇 第十六课. rebase当前分支树： rebase讲解： rebase步骤： 执行命令：git rebase --onto master master dev 上面的指令可以简写，如果已经在dev分支上，可以直接执行：git rebase master 第十七节.远程分支远程分支存放在.git/refs/remotes/origin/ 可以使用git branch -a查看本地和远程的所有分支 可以使用git fetch获取到远程分支： 可以查看当前分支情况： 可以看到远程分支已经被获取到本地，并且是本地分支的最新提交，如果想将二者合并，可以直接执行：git merge origin/master就可以将这两个分支进行合并了： git pull相当于是git fetch和git merge origin/master进行合并 执行git branch -vv可以查看一个分支的跟踪分支 现在我们在远程新建一个dev分支然后在本地执行git fetch命令 切换到dev：git checkout dev查看分支树：查看本地dev分支的跟踪树： 可以看到，远程的dev分支就是本地dev分支的跟踪分支，远程master分支就是本地master分支的跟踪分支。 第十八节.reset命令 git reset -- .当前暂存区中有c0，c1两个文件： 而代码仓库只有已经提交的c0文件 现在执行git reset -- .可以看到代码仓库把暂存区全部覆盖，所以没有了c1文件 git reset --soft chash 现在工作目录有c0和c1,暂存区只有c0，现在再次将工作目录文件添加并提交： 发现提交信息写错了，想重新提交： 由上面可以看到c1已经进入暂存区，而且待提交 如果想直接修改最后一次提交的提交信息，可以直接敲：git commit --amend -m ‘相输入的内容’ git reset --mixed chash可以更新commit记录并覆盖暂存区。 可以看到c1已经不被跟踪了 git reset --hard chash上面这个指令可以使分支回滚到上一次提交记录上： git reset chash上面这个指令默认选项是mixed 总结一下：• –soft – 缓存区和工作目录都不会被改变• –mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响• –hard – 缓存区和工作目录都同步到你指定的提交 第十九课.交互式rebase 第二十节.cherry-pickgit cherry-pick chash(想要挑选的commit可以合并到当前分支上去)： 第二十一节.revert当前状态： 发现d2提交有问题，可以对d2的提交进行撤销：git revert 1702保存后变为：再对d0进行撤销：上面的revert操作相当于undo操作，就是撤销。 现在想回到最初的d2，只需要执行操作：git reset --hard 1702就可以得到如下的分支提交树：切换到master,再对dev和master进行merge对merge后的提交进行撤销，首先我们可以查看79ef的情况： 可以看到，这个merge是由622f4d3和1702b16合并而成的，所以可以执行命令：git revert -m 1 79ef上面的1就是指定622f4d3为回退后的主分支可以得到如下的界面：保存并退出：:wq 可以得到如下版本树： revert小结：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记（三）]]></title>
    <url>%2F2017%2F11%2F03%2Fgitnotes3%2F</url>
    <content type="text"><![CDATA[本篇为git笔记的第三篇 第十一课. 再谈分支切换和checkout 第十二节.stash命令SourceTree：图形化的git操作工具 git stash：可以把当前未commit的工作放在存储区，该存储区是一个栈，最顶上是最新的stash列出所有存储：git stash list恢复最近存储：git stash pop你指定版本号为stash@{1}的工作取出来：git stash apply stash@{1}将所有的栈都应用回来：git stash clear 第十三节.分支合并1.快进（Fast Forward）没有merge之前的分支情况： 执行：git checkout mastergit merge b效果： 可以看到，这个合并是Fast forward（快进）的 由于b是master的直接祖先，所以直接就采用快进的方式将两个分支合并。 2.三方合并情况如下： 现在将分支e合并到master分支上去： 由于e不是master的直接祖先，所以采用recursive策略（三方合并），合并效果如下： 三方合并是哪三方？ 当前分支（提交）内容 要合并的分支（提交）内容 共同的一个祖先提交的内容 第十四节.分支合并之冲突解决如图所示，这个图中master和f是有冲突的（同时对同一个7.txt进行不同的修改） 现在将master和f分支进行合并（其中f不能合并master，只能用master合并f） 由上图可知，f和master产生了冲突解决冲突的办法：使用git mergetool查找merge工具 上面没有找到，采用vimdiff，敲回车： 决定不采用这种方式merge，所以退出，各种选择no: 利用BCompare来配置mergetool并再次执行mergetool: 这个指令会进入BCompare的图形化界面： 左边是本地分支，右边是要merge的分支，中间是共同的祖先分支，我们采用先左后右的方式对两个分支进行合并。合并成功后，输入ll查看文件情况，发现多了一个7.orig文件： 该文件保存了merge之前的内容，因为已经merge成功，所以可以直接删除：rm 7.orig此时提交，就会去掉merging状态 ： 第十五课.分支冲突idea解决和gitignore对于上面已经解决的冲突，如果想撤回操作，直接使用git reset –hard 提交的哈希就可以将已经执行的操作撤回了。 在idea中打开ck文件夹，并且点开View-&gt;Tool Windows-&gt;Version Control就可以打开git的版本插件： 不打算让git管理的文件，可以写到.gitignore 这样上面这些文件在提交时就会被忽略提交gitignore，按ctrl+K，添加提交信息即可提交。 点击下面的Log，就可以查看提交的树状图形化界面，还可以切换分支，进行merge 对master进行merge操作： 之后的操作就和BCompare的一样了：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记（二）]]></title>
    <url>%2F2017%2F11%2F03%2Fgitnotes2%2F</url>
    <content type="text"><![CDATA[本篇为git笔记的第二篇 第八课.git如何存储数据 执行下面的命令： 生成一个.git文件夹，里面一个index文件就是暂存区.git/objects文件夹就是git的对象区。 执行命令：$ git ls-files -s就可以得到暂存区内容：100644 190a18037c64c43e6b11489df4bf0b9eb6d2c9bf 0 a.txt查看哈希值对应的内容：git cat-file -p 190a就可以得到内容：123进行提交git commit -m ‘创建文件a.txt’生成新的对象：生成commit和tree对象 之后再创建新的文件b.txt，再添加并提交，就可以得到新的对象： 总结： 每一个提交的索引： 一个提交的索引： 分支：跟踪文件版本 第九课. 深入Git存储之文件格式 第十课.git分支查看历史提交记录：git log 查看提交的哈希值：git log –oneline 查看分支，当前只有一个分支： 查看分支中的内容： 由分支可以知道，内容哈希与第二次提交的哈希相同。 新建开发分支：git branch dev查看当前分支：git branch 切换到dev分支：git checkout dev查看一下当前有哪些分支： 查看一下两个分支指向的提交的hash值： 所以两个分支当前都指向相同的提交 自动创建并切换到一个分支bug_11：$ git checkout -b bug_11 HEAD指向当前分支： 查看HEAD指向的分支，可以看到当前是在bug_11分支上。 分支总结： 查看分支的另一个方法：git log --oneline --decorate 基于某一次提交的hash创建分支：git branch dev commithash(分支的hash)或者git branch dev master 空的提交：git commit --allow-empty -m ‘功能1’ git log --oneline不能看到空的提交，要想看到空的提交，也就是所有提交，得执行：git log --oneline all顺便查看提交和分支：git log --oneline all –decorate图形化展示:git log --oneline all –decorate –graph给上面起别名：git config alias.logg &quot;log --oneline --all --decorate --graph&quot;利用别名展示：git logg]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记（一）]]></title>
    <url>%2F2017%2F11%2F03%2Fgitnotes1%2F</url>
    <content type="text"><![CDATA[本篇为git笔记的第一篇 第四课：github账号创建-仓库创建创建好账号，然后在自己账号下点New repository： 填写仓库名字并创建： 填写ReadMe(Markdown格式) 可以利用gitpage创建个人主页：命名规则：仓库名/仓库名.github.io在里面添加index.html就可以。输入：仓库名.github.io即可打开主页（参见之前的个人blog搭建过程） 第五课：git配置简单右键文件夹，git bash here，对用户名和邮箱进行输入即可：$ git config –global user.name XX$ git config –global user.email YY@sina.cn 第六课：git大致工作流程在文件夹下克隆一个项目：右键git bash，然后 git clone https://github.com/caocan/test.git 这样一个项目就被复制到你想要的文件夹下了，而且这个文件夹下有了一个隐藏的.git文件夹。切换到已经克隆好的项目下，新建一个a.txt文件，再在git下执行git add a.txt，这样就将a.txt添加到了暂存区了。执行git commit就可以添加注释并提交了 上面的提交只是提交到了本地的仓库.git，如果想提交到远端，需要执行：git push（如果没有创建仓库需要输入用户名和邮箱）这样就提交成功了。 如果远端仓库被更新，只需要在本题执行git pull，就可以将最新的项目仓库更新。上面的工作流程讲解： 第七课.git文件状态在一个新文件夹下创建仓库：右键git bash here–&gt;git init test在test文件夹下有一个本地仓库.git cd test在test文件夹下新建一个init文件：touch init看一下文件状态：git status可以看到init文件是未跟踪文件 添加文件git add .再次查看文件状态：git status由上面的状态可知，我们已经将文件添加到暂存区了，但是还没有提交（commit） 再次提交到本地仓库：git commit -m ‘创建init’ 查看状态：git status 工作目录已经清空，都已经提交到本地仓库了 编辑init文件：vi init--&gt;o--&gt;111--&gt;esc--&gt;shift+zz 查看状态：git status 上面的意思是：在工作目录中修改了，还没有添加到暂存区。添加工作目录的所有文件：git add .再对文件进行修改vi init--&gt; o--&gt;222--&gt;esc--&gt;shift+zz再查看：git status可以看到工作区的需要添加暂存区，而已经在暂存区的需要被提交到本地仓库 查看差别的三个命令：git diff：是查看工作目录与暂存区的差别的。git diff --cached：是查看暂存区与本地仓库的差别的。git diff HEAD：是查看工作目录和本地仓库的差别的。（你一定没有忘记，HEAD代表的是最近的一次commit的信息） 流程图]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL笔记]]></title>
    <url>%2F2017%2F11%2F03%2FMySQL%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一课 MySQL的安装安装教程：https://jingyan.baidu.com/article/cd4c2979033a17756f6e6047.html 我设置的root密码是：09129421 测试是否安装成功以管理员权限运行命令提示符，用net start mysql56启动MySQL服务。用net stop mysql56关闭MySQL服务。其中mysql56为Windows下MySQL的服务名。 打开MySQL方式：可以通过MySQL 5.7 Command Line Client客户端输入上面密码打开，也可以在用管理者权限打开cmd后键入mysql -u root -p并输入密码来打开。之后就和sql*plus用法相似。 第二课. mysql_started1234567891011121314151617181920212223242526--建立数据库：create database mydata;--使用这个数据库use mydata;--创建表deptcreate table dept( deptno int primary key, dname varchar(14), loc varchar(13));--创建emp表create table emp( empno int primary key, ename varchar(10), job varchar(10), mgr int, hiredate datetime, sal double, comm double, deptno int, foreign key (deptno) references dept(deptno)); 另外一种方式创建表：可以将上面创建emp表的代码写入一个文件，起名叫mydata.sql，然后再mysql中执行该脚本文件：\. c:\\mysql_script\\mydata.sql如果已经建表，就不会再建。 第三课. page_seperation12345678910111213141516--查看当前用户有多少个数据库：show databases;--查看当前用户有多少个表：show tables;--查看一张表的信息desc dept;--插入多条信息：insert into dept values (10, 'A', 'A');insert into dept values (20, 'B', 'B');insert into dept values (30, 'C', 'C');insert into dept values (40, 'D', 'D');insert into dept values (50, 'E', 'E');--提交commit;--将dept数据按deptno倒序排，从第三条开始，去后面两条。select * from dept order by deptno desc limit 3, 2; 第四课. auto_increment123456--先创建一个article表，在id后加上auto_increment，该字段就会自动递增：create table article( id int primary key auto_increment, title varchar(255)); –显示一下select * from article; –再插一条insert into article values(null,&#39;b&#39;); –显示一下，id自动递增select * from article; –在指定字段上插入数据insert into article (title)values(&#39;c&#39;); 第五课. datetime–查看当前时间：select now(); –修改时间格式select date_format(now(),&#39;%Y-%m-%d %H:%i:%s&#39;); –向emp表中插入一条数据insert into emp values (9999, &#39;test&#39;, &#39;clerk&#39;, 7369, &#39;1981-12-23 12:23:23&#39;, 8000, 80, 10); 第六课.mysql_jdbc下载好MySql到JDBC的驱动程序https://www.mysql.com--&gt;products--&gt; MySQL Connectors–&gt; JDBC Driver for MySQL (Connector/J) 在project中导入connector的jar包：http://blog.csdn.net/a153375250/article/details/50851049 编写从jdbc到mysql的连接查询代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.sql.*;public class TestMysqlConnection &#123; public static void main(String[] args)&#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; //添加jdbc到mysql的驱动 Class.forName("com.mysql.jdbc.Driver"); //连接数据库 conn = DriverManager.getConnection("jdbc:mysql://localhost/mydata?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false" , "root","09129421"); //实例化数据库操作 stmt = conn.createStatement(); //返回数据库查询结果 rs = stmt.executeQuery("select * from dept"); //将查询结果中的deptno的值依次打印 while(rs.next())&#123; System.out.println(rs.getString("deptno")); &#125; // Do something with the Connection &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; catch (SQLException ex) &#123; // handle any errors System.out.println("SQLException: " + ex.getMessage()); System.out.println("SQLState: " + ex.getSQLState()); System.out.println("VendorError: " + ex.getErrorCode()); &#125;finally &#123; try&#123; if(rs != null) &#123; rs.close(); rs = null; &#125; if(stmt != null) &#123; stmt.close(); stmt = null; &#125; if(conn != null) &#123; conn.close(); conn = null; &#125; &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 第八课.article_tree我们要在mysql下执行bbs.sql文件该sql文件如下：1234567891011121314151617181920212223242526create database bbs;use bbs;create table article (id int primary key auto_increment,pid int,rootid int,title varchar(255),cont text,pdate datetime,isleaf int );insert into article values (null, 0, 1, '蚂蚁大战大象', '蚂蚁大战大象', now(), 1);insert into article values (null, 1, 1, '大象被打趴下了', '大象被打趴下了',now(), 1);insert into article values (null, 2, 1, '蚂蚁也不好过','蚂蚁也不好过', now(), 0);insert into article values (null, 2, 1, '瞎说', '瞎说', now(), 1);insert into article values (null, 4, 1, '没有瞎说', '没有瞎说', now(), 0);insert into article values (null, 1, 1, '怎么可能', '怎么可能', now(), 1);insert into article values (null, 6, 1, '怎么没有可能', '怎么没有可能', now(), 0);insert into article values (null, 6, 1, '可能性是很大的', '可能性是很大的', now(), 0);insert into article values (null, 2, 1, '大象进医院了', '大象进医院了', now(), 1);insert into article values (null, 9, 1, '护士是蚂蚁', '护士是蚂蚁', now(), 0); 由于mysql编码问题，有时会出现因为乱码而无法插入数据的现象，解决办法如下：C:\ProgramData\MySQL\MySQL Server 5.7下，有可能ProgramData文件又能隐藏了，设置一下文件夹选项，然后再这个文件夹下面可以找到my.ini配置文件，将字符编码改为：default-character-set=gbk就可以了。 第九课.article_tree 2idea中连接数据库的详细教程：http://blog.csdn.net/qq_27093465/article/details/52872582可以将数据库的可视化界面调用出来。 将上面第八课的bbs数据库的article表树状打印出来：代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.sql.*;public class ArticleTree &#123; public static void main(String[] args)&#123; new ArticleTree().show(); &#125; public void show()&#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; //添加jdbc到mysql的驱动 Class.forName("com.mysql.jdbc.Driver"); //连接数据库 conn = DriverManager.getConnection("jdbc:mysql://localhost/bbs?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false" , "root","09129421"); stmt = conn.createStatement(); rs =stmt.executeQuery("select * from article where pid = 0"); while(rs.next())&#123; System.out.println(rs.getString("cont")); tree(conn, rs.getInt("id"), 1); &#125; &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(rs != null) &#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; if(conn != null)&#123; conn.close(); conn = null; &#125; &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; private void tree(Connection conn, int id, int level)&#123; Statement stmt = null; ResultSet rs = null; StringBuffer strPre = new StringBuffer(""); for(int i = 0; i &lt; level; i++)&#123; strPre.append(" "); &#125; try&#123; stmt = conn.createStatement(); String sql = "select * from article where pid = " + id; rs = stmt.executeQuery(sql); while(rs.next())&#123; System.out.println(strPre +(rs.getString("cont"))); if(rs.getInt("isleaf") != 0) tree(conn, rs.getInt("id"), level + 1); &#125; strPre = new StringBuffer(""); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(rs != null) &#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 647.找出字符串回文子串的个数]]></title>
    <url>%2F2017%2F11%2F03%2Fleetcode647%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/palindromic-substrings/description/ 这道题，就是找出一个字符串中所有可能出现的回文子串的个数。首先想到了一种最为直接粗暴的做法，就是把一个字符串的所有子串都求出来，然后依次判断是不是回文，如果是，计数器+1.最后将计数器返回。AC代码如下：12345678910111213141516171819202122232425class Solution &#123; public int countSubstrings(String s) &#123; int count = 0; int n = s.length(); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0 ; j &lt;= n-i; j++) &#123; String des = s.substring(j,j+i); // System.out.println("这次的子串是："+des); int desn = des.length(); int k; for(k = 0; k &lt; desn; k++) if(des.charAt(k) != des.charAt(desn-k-1)) break; if(k == desn) &#123; count++; // System.out.println(des+"是回文"); &#125; &#125; &#125; return count; &#125;&#125; 更为简洁的做法，应该是利用中心拓展来求解： 中心拓展，假设当前位置i为回文的中心，那么设置left=i-1 right=i+1，比较left与right位置是否相同，相同就+1，然后各自移动一步，重复直到退出 。 中心拓展当前的回文长度是偶数的，那么就设置left=i，right=i+1，其他同2一样。 代码如下：123456789101112131415161718192021public class Solution &#123; int count = 0; public int countSubstrings(String s) &#123; if (s == null || s.length() == 0) return 0; for (int i = 0; i &lt; s.length(); i++) &#123; // i is the mid point extendPalindrome(s, i, i); // 奇数长度; extendPalindrome(s, i, i + 1); // 偶数长度 &#125; return count; &#125; //中心拓展子函数 private void extendPalindrome(String s, int left, int right) &#123; while (left &gt;=0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; count++; left--; right++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 406.根据身高重新排队]]></title>
    <url>%2F2017%2F11%2F02%2Fleetcode406%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/queue-reconstruction-by-height/description/ 首先需要对身高和前面的人数进行排序：先对身高降序排列，再对前面的人升序排列。 对已经排好序的数组进行遍历，取出当前人的，开始对结果队列的人进行遍历，并设置计数器。如果结果队列中有一个人的身高大于h，就将计数器+1,；如果计数器的值等于了k，就在这个位置把我们当前的人插入到结果列表中去。示例：people：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]排序后：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]然后从数组people第一个元素开始，放入到数组result中，放入的位置就是离result开始位置偏移了元素第二个数字后的位置。如下： people: [7,0]插入到离开始位置偏移了0个距离的位置。result: [[7,0]] people: [7,1]插入到离开始位置偏移了1个距离的位置，即插入到[7,0]的后面。result: [[7,0], [7,1]] people: [6,1]插入到离开始位置偏移了1个距离的位置，即插入到[7,0]的后面。result: [[7,0], [6,1], [7,1]] people: [5,0]插入到离开始位置偏移了0个距离的位置，即插入到[7,0]的前面。result: [[5,0], [7,0], [6,1], [7,1]] people: [5,2]插入到离开始位置偏移了2个距离的位置，即插入到[7,0]的后面。result: [[5,0], [7,0], [5,2], [6,1], [7,1]] people: [4,4]插入到离开始位置偏移了4个距离的位置，即插入到[6,1]的后面。result: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 这种算法体现了元素第二个数字与其插入位置的关系，所以通过简单的一个for循环就可以搞定。 我的AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; //如果输入数组为空，直接返回空数组即可 if(people.length == 0) return people; //利用Arrays.sort对二维数组进行排序，先对身高降序排列，如果身高相同，就对前面的人数升序排列（这里需要用到比较器Comparator） Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] o1, int[] o2) &#123; if(o1[0] == o2[0]) return o1[1] - o2[1]; else return o2[0] - o1[0]; &#125; &#125;); //创建一个存放键值对的链表res LinkedList&lt;int[]&gt; res = new LinkedList&lt;&gt;(); int[] temp = new int[2]; //将第一个人的身高和k值传入 res.add(new int[]&#123;people[0][0], people[0][1]&#125;); //对已经排好序的数组进行遍历，取出当前人的&lt;h,k&gt;，开始对结果队列的人进行遍历，并设置计数器。如果结果队列中有一个人的身高大于h，就将计数器+1,；如果计数器的值等于了k，就在这个位置把我们当前的人插入到结果列表中去。 for(int i = 1; i &lt; people.length; i++) &#123; int h = people[i][0]; int k = people[i][1]; int count = 0; int p = 0; Iterator&lt;int[]&gt; it = res.iterator(); while(it.hasNext())&#123; if (count &lt; k)&#123; temp = it.next(); p++; if(temp[0] &gt;= h)&#123; count++; &#125; else continue; &#125; if (count &gt;= k) break; &#125; res.add(p, new int[]&#123;h, k&#125;); &#125; Iterator&lt;int[]&gt; it = res.iterator(); //将结果列表转换为数组 int pos = 0; while(it.hasNext())&#123; temp = it.next(); people[pos][0] = temp[0]; people[pos][1] = temp[1]; pos ++; &#125; return people; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 669.裁剪二叉搜索树]]></title>
    <url>%2F2017%2F10%2F22%2Fleetcode669%2F</url>
    <content type="text"><![CDATA[原题地址：https://leetcode.com/problems/trim-a-binary-search-tree/description/ 思路：第一种是循环+递归方法做裁剪： 1.如果root是null，就直接返回null；2.如果root值位于L和R之间，那么要求解的左子树就是将根的左子树带入递归算法得出的裁剪节点，求解的右子树就是根的右子树带入递归算法得出的裁剪节点；3.如果root值不位于L和R之间，那么就让根一直查找到位于L和R的区间，再重复2的求解过程。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public TreeNode trimBST(TreeNode root, int L, int R) &#123; if(root==null)&#123; return root; &#125; if(root.val&gt;=L&amp;&amp;root.val&lt;=R)&#123; root.left=trimBST(root.left, L, R); root.right=trimBST(root.right, L, R); return root; &#125; else if(root.val&lt;L)&#123;//root和root左边的部分肯定要被trim掉 while (root.val &lt; L) &#123; root = root.right; // 保证 root.val&gt;=l while (root != null &amp;&amp; root.val &lt; L) &#123; root = root.right; &#125; // 保证 l&lt;=root.val&lt;=R while (root != null &amp;&amp; root.val &gt; R) &#123; root = root.left; &#125; if (root == null) &#123; return root; &#125; &#125; root.left=trimBST(root.left, L, R); root.right=trimBST(root.right, L, R); return root; &#125; else&#123;//root.val&gt;R while (root.val &gt; R) &#123; root = root.left; // 保证 root.val&lt;=R while (root != null &amp;&amp; root.val &gt; R) &#123; root = root.left; &#125; // 保证 l&lt;=root.val&lt;=R while (root != null &amp;&amp; root.val &lt; L) &#123; root = root.right; &#125; if (root == null) &#123; return root; &#125; &#125; root.left=trimBST(root.left, L, R); root.right=trimBST(root.right, L, R); return root; &#125; &#125; 另外更简单的使用递归去做： 1.如果当前 root 正好在范围之内，那么把问题递归到它的左结点和右结点。2.如果当前 root 不在范围内，比 L 小，那么 它和它的左子树 可以被抛弃了。3.如果当前 root 不在范围内，比 R 大，那么 它和它的右子树 可以被抛弃了。 代码： 12345678910public TreeNode trimBST(TreeNode root, int L, int R) &#123; if(root == null) return null; if(root.val &gt;= L &amp;&amp; root.val &lt;= R) &#123; root.left = trimBST(root.left, L, R); root.right = trimBST(root.right, L, R); return root; &#125; if(root.val &lt; L) return trimBST(root.right, L, R); if(root.val &gt; R) return trimBST(root.left, L, R);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 575.分糖块]]></title>
    <url>%2F2017%2F10%2F22%2Fleetcode575%2F</url>
    <content type="text"><![CDATA[Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies. Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. The sister has two different kinds of candies, the brother has only one kind of candies. Note: The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. 思路：记录糖果的种类，放在set集合中，然后取糖果种类和数组一半长度中较小的一个；1234567891011public class Solution &#123; public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;(); for(int i=0;i&lt;candies.length;i++) &#123; if(!s.contains(candies[i])) &#123; s.add(candies[i]); &#125; &#125; return s.size()&lt;(candies.length/2) ? s.size():(candies.length/2); &#125; &#125; 但是这种方法需要额外的存储空间。 如果不想用额外的set集合来存储糖果种类，可以先对数组排序，然后用一个整数来存储糖果种类。 12345678910public int Solution(int[] candies) &#123; Arrays.sort(candies); int res = 0; for(int i=0;i&lt;candies.length;i++) &#123; if(i==0 || candies[i]!=candies[i-1]) &#123; res++; &#125; &#125; return Math.min(res, candies.length/2); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（十一） 持有对象]]></title>
    <url>%2F2017%2F10%2F22%2FThinkingInJava11%2F</url>
    <content type="text"><![CDATA[11.2 基本概念容器类类库的用途是“保存对象”，可划分为两个不同概念： Collection。一个独立元素的序列，这些元素都服从一条或多条规则。• List必须按照插入顺序保存元素。• Set不能有重复元素• Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同） Map。一组成对的“键值对”对象，允许你使用键来查找值。也被称为”关联数组”或”字典”。某种意义上来说，ArrayList也是一种Map 理想情况下，编写的大部分代码都是在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。可以这样创建一个List：List apples = new ArrayList好处在于修改实现时，只需要在创建处修改代码。如把ArrayList改为LinkedList。但是导出类一般具有额外的功能，如果需要使用这些功能，就不能将它们向上转型为更通用的接口。 11.3 添加一组元素1.Arrays.asList()。public static &lt;T&gt; List&lt;T&gt; asList(T... a)该方法接受一个数组或是一个用逗号分割的元素列表（使用可变参数），并将其转换为一个List对象，然后将其返回。可以直接使用此方法的输出当做一个List，但是在这种情况下，其底层表示是数组，因此不能调整大小，如果试图用add()或delete()方法在这种列表中添加或删除元素，有可能会引发改变数组尺寸的尝试，获得“Unsupported Operation”错误。另一个限制：会对所产生的List的类型做出最理想的假设，而不关心对它赋予的类型。 例： 12345678910111213141516171819202122232425262728/: holding/AsListInference.java // Arrays.asList() makes its best guess about type. import java.util.*; class Snow &#123;&#125; class Powder extends Snow &#123;&#125; class Light extends Powder &#123;&#125; class Heavy extends Powder &#123;&#125; class Crusty extends Snow &#123;&#125; class Slush extends Snow &#123;&#125; public class AsListInference &#123; public static void main(String[] args) &#123; List&lt;Snow&gt; snow1 = Arrays.asList( new Crusty(), new Slush(), new Powder()); // 不能编译: // List&lt;Snow&gt; snow2 = Arrays.asList( // new Light(), new Heavy()); // 编译说: // found : java.util.List&lt;Powder&gt; // required: java.util.List&lt;Snow&gt; // Collections.addAll() doesn't get confused: List&lt;Snow&gt; snow3 = new ArrayList&lt;Snow&gt;(); Collections.addAll(snow3, new Light(), new Heavy()); // 显式类型参数说明：Give a hint using an // explicit type argument specification: List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList( new Light(), new Heavy()); &#125; &#125; ///:~ 解决办法：使用显式类型参数说明（List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList(new Light(), new Heavy());） ，象上面的例子中最后所做的那样。 2. Collections.addAll() public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)该方法接受一个Collection对象，以及一个数组或是一个用逗号分割的列表，将元素添加到Collection中。先构建一个不包含元素的Collection，然后调用Collections.addAll()这种方式很方便，因此是首选方式。 3. Collection导出类构造器，可以接受另一个Collection，用它来将自身初始化。 4.Collection的addAll()方法，将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。相比使用构造函数初始化，这种方法快的多。 11.4 容器的打印数组需要用Arrays.toString()，容器不需要任何其它手段 （它们自己的toString()方法就足够了）。Collection打印出来的内容以[]括住，逗号分隔；Map则用{}，逗号分隔，键和值用=连接。 HashSet(HashMap)提供最快的查找技术，存储顺序无实际意义；LinkedHashSet(LinkedHashMap)按照被插入的顺序保存元素；TreeSet(TreeMap)按照比较结果的升序保存对象。 11.5 ListList 类 随机访问元素 插入和移除元素 其它 ArrayList 快 慢 LinkedList 慢 快 更大的特性集 常用方法： 方法 说明 boolean add(E e) 向列表的尾部添加指定的元素（可选操作）。 void add(int index, E element) 在列表的指定位置插入指定元素（可选操作）。 boolean addAll(Collection&lt;? extends E&gt; c) 添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序（可选操作）。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）。 void clear() 从列表中移除所有元素（可选操作）。 boolean contains(Object o) 如果列表包含指定的元素，则返回 true。 boolean containsAll(Collection&lt;?&gt; c) 如果列表包含指定 collection 的所有元素，则返回 true。 boolean equals(Object o) 比较指定的对象与列表是否相等。 E get(int index) 返回列表中指定位置的元素。 int hashCode() 返回列表的哈希码值。 int indexOf(Object o) 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 boolean isEmpty() 如果列表不包含元素，则返回 true。 Iterator iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器。 int lastIndexOf(Object o) 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 ListIterator listIterator() 返回此列表元素的列表迭代器（按适当顺序）。 ListIterator listIterator(int index) 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。 E remove(int index) 移除列表中指定位置的元素（可选操作）。 boolean remove(Object o) 从此列表中移除第一次出现的指定元素（如果存在）（可选操作）。 boolean removeAll(Collection&lt;?&gt; c) 从列表中移除指定 collection 中包含的其所有元素（可选操作）。 boolean retainAll(Collection&lt;?&gt; c) 仅在列表中保留指定 collection 中所包含的元素（可选操作）。交集 E set(int index, E element) 用指定元素替换列表中指定位置的元素（可选操作）。 int size() 返回列表中的元素数。 List subList(int fromIndex, int toIndex) 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。 Object[] toArray() 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 T[] toArray(T[] a) 返回按适当顺序（从第一个元素到最后一个元素）包含列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 • contains()、remove()、retainAll()、removeAll()方法都是基于equals()方法的。不同类，equals()方法定义可能有所不同，比如String只有在内容完全一样的情况下才会是等价的。• subList()返回的列表的修改都会反映到初始列表中，反之亦然。• Collections.sort()，Collections.shuffle()方法，进行排序、打乱顺序。• List重载了一个addAll(int, Collection)方法，可以插入一个新的列表到List中间； Collection的addAll方法追加到结尾。• toArray()方法：有一个重载；无参数的返回Object[]；传递目标类型的数组，将返回指定类型的数组，传递的数组如果太小，该方法新创建一个合适尺寸的数组。 11.6 迭代器一种设计模式，在不知道或不关心序列底层结构的情况下，遍历序列，选择每一个元素。迭代器是一种轻量级对象：创建代价低。Java的Iterator只能单向移动，用法： 使用iterator()方法返回Collection的迭代器；迭代器准备返回序列的第一个元素； 使用next()方法获取下一个元素；注意：iterator()返回的迭代器是”准备返回序列的第一个元素”，而不是已经指向了第一个元素，因此要获取第一个元素也得调用一次next()，即c.iterator().next()得到的是第一个元素。 hasNext()方法检验序列是否还有元素； 使用remove()方法删除迭代器返回的最后一个元素。注意，remove()是一种可选方法，依赖于具体实现，但Java标准容器类库都实现了这个方法。 当仅仅是遍历并获取每个元素，用foreach语法更简练。调用remove()之前必须调用next()方法。注意ConcurrentModificationException异常（所谓的fail-fast iterator）。 迭代器的威力：将遍历序列的操作与序列的底层结构分离，统一了对容器的访问方式。 11.6.1 ListIteratorListIterator：Iterator的子类，只能用于List类的访问，可双向移动；可以返回前一个和后一个元素的索引；可以使用set()方法替换最后访问的元素；listIterator()方法返回指向List开始处的ListIterator；listIterator(n)方法返回指向索引为n的元素处的ListIterator。 11.7 LinkedListLinkedList添加了一些可以使其用于栈、队列或双端队列的方法。某些方法只是别名，或者只存在些许差异，以使得它们在特定用法的上下文环境中更加适用（特别是在Queue中）。• getFirst()和element()方法完全相同，都返回列表的头，而并不移除它，如果List为空，抛出NoSuchElementException；peek()方法与他们基本相同，只是列表为空时返回null。• removeFirst()与remove()方法相同，移除并返回列表的头，List为空，抛出NoSuchElementException；poll()方法只是在列表为空时返回null。• offer()、add()、addLast()相同，都将某个元素插入到列表的尾端。• addFirst()将元素插入到列表的头。• removeLast()移除并返回列表的最后一个元素。 11.8 Stackjava.util中的Stack类采用了继承LinkedList的方式实现，实际上使用组合实现更好。 12345678910import java.util.LinkedList;public class Stack&lt;T&gt;&#123; private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void push(T v)&#123; storage.addFirst(v); &#125; public T peek()&#123; return storage.getFirst(); &#125; public T pop()&#123; return storage.removeFirst(); &#125; public boolean empty()&#123; return storage.isEmpty(); &#125; public String toString()&#123; return storage.toString(); &#125;&#125; 11.9 Set查找是Set最重要的操作，因此通常选择HashSet，因为快速查找正是它的长项。 Set的接口与Collection接口完全相同，只是行为不同而已，典型的继承与多态。 TreeSet使用红黑树数据结构，HashSet使用散列函数来保存对象，LinkedHashSet也使用散列来优化查找速度，但看起来使用链表来维护元素的插入顺序。 TreeSet默认按照字典序（lexicographically）排序，如果需要改变排序方法，可将比较器传给TreeSet构造器，如String.CASE_INSENTIVE_ORDER（按照字母表顺序alphabetically）。 11.10 Mapget(key)返回key所对应的值，如果key不在Map中，返回null。 containKey()和containValue()方法。 多维Map：值为Map或者别的Array、Collections。 Map可以返回它的键的Set（keySet()方法），它的值的Collection（values()方法），或者它的键值对的Set（entrySet()）。 11.11 QueueQueue常被用来可靠、安全地传输对象， 如从程序的一个区域传输到另一个区域，或者并行编程中从一个任务传输给另一个任务。 LinkedList实现了Queue接口，因此可用作Queue的一种实现（向上转型为Queue） 。 插入队尾：offer() 查询并返回队头：peek()：队列为空时返回nullelement()：队列空的时候抛出异常NoSuchElementException 移除并返回队头：poll()：队列为空时返回nullremove()：队列空的时候抛出异常NoSuchElementException 11.11.1 PriorityQueue队列规则：给定一组队列中的元素，确定下一个弹出队列的元素的规则 。FIFO是典型的一种规则，声明的是下一个元素应该是等待时间最长的元素。 优先级队列：下一个元素是最需要的元素（优先级最高的元素）。 Java SE5添加了这种队列。 offer()插入一个对象到PriorityQueue时，会在队列中被排序 （实际上依赖于具体实现，典型的是插入时排序，但也可以在移除时选择最重要的元素，如果对象的优先级在队列等待时可以改变，那算法的选择就很重要）。默认排序使用对象的自然顺序，但可以通过提供Comparator（如Collections.reverseOrder()，Java SE5）改变这个顺序。peek()、poll()和remove()可以获得优先级最高的元素 （对于内置类型，最小值拥有最高优先级）。 如果要在PriorityQueue使用自定义类型，就需要添加额外的功能以提供自然顺序，或者提供自己的Comparator。 11.12 Collection和IteratorCollection被认为是一个“附属接口”即因为要表示其它若干个接口的共性而出现的接口。 通过针对接口而非具体实现编写代码，我们的代码可以应用于更多的对象类型。 实现Collection接口可以通过继承AbstractCollection，但必须实现Iterator()和size()；如果类继承自其它类，就必须实现完整的Collection，但此时实现Iterator()似乎是一种更明智的选择 ，因为生成Iterator是将队列与使用队列的方法连接在一起耦合度最小的方式，并且与实现Collection相比，在序列类上所施加的约束也少得多。 11.13 Foreach与迭代器foreach可以用于数组，也可以用于Collection对象。因为Collection对象实现了Iterable接口（Java SE5引入，包含一个产生Iterator的iterator()方法）。也就是说，foreach可以用于数组和实现了Iterable接口的类（数组并不是Iterable）。 当类需要提供多种在foreach语句使用的方法时，可以采用适配器方法的惯用法。当已经拥有一个接口并需要另一个接口时，就可以编写适配器。例如，想在默认前向迭代器的基础上，添加产生反向迭代器的能力，此时不能使用覆盖，而是应该添加一个能够产生Iterable对象的方法，该对象可以用于foreach语句，像这样 123456789101112131415161718192021222324252627282930313233import java.util.*; class ReversibleArrayList&lt;T&gt; extends ArrayList&lt;T&gt; &#123; public ReversibleArrayList(Collection&lt;T&gt; c) &#123; super(c); &#125; public Iterable&lt;T&gt; reversed() &#123; return new Iterable&lt;T&gt;() &#123; public Iterator&lt;T&gt; iterator() &#123; return new Iterator&lt;T&gt;() &#123; int current = size() - 1; public boolean hasNext() &#123; return current &gt; -1; &#125; public T next() &#123; return get(current--); &#125; public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125; &#125; public class AdapterMethodIdiom &#123; public static void main(String[] args) &#123; ReversibleArrayList&lt;String&gt; ral = new ReversibleArrayList&lt;String&gt;( Arrays.asList("To be or not to be".split(" "))); // Grabs the ordinary iterator via iterator(): for(String s : ral) System.out.print(s + " "); System.out.println(); // Hand it the Iterable of your choice for(String s : ral.reversed()) System.out.print(s + " "); &#125; &#125; 通过这种方法，可以创建不同行为多个迭代器，如随机访问random()等。 意识到Arrays.asList()产生的List对象会使用底层数组作为其物理实现是很重要的。下面的代码直接使用Arrays.asList()返回的List，Collections.shuffle(stringList);原来的数组也会改变。 123456789class TestArrays&#123; public static void main(String[] args)&#123; String[] strings = &#123;"hello","world","!"&#125;; List&lt;String&gt; stringList = Arrays.asList(strings); System.out.println(Arrays.toString(strings)); Collections.shuffle(stringList); System.out.println(Arrays.toString(strings)); &#125;&#125; 新程序中不应该使用过时的Vector、Hashtable和Stack。 点线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的点线表示一个特定的类实现了一个接口，实心箭头表示某个类可以生成箭头所指向的对象。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（十） 内部类]]></title>
    <url>%2F2017%2F10%2F22%2FThinkingInJava10%2F</url>
    <content type="text"><![CDATA[内部类主要有四种：静态内部类，普通内部类，局部内部类，匿名内部类。内部类不能和外部类同名。静态内部类不依赖于外部类实例而创建，不能访问外部类的普通成员变量和方法，只能访问静态成员变量和方法。普通内部类和外部类实例绑定，可以访问外部类的任一成员和方法，不能定义静态成员和方法，但是可以有static final 成员变量。局部内部类和局部变量一样，不能被public、protected、private、static修饰，只能访问定义为final类型的局部变量，也可以访问外部类成员。 10.1 创建内部类典型用法：外部类通过方法返回内部类的引用。想从外部类的非静态方法之外的任意位置创建某个内部类的对象，就得用OuterClassName.InnerClassName的形式定义内部类对象。 注意，非static内部类只能在外部类的非静态方法中直接生成对象；在外部类静态方法和其它类中，必须先生成外部类对象实例，然后外部类对象.new。 10.2 链接到外部类内部类对象有一个到创建它的外部类对象的链接，因而可以直接的、没有任何限制地访问该外部类对象的成员，而且内部类可以访问外部类的所有成员（包括private）（C++的嵌套类没有这个特性）；而外部类访问内部类的成员，必须创建内部类的对象，可以访问任何成员（包括private）。 内部类对象中隐式包含了一个外部类对象的引用。内部类对象构建需要外部类对象的引用，如果没有，编译报错（对于非静态内部类，静态内部类可以直接被创建new Outer.Inner()，而不需要先创建外部类对象）。 10.3 使用.this和.mew.this用来返回外部类引用，编译期可知道和检查正确类型，无运行时开销（OuterClassName.this）；.new用来由外部类对象创建其内部类的对象，OuterClassObject.new InnerClassName ()（注意：在拥有外部类对象之前是不能创建内部类对象的） 嵌套类，static 内部类，其对象创建不需要外部类对象引用，也可在static方法中创建。 10.4 内部类与向上转型内部类在向上转型的时候很有用处。因为内部类通常为某个接口的实现，且能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，能更好得隐藏细节。 10.5 在方法和作用域内的内部类可以在一个方法里或者任意的作用域内定义内部类，称为局部内部类。两个理由： 实现一个接口 需要一个不公开的类辅助解决复杂的问题 内部类形式 方法内的内部类； 方法中的一个作用域内的内部类； 实现接口的匿名内部类； 继承的匿名内部类（基类含有带参数的构造器）； 进行字段初始化的匿名内部类； 使用实例初始化块进行构造的匿名内部类（匿名类没有构造器）。 10.6 匿名内部类匿名内部类 ：new T(){…}; {…}为匿名内部类的定义，”;”不可少（;只是该语句的结束，而不是用来表示匿名内部类的结束，所以没有什么特殊的地方）。 前面是基类构造器为默认构造器的情况，当基类构造器有参数时：new T(args){…};此时会调用基类相应构造器。 当需要用到外部定义的对象时，传递的引用参数必须为final，否则编译报错； 匿名类没有命名的构造器（类本身就没有名字），可以通过实例初始化来完成构造器的功能。 匿名内部类只能在继承类和实现接口中2选一，且只能实现一个接口。 10.7 嵌套类static内部类。有点类似C++嵌套类的概念，但Java的嵌套类可以访问外部类的所有成员（包括private，当然只能通过外部类对象访问非静态成员）。 不需要通过外部类对象来创建嵌套类对象； 不能通过嵌套类对象访问非静态外部类对象(嵌套类是静态的，没有外部类对象的引用，.this不可用)； 普通内部类的字段和方法，只能在类的外部层次上，不能有static成员、方法和嵌套类（普通内部类有static final字段，普通内部类继承的父类中有静态域，这时可以通过内部类直接访问静态域）。 嵌套类可以位于接口内部，位于接口内部的类自动为public static的，而且嵌套类甚至本身就可以实现该接口，好处在于可以在嵌套类内编写该接口所有实现中都要用到的代码。 10.8 为什么需要内部类内部类的使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现“多重继承”。也就是说，内部类允许继承多个非接口类型（类或抽象类）。 代码：12345678910111213141516171819package access; class D &#123;&#125; abstract class E &#123;&#125; class Z extends D&#123; E makeE()&#123; return new E() &#123;&#125;; &#125; &#125; public class MultiImplementation &#123; static void takesD(D d) &#123;&#125; static void takesE(E e) &#123;&#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Z z = new Z(); takesD(z); takesE(z.makeE()); &#125; &#125; 如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承。特性： 内部类可以有多个实例，每个实例可以拥有独立于外部类对象的不同信息； 一个外部类可以有多个内部类，每个内部类可以以不同的方式实现同一个接口或者继承同一个类； 内部类实例创建时刻并不受到外部类对象创建的限制； 用内部类不会制造”is-a”关系的混乱，每个内部类都是个实体。 10.8.1 闭包与回调闭包是一种可调用的对象，它记录了来自创建它的作用域的一些信息。内部类是一种面向对象的闭包，不仅包含了外部类的信息，而且通过包含一个指向外部类对象的引用，可以操作所有成员，包括private。 回调，通过其它对象携带的信息，可以在稍后的某个时刻调用初始对象。回调的价值在于灵活性，可以在运行时决定需要调用的方法。 GUI编程将体现得更明显。 10.8.2 内部类与控制框架一个应用程序框架是指一个用来解决一个特定类型问题的类或一组类。应用方法是，继承其中一个或多个类，覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，来解决特定问题，这是设计模式中模板方法的一个例子。 模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法。设计模式将不变的和变化的事情分开。在这个设计模式中，模板方法是保持不变的事物，而可覆盖的方法是变化的事物。 控制框架是用来响应事件的一类特殊的应用程序框架 。主要用来响应事件的系统称为事件驱动系统，如GUI。Java Swing就是一个控制框架。 内部类在控制框架中两个作用： 用来表示解决问题所需的各种不同的action()。 内部类可以直接访问外部类的所有成员，因而使得实现变得更灵活。参见P209控制温室的运作例子。 10.9 内部类的继承内部类指向外部类对象的引用必须初始化，而在它的继承类中并不存在要联接的缺省对象，必须使用特殊的语法明确指出这种关联。 12345678910111213class WithInner&#123; class Inner&#123; &#125;&#125;public class InheritInner extends WithInner.Inner &#123; InheritInner(WithInner wi)&#123; wi.super(); &#125; public static void main(String[] args)&#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(); &#125;&#125; 10.10 内部类可以被覆盖吗继承外部类，像重写方法一样重写内部类并不起作用，此时两个内部类只是两个独立的实体。 10.11 局部内部类局部内部类不能有访问限定符；有访问局部final变量和外部类所有成员的权限；可以有命名的构造器；在方法外不能访问。绝大部分情况下，可以用匿名类来替代局部内部类，除非： 需要命名的构造器，或者需要重载构造器 需要多个内部类的对象 10.12 内部类标识符内部类生成的.class文件命名规则：外围类的名字，加上’$’，再加上内部类的名字。 如果内部类是匿名的，编译器会简单地产生一个数字作为标识符。如果内部类是嵌套在别的内部类之中，只需要直接将它们的名字加在其外围类标识符与“$”的后面。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle（三） PLSQL]]></title>
    <url>%2F2017%2F10%2F22%2FOracle-PLSQL%2F</url>
    <content type="text"><![CDATA[第三十八课：PL_SQL/输出Hello World!/1234set serveroutput on; begin dbms_output.put_line('Hello World!!'); end; 12345678910111213141516declare v_name varchar2(20); begin v_name:='xiaoyu'; dbms_output.put_line(v_name); end; declare v_num number:=0; begin v_num:=2/v_num; dbms_output.put_line(v_num); exception when others then //任何错误，都会不找并打印为error dbms_output.put_line('error'); end; –变量声明的规则 1.变量名不能使用保留字 2.第一个字符必须是字母 3.变量名最多包含30个字母 4.不要与数据库或表名同名 5.每一行只能声明一个变量 /&#42;这是多行注释&#42;/–常用变量类型 1.binary_integer：整数，主要用来计数而不是用来表示字段类型 2.number数字类型 3.char定长字符串 4.date日期 5.long长字符串，最长2GB 6.boolean类型：可以取值true、false、null，默认为null，另外boolean类型值不可直接打印 1234567891011121314151617181920--变量声明 declare v_temp number(1); v_count binary_integer:=0; v_sal number(7,2):=8888.88; v_date date:=sysdate; v_pi constant number(3,2):=3.14; v_valid boolean:=false; v_name varchar2(20) not null:='geniusxiaoyu'; begin dbms_output.put_line('v_temp value:' || v_temp); end; --变量声明：使用%type属性 declare v_empno number(4); v_empno2 emp.empno%type; v_empno3 v_empno2%type; begin dbms_output.put_line('test for type'); end; 第四十一课12345678910--Table变量类型,相当于数组类型 declare type type_table_emp_empno is table of emp.empno%type index by binary_integer;//声明类型 v_empnos typa_table_emp_empno; begin v_empnos(0):=7777; v_empnos(1):=7778; v_empnos(-1):=6666; dbms_output.put_line(v_empnos(-1)); end; 123456789101112131415--Record变量类型，相当于类 declare type type_record_dept is record ( deptno dept.deptno%type, dname dept.dname%type, loc dept.loc%type ); v_temp type_record_dept; begin v_temp.deptno:=50; v_temp.dname:='yugang'; v_temp.loc:='beijing'; dbms_output.put_line(v_temp.deptno || ' ' || v_temp.dname || ' ' || v_temp.loc); end; 123456789--使用%rowtype声明record变量 declare v_temp dept%rowtype; begin v_temp.deptno:=50; v_temp.dname:='yugang'; v_temp.loc:='beijing'; dbms_output.put_line(v_temp.deptno || ' ' || v_temp.dname || ' ' || v_temp.loc); end; 12345678910--SQL语句的运用 --select语句必须和into语句一块使用并且只能返回一条记录 --sql%rowcount declare v_name emp.ename%type; v_sal emp.sal%type; begin select ename,sal into v_name,v_sal from emp where empno=7369; dbms_output.put_line(v_name || ' ' || v_sal); end; 123456declare v_temp emp%rowtype; begin select * into v_temp from emp where empno=7369; dbms_output.put_line(v_temp.ename || ' ' || v_temp.eno); end; 123456789/*向dept表中插入一条数据*/declare v_deptno dept.deptno%type:=50; v_dname dept.dname%type:='mm'; v_loc dept.loc%type:='bj'; begin insert into dept values(v_deptno,v_dname,v_loc); commit; end; 12345678910declare v_deptno dept.deptno%type:=50; v_count number; begin --update emp set sal =sal/2 where deptno=v_deptno; --select deptno into v_deptno from emp where empno=7369; select count(*) into v_count from emp; dbms_output.put_line(sql%rowcount || '条记录被影响！'); commit; end; 1234--DDL语句，在PLSQL中使用DDL语句要加上execute immediate,两个单引号代表一个单引号 begin execute immediate 'create table tt(name varchar2(20) default ''Army'')'; end; 1234567891011121314--if语句--取出7369的薪水，如果&lt;1200，则输出‘low’，如果&lt;2000则输出‘middle’，否则‘high’ declare v_sal emp.sal%type; begin select sal into v_sal from emp where empno=7369; if(v_sal&lt;1200) then dbms_output.put_line('low'); elsif(v_sal&lt;2000) then dbms_output.put_line('middle'); else dbms_output.put_line('high'); end if; end; –循环 12345678910--do while循环 declare i binary_integer:=1; begin loop dbms_output.put_line(i); i:=i+1; exit when (i &gt;= 11); end loop; end; -- while循环 declare j binary_integer:=1; begin while j&lt;11 loop dbms_output.put_line(j); j:=j+1; end loop; end; /*逆序输出*/ begin for k in 1..10 loop dbms_output.put_line(k); end loop; for k in reverse 1..10 loop dbms_output.put_line(k); end loop; end; --错误处理（too_many_rows，others，no_data_found） declare v_temp number; begin select empno into v_temp from emp where deptno=10; exception when too_many_rows then dbms_output.put_line(&apos;太多记录了&apos;); when others then dbms_output.put_line(&apos;error&apos;); end; declare v_temp number(4); begin select deptno into v_temp from emp where empno=2222; exception when no_data_found then dbms_output.put_line(&apos;没数据&apos;); end; --创建错误日志 create table errorlog ( id number primary key, errcode number, errmsg varchar2(1024), errdate date ); create sequence seq_errorlog_id start with 1 increment by 1; –SQLCODE 是出错代码，SQLERRM 是出错信息 123456789101112131415 declare v_deptno dept.deptno%type:=10; v_errcode number; v_errmsg varchar2(1024); begin delete from dept where deptno=v_deptno; commit; exception when others then rollback; v_errcode:=SQLCODE; v_errmsg:=SQLERRM; insert into errorlog values(seq_errorlog_id.nextVal,v_errcode,v_errmsg,sysdate); commit; end; –显示错误日志select * from errorlog; –显示错误时间select to_char(errdate , &#39;YYYY-MM-DD HH24:MI:SS&#39;) from errorlog; 第47~48课：cursor（重点） 12345678910 declare cursor c is select * from emp; v_emp c%rowtype; begin open c; fetch c into v_emp; dbms_output.put_line(v_emp.ename); close c; end; 12345678910111213--简单循环 declare cursor c is select * from emp; v_emp c%rowtype; begin open c; loop fetch c into v_emp; exit when(c%notfound); dbms_output.put_line(v_emp.ename); end loop; end; 123456789101112131415161718192021222324252627282930313233declare cursor c is select * from emp; v_emp c%rowtype; begin open c; loop fetch c into v_emp; --下面两行顺序改变后，将会把最后一条记录打印两遍 dbms_output.put_line(v_emp.ename); exit when(c%notfound); end loop; end; ``` ```sql--while循环 declare cursor c is select * from emp; v_emp emp%rowtype; begin open c; fetch c into v_emp; while(c%found) loop dbms_output.put_line(v_emp.ename); fetch c into v_emp; end loop; close c; end; 123456789--for循环 declare cursor c is select * from emp; begin for v_emp in c loop dbms_output.put_line(v_emp.ename); end loop; end; 12345678910--带参数的游标 declare cursor c(v_deptno emp.deptno%type,v_job emp.job%type) is select ename,sal from emp where deptno=v_deptno and job=v_job; --v_emp emp%rowtype; begin for v_emp in c(30,'JAY') loop dbms_output.put_line(v_emp.ename); end loop; end; 123456789101112131415--可更新的游标 declare cursor c is select * from emp for update; --v_temp c%rowtype; begin for v_temp in c loop if(v_temp.sal &lt; 2000) then update emp set sal=sal*2 where current of c; elsif(v_temp.sal=5000) then delete from emp where current of c; end if; end loop; commit; end; 第49～50课：procedure1234567891011121314151617181920--只有create or replace procedure p -- is --替换了最初的declare语句--创建存储过程 create or replace procedure p is cursor c is select * from emp for update; begin for v_temp in c loop if(v_temp.deptno=10) then update emp set sal=sal+10 where current of c; elsif(v_temp.deptno=20) then update emp set sal=sal+20 where current of c; else update emp set sal=sal+50 where current of c; end if; end loop; commit; end; –执行上面的存储过程：exec p; 123456789101112--带参数的存储过程 create or replace procedure p (v_a in number,v_b number,v_ret out number,v_temp in out number) is begin if(v_a&lt;v_b) then v_ret:=v_b; else v_ret:=v_a; end if; v_temp:=v_temp+1; end; 12345678910111213141516171819--调用过程 declare v_a number:=10; v_b number:=20; v_ret number; v_temp number:=99; begin p(v_a,v_b,v_ret,v_temp); dbms_output.put_line(v_ret); dbms_output.put_line(v_temp); end; /* begin P; end 存储过程在创建过程中如果出现错误，仍然会创建，并且不会提示错误在哪儿，可以使用 show error来查看错误出现在哪儿。 */ 1234567891011121314----创建函数 create or replace function tax_sal (v_sal number) return number is begin if(v_sal&lt;2000) then return 0.10; elsif(v_sal&lt;3000) then return 0.20; else return 0.30; end if; end; –执行函数：select tax_sal(sal) from emp; 1234567--触发器 create table emp_log --创建一个表记录操作( uname varchar2(20), action varchar2(10), atime date); 123456789101112131415--after insert：插入之后触发事件--before insert：插入之前触发事件 create or replace trigger trig after/before insert or update or delete on emp2 for each row begin if inserting then insert into emp_log values(USER,'insert',sysdate); elsif updating then insert into emp_log values(USER,'update',sysdate); else insert into emp_log values(USER,'delete',sysdate); end if; end; --更新6行数据 update emp2 set sal = sal * 2 where deptno = 30;12--deptno被参考，违反约束条件 update dept set deptno=99 where deptno=10; 12--删除触发器：drop trigger trig; 123456--创建新的触发器： create or replace trigger trig after update on dept for each row begin update emp set deptno=:NEW.deptno where deptno=:OLD.deptno; end; 12--再更新：update dept set deptno=99 where deptno=10; ————–树状结构的存储和展示——————–123456789101112131415161718create table article(id number primary key,cont varchar2(4000),pid number,isleaf number(1), --0代表非叶子节点，1代表叶子节点alevel number(2));insert into article values(1,'蚂蚁大战大象',0,0,0);insert into article values(2,'大象被打趴下了',1,0,1);insert into article values(3,'蚂蚁也不好过',2,1,2);insert into article values(4,'瞎说',2,0,2);insert into article values(5,'没有瞎说',4,1,3);insert into article values(6,'怎么可能',1,0,1);insert into article values(7,'怎么没有可能',6,1,2);insert into article values(8,'可能性是很大的',6,1,2);insert into article values(9,'大象进医院了',2,0,2);insert into article values(10,'护士是蚂蚁',9,1,3);commit; –展现方法1234567891011121314create or replace procedure p (v_pid article.pid%type, v_level binary_integer) is cursor c is select * from article where pid = v_pid;v_preStr varchar2(1024) := '';begin for i in 1..v_level loop v_preStr := v_preStr || '****'; end loop; for v_article in c loop dbms_output.put_line(v_preStr||v_article.cont); if(v_article.isleaf = 0) thenp(v_article.id, v_level + 1); end if; end loop;end; –执行上面操作exec p(0,0); 结果： 蚂蚁大战大象 ****大象被打趴下了 ********蚂蚁也不好过 ********瞎说 ************没有瞎说 ********大象进医院了 ************护士是蚂蚁 ****怎么可能 ********怎么没有可能 ********可能性是很大的]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle（二） DML、DDL、事务控制语句]]></title>
    <url>%2F2017%2F10%2F22%2FOracle-DDL%2F</url>
    <content type="text"><![CDATA[第二十四课备份与恢复:1— backup scottexp2— create user12create user liuchao identified by liuchao default tablespace users quota 10M on users;grant create session , create table , create view to liuchao; 3— import the data;impDOS环境下:exp导出,imp导入12345678--drop user yugang cascade; //删除YUGANG 用户--cd \ --cd temp --delete *.* --exp --create user yugang indentified by yugang default tablespace users quota 10M on users //创建用户--grant create session,create table,create view to yugang //分配权限--imp the data 第一次输入的用户名密码为:yugang/yugang第二次输入的用户名密码为:导出数据的用户的用户名和密码 12--rollback //取消刚才的操作create table emp2 as select * from emp; //复制emp 插入数据操作：123insert into dept2 values(50 , 'game' , 'bj'); //插入全部值insert into dept2 (deptno , dname) values (60 , 'game2'); //插入部分值insert into dept2 select * from dept; //将一张表插入现在的表 第二十五课:rownumrownum是在Oracle中在表的后面加的一个尾字段,并且只能使用诸如rownum&lt;=n或rownum&lt;=n这样的形式,不能与&gt;或&gt;=相连接在一起 Oracle里面有一个尾字段叫–&gt;rownum 它是按照1，2，3…进行排列的，它不显示所以如果想求&gt;或者&gt;=的行数，可以给rownum起别名，就如下面这么做：select ename from (select rownum r , ename from emp) where r &gt; 10; 1.求薪水值最高的前5条记录.1select ename , sal from (select ename , sal from emp order by sal desc)where rownum &lt;=5; 2.求薪水值最高的第6~10条记录.123456select ename,sal from ( select ename,sal,rownum r from (select ename,sal from emp order by sal desc) ) where r &gt;=6 and r &lt;= 10; 第二十六课:homework_dml_transactionSQL面试题有三张表S、C、SCS(SNO、SNAME)代表（学号、姓名）C(CNO、CNAME、CTEACHER)代表（课号、课名、老师）SC(SNO、CNO、SCGRADE)代表（学号、课号、成绩）1.求出没选过郭富城老师的所有学生姓名2.列出2门以上（含2门）不及格的学生姓名及平均成绩3.既学过1号课程又学过2号课程的所有学生姓名 1.12345678910select sname from s join sc on (s.sno = sc.sno) join c on (c.cno = sc.cno) where c.cteacher &lt;&gt; '郭富城';``` 2.```sqlselect sname from s where sno in ( select sno from sc where scgrade &lt; 60 group by sno having count(*) &gt;= 2 ) 3.12345select sname from s where sno in ( select sno from sc where cno=1 and sno in (select distinct sno from sc where cno=2) ) update 更新表中的数据 把emp2这张表里，编号为10的，所有人的薪水提1倍12update emp2 set sal = sal*2, ename = ename||'-' where depton = 10//修改数据delete from dept2 where depton = 10; 四条语句讲完了：背过语法格式DDL– 数据定义语言，建表，建视图，建其他一些东西。1.创建表– create tablecreate table t (a varchar2(10));2.删除表 drop tabledrop table xx;跳过此阶段，先讲事务控制语句事务transaction代表一组不可分割的操作，要么全部执行，要么全部不执行，transaction起始于一条DML语句，结束于commit;语句，或者是DCL、DDL语句，在事务未提交前 可以通过rollback回滚事务，正常退出事务会自动提交，非正常退出事务会自动回滚。 第二十七课：create table 为什么有变长字符串Varchar2还要有定长字符串Char呢? 因为存在效率问题，用Char效率高，但浪费空间，这就是拿空间换时间Hashtable也是拿空间换时,创建一张表，并往里插入一条数据123456789101112131415161718192021222324create table stu( id number(6), name varchar2(20), sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) );create table stu ( id number(6), name varchar2(20) not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) ); 第二十八~三十课五个约束条件：非空 唯一 主键 外键 check主键：PRIMARY KEY 叫做：可以唯一标识整条记录的这样的一个东西从语法上来说主键的约束可以理解为：非空 ，唯一 两个的组合主键约束在逻辑意义上代表着单独的，每一条记录，看到主键就知道你是一条单独的不同的记录，是唯一的代表的记录 我们可以用两个字段的组合作为主键 外键(最麻烦的约束)：建立于一张表的两个字段，或者两张表的两个字段constraint stu_class_fk foreign key (class)references class (id) 外键关系：是建立在两个字段上，某一个字段会参考另外一个字段里面的值，如果另外一个字段里面没有这个值，你不能够把这个字段里面的值，设置成为其他的值。被参考的字段必须是主键，被其他人参考的字段不能作为删除条件主键约束和外键约束非常重要，老牢牢掌握其概念 1.唯一约束–&gt;在这个字段里面所有的记录不能取重复的值，每个值必须是唯一的 唯一约束后面 + unique ，当然也可以用constraint + 名字字段级的约束：把约束条件+在字段名的后面表级的约束：+在所有字段名的最后面 constraint stu_name_email_uni unique(email,name) 表示的是：这两个字段的组合不能重复 2.constraint//非空约束约束条件本身也是一个对象，本身约束条件你个可以为它起一个名字用constraint stu_name_nn not null –&gt;为约束条件not null起名字为：stu_name_nn如果不给约束条件起名字，系统会默认的给约束条件起一个名字 not null,unique(当某字段有unique约束时，可以插入空值，空值之间不重复)、主键、外键、 check约束123456789101112create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, //（字段级约束）sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) unique //unique唯一约束 都为空可以) / //名字和email的组合不能重复：行级约束（放在字段后面）与表级约束（加在表后面）：12345678910111213create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_email_name_uni unique(name,email) //name,email的组合唯一约束（表级约束）) / 主键约束123456789101112131415161718192021222324252627create table student ( id number(6) primary key, name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_email_name_uni unique(name,email) ) / create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_id_pk primary key(id), constraint stu_email_name_uni unique(name,email) ) / 外键约束外键约束被参考的字段必须是主键。 先建表：123456create table class ( id number(4) primary key, name varchar2(20) not null ) / 第一种创建外键的方法：1234567891011121314create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4) references class(id), email varchar2(50), constraint stu_id_pk primary key(id), constraint stu_email_name_uni unique(name,email) ) / 第二种创建外键的方法：123456789101112131415create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_id_pk primary key(id), constraint stu_class_fk foreign key (class) references class(id), constraint stu_email_name_uni unique(name,email) ) / 第三十一课：123456789alter table drop table //修改表结构；alter table student add(addr varchar2(100)); //添加结构alter table student drop(addr); //删除结构alter table student modify(addr varchar2(50)); //修改若addr字段中有的记录长度大于50，则修改不成功。 alter table student drop constraint stu_class_fk; //去掉约束条件alter table student add constraint stu_class_fk foreign key (class) references class (id); //添加约束条件drop table class; 第二范式的要求：当一张表里面有多个字段作为主键的时候，非主键的这些字段，不能依靠于部分主键(只能依赖整个组合的主键，不能依赖部分) 叫做：不能存在部分依赖第三范式的要求：不能存在传递依赖(除了主键之外的任何其他字段必须直接依赖于主键) 第三十二课：Oracle dictionaries1234567desc user_tables; select table_name from user_tables; select view_name from user_views; select constraint_name from user_constraints; select constraint_name,table_name from user_constraints; desc dictionary; //显示目录字典表select table_name from dictionary where table_name like ‘user%’; //显示目录字典表中’user’开头的名字 第三十三课：indexes_and_views索引可以提高读数据的效率，但会降低修改、写数据的效率,索引还会占用一定的存储空间12create index idx_stu_email on student(email); drop index idx_stu_email; 视图会带来一些维护的代价，比如表结构改了，那么视图也得跟着改变。视图还可以用来保护私有数据。123select index_name from user_indexes; select view_name from user_views; create view v$_stu as select id , name , age from student; 视图其实就是一个子查询，可以用来更新数据，但是不经常这么用，目的是为了简化查询，保护私有数据。 第三十四课：sequences and review序列可以自动增长，在sql server中有identity，mysql中有auto_increment1234567create table article ( id number, title varchar2(1024), cont long ) / 如何保证插入数据时id不重复？select max(id) from article;这样做也不行，如果有多个线程同时访问数据，则可能会出现数据不一致的现象，比方说第一个用户查询出最大id值是100，第二个用户也查询出最大id是100，然后第二个用户新插入一条记录：id是101，然后第一个用户也插入了一条记录：id也是101可以用Oracle的sequencecreate sequence seq_article_id;多个表之问可以共用一个序列，但是一般情况下为每个字段分别建立一个序列sequence有两个属性CurrVal、NextVal12345select seq.nextvalue from dual; insert into article values(seq.nextval,'y','yy'); insert into article values(seq.nextval,'x','xx'); insert into article values(seq.nextval,'z','zz'); insert into article values(seq.nextval,'q','qq'); 删除序列：drop sequence seq; 第三十五课：三范式第一范式：1.每个表都要有主键2.列不可分，比如：1234567891011121314create table stu ( id number, name varchar2(20), age number ) / insert into stu values(1,'yu',21); create table stu2 ( inf long ) / insert into stu2 values('1_yu_21'); 虽然表stu2可以字符串解析后可以达到和表stu一样的效果，但是显然第一种方法更好，查询数据更加方便，而表stu2违反了第一范式的列不可分原则。 第二范式：当有两个以上字段作主键时，非主键字段不能部分依赖于主键字段，如有一个需求，一名老师教多名学生，一名学生可以选多个老师的课。然后设计了一张表，有以下字段（老师编号、学生编号、老师姓名、学生姓名等），其中以老师编号和学生编号作联合主键，则些表就存在部分依赖，老师姓名部分依赖于老师编号，不满足第二范式，有数据冗余。要解决这个问题可以设计三张表：老师表，学生表，老师学生关系表。 第三范式：不能存在传递依赖，如有一张表有以下字段：（学号、姓名、班级号、班级名称、班级位置），其中学号为主键，则班级号依赖于学号，每个学生都有相应的班级号，但是班级名称、班级位置 是依赖于班级号，即它们通过班级号传递依赖于学号，不满足第三范式。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle（一） Select语句]]></title>
    <url>%2F2017%2F10%2F14%2FOracle-Select%2F</url>
    <content type="text"><![CDATA[第一课：口令超级管理员：sqlplus sys/bjsxt as sysdba普通管理员：system/manager普通用户：scott/tiger大数据用户：sh/sh 在cmd下敲：12sqlplus sys/bjsxt as sysdba //以sys超级管理员的权限去登录bjsxt 这个数据库alter user scott account unlock; //(解锁)用户已更改。 第二课：SQL语言Sql语言是在数据库地下进行操作的专门的语言，sql语言本身是一种标准语言，它是一个国际标准，它定义了套标准SQL1922， SQL1999，SQL在大多数数据库上通用，或许有轻微的改变包含四大语句： 查询语句 查询语句只有一种就是select语句 DML语句 DML语句包含Insert,Update,Delete等常用语句 DDL语句 DDL语句包含Create, Alter， Drop等常用语句 事务控制语句 包含Commit， Rollback等常用语句还有一大类语句：叫DCL语句（Data Control Language），主要用于权限的分配与回收，由于与开发关系不是十分密切，不做重点讲解Select语句就是从表里把数据选出来首先熟悉试验中的数据第一条语句：desc emp; desc 表名; 列出 表头 == 字段 == 列Varchar2 可变字符串支持国际化 NUMBER(7,2) 7位的数字，2位的小数每行显示的宽度setlinesize 200; 显示的页数 setpagesize 30; 第三课：table_structures12desc 表名 //描述表select * from 表名 //查看表数据 第四课：select语句1.含有别名的sql语句例子1：1select ename, sal&amp;#42;12 annual_sal from emp; 例子2：1Select ename, sal&amp;#12 “Annual_sal” from emp; 如果想让别名强制大小写混合可以使用双引号 例子3：1Select ename, sal&amp;#12 “Annual sal” from emp; 如果想让别名中有空格也使用双引号 2.1desc dual，select 2*3 from dual，dual是系统自带的一张空表，计算数据时可以使用该表 3.任何含有空值的算术表达式的计算结果是空值 4.select ename||sal from emp; 字符串连接符：|| 5.select ename || &#39;abcdefg&#39; from emp; 6.select ename || &#39;abcd&#39;&#39;efg&#39; from emp;当字符串中含有单引号时，可用两个单引号代表一个单引号 7.set linesize 200;--用于设定每行显示的宽度 8.set pagesize 30;--设置显示的页数 9.select syadate from dual;//显示系统时间 第五课：distinct1.select distinct deptno from emp; //把deptno值重复的不显示出来 2.select distinct deptno,job from emp; //把deptno,job都重复的都不显示出来； 第六课：where1.select * from emp where empno = 10; //显示部门编号为10的所有员工的详细信息 2.select * from emp where empno &lt;&gt; 10;//&lt;&gt;是不等于 3.select * from emp where ename = &#39;KING&#39;; //显示名字为KING的员工的详细信息, 判断字符串是否相等时，字符串要用单引号引起来，单引号中字符串内容是要区分大小写的；比较的按字母顺序 4.select * from emp where comm is (not) null; //为空值的表项查询 5. AND， OR， NOT例1：Select ename, deptno, sal from emp wheredeptno = 10 and sal &gt; 1000; 查询部门标号为10 并且薪水&gt;1000 的员工 例2：Select ename, deptno, job from emp where deptno = 10 or job = ‘CLEARK; 查询部门编号为10或者工作岗位为CLERK 的员工 例3：select * from emp where sal (not) between 800 and 1500; //取出薪水位于800和1500(包含800和1500)之间的雇员名字和薪水 6.In语句：用于塞选某一个值12select * from emp where ename (not) in ('smith','philip','jay'); //把名字为SMITH, ALLEN, KING 的雇员取出来Select ename, sal from emp where sal in(800, 1250, 1500, 2000); //把薪水是800，1250， 1500， 2000 的雇员信息取出来 7.1select * from emp where hiredate &gt; '20-2 月 1820'； //20-2 月 1820后的时间, 如果想用自己定义的日期格式，可以使用to_char or to_date函数; Oracle默认的日期格式为：DD-MON-RR 8.模糊查询使用like关键字，和通配符 % 表示0个或多个字符，&#95;表示1个字符, “?”为0个或1个123select * from emp where ename like '_A%'; // 查询第二字母中含有 A 的雇员 select * from emp where ename like '_\%a%'; //系统默认转义符是\,可以自己指定转义符 select * from emp where ename like '_$%a%' escape '$'; 第七课：order by 使用order by对数据进行排序123select * from dept; select * from dept order by dept desc; //(默认为asc) desc为降序排列，asc为升序 select ename, sal, deptno from emp where sal &gt; 2000 order by deptno asc,ename desc; 第八课：sql_function1.select ename,sal*12 annual_sal from emp where ename not like &#39;_A%&#39; and sal &gt; 1500 order by sal desc; 2.select lower(ename) from emp; // Lower()函数 将字符串全部转换成小写,把ename 转换为小写值 3.select ename from emp where lower(ename) like &#39;_a%&#39;; //把ename的值第二个字母为A或a输出 4.select substr(ename,2,3) from emp; //从第二字符截，一共截三个字符。 5.select chr(65) from dual; //求一个与某个ASCII码值对应的字符,结果为A 6.select ascii(&#39;a&#39;) from dual; //求一个字符的ASCII码值,结果为65 7.round()函数 对参数值进行四舍五入的操作例子1： Select round(23.652)from dual; //对23.652进行四舍五入操作 24例子2： Select round(23.652,2) from dual; //对23.652四舍五入到小数点后2位 23.65例子3： Select round(23.652,-1) from dual; //用负数指定小数点前面几位,对23.652四舍五入到小数点前1位 20 &#42;8.to_char() 用于将数字或日期转换成特定的字符串，To_char()有两个参数：第一个参数：需要进行转换的日期或数字第二个参数：特定的转换格式，对于数字有一下几个格式可以指定：9 代表数字，若果该位没有数字则不进行显示，但对于小数点后面的部分仍会强制显示0 代表一位数字，如果该位没有数字则强制显示0 1234select to_char(sal,'$99,999.9999') from emp; //to_char函数主要用于对日期和数字格式化 $16,000.0000select to_char(sal,'$0000,000.0000') from emp; //结果$0016,000.0000select to_char(sal,'L99,999.9999') from emp; //人民币符号，L代表本地符号。 select birthdate from emp; 显示为：BIRTHDATE&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;22-3月-87改为：select to_char(birthdate,&#39;YYYY-MM-DD HH24:MI:SS&#39;) from emp; //24制的 没有24为12制的 格式控制符 含义YYYY、YY —————————– 代表4位，2位数字的年份MM —————————– 用数字表示的月份MON —————————– 月份的缩写对中文月份来说就是全称DD —————————– 数字表示的日DY —————————– 星期的缩写，对中文的星期来说就是全称HH24、HH12 —————————12小时或者24小时进制下的时间MI —————————– 分钟数SS —————————– 秒数 &#42;9.to_data函数将特定的字符串转换成日期格式，这个函数有两个参数:第一参数：自定义的日期字符串第二参数：指定这个字符串的格式1select ename,birthdate from emp where birthdate &gt; to_date('1987-3-22 12:00:00','YYYY-MM-DD HH24:MI:SS'); //不能直接写birthdate&gt;'1987-2-22 11:22:33'会出现格式不匹配，因为表中格式为DD-MM月－YY 10.Select * from emp where sal &gt; to_number(‘$1,200.00’,‘$9,999.99’); //求薪水大于1200的员工信息 &#42;11.nvl()函数用来处理空值，这个函数有两个参数：第一参数：字段名或表达式，如果这个参数值为null，就返回第二参数值，否则返回第一参数值1select ename, sal*12+nvl(comm,0) from emp //这样防止comm为空时，sal*12相加也为空的情况 第九课：Group function 组函数1.select max(sal) from emp; //最大值 2.select min(sal) from emp; //最小值 3.select to_char(avg(sal), &#39;$999,999,999.99&#39;) from emp; //平均值 4.select round(sum(sal),2) from emp; //求和 5.select count(*) from emp where sal &gt; 1500; //求记录数 6.select count(comm) from emp; //Count()可以对单独字段使用，得到的是所有非空记录的数量 7.select count(distinct deptno) from emp; //Count()可以和distinct一起使用，得到所有唯一值记录的数量 第十课：Group by语句1.select avg(sal) from emp group by deptno; //首先将现有数据按照部门进行分组，然后再计算每个组员工的平均薪水 2.select deptno,avg(sal) from emp group by deptno; 3.select deptno,job,max(sal) from emp group by deptno,job; //按照部门，和职位的最大薪水进行分组 4.求薪水值最高的人的名称select ename,max(sal) from emp; //出错，因为max只能有一个值，但是等于max的值可能有好几个，不能匹配。 可以写成select ename from emp where sal=(select max(sal) from emp);Group by 语句应注意，出现在select中的字段，如果没有出现在组函数中，必须出现在Group by语句中。 第十一课：Having对分组结果筛选1.where是对单条记录进行筛选,Having是对分组结果进行筛选select avg(sal),deptno from emp group by deptno having avg(sal) &gt; 2000; 2.查询工资大于2000的雇员,按照部门编号进行分组,分组后平均薪水大于1500,按工资倒序排列select deptno,avg(sal) from emp where sal &gt; 2000 group by deptno having avg(sal) &gt;1500 order by avg(sal) desc; ///////select-where-group by- having-order by//////// 第十二课:子查询1.select 语句中嵌套select 语句,求哪些人工资在平均工资之上.select ename,sal from emp where sal &gt; (select avg(sal) from emp); 2.查找每个部门挣钱最多的那个人的名字.select ename, deptno from emp where sal in (select max(sal) from emp group by deptno); 查询会多值.正确写法是: 应把select max(sal),deptno from emp group by deptno当成一个表,给这个表起名叫t,然后将两张表连接起来就可以了。语句如下:123select ename,sal from emp join (select max(sal) max_sal,deptno from emp group by deptno) t on (emp.sal = t.max_sal and emp.deptno = t.deptno); 第十三课:self_table_connection自连接：为同一张表起不同的别名，然后当成两张表来用1select e1.ename,e2.ename from emp e1,emp e2 where e1.mgr = e2.empno; //求这个人的名字和他经理人的名字(自连接) 第十四课:SQL1999_table_connection1.select ename,dname,grade from emp e,dept d,sqlgrade s where e.deptno=d.deptno and e.sal between s.losal and s.hisal and job &lt;&gt; &#39;CLERK&#39;;这种写法没有把过滤条件和连接条件分开来,由于这个原因,sql1999标准推出来了. 2.select ename,dname from emp,dept;(旧标准) select ename,dname from emp cross join dept;(1999标准) 3.等值连接 123select ename,dname from emp,dept where emp.deptno = dept.deptno;(旧) select ename,dname from emp join dept on (emp.deptno = dept.deptno);select ename , dname from emp join dept using (deptno); //不推荐使用 4.非等值连接： select ename,grade from emp e join salgrade s on(s.sal between s.losal and s.hisal); 5.select ename,dname,grade from emp e join dept d on(e.deptno = d.deptno) join salgrade s on (e.sal between s.losal and s.hisal) where ename not like &#39;_A%&#39;; 6.select e1.ename,e2.ename from emp e1 join emp e2 on (e1.mgr = e2.deptno); 7.select e1.ename,e2.ename from emp e1 left (outer) join emp e2 on (e1.mgr = e2.empno); //left outerjoin或者left join都可以！即为左连接。 8.select ename,dname from emp e right outer join dept d on (e.deptno = d.deptno); //右连接 9.select ename,dname from emp e full join dept d on (e.deptno = d.deptno); //全连接 第十六至二十三课:求部门平均薪水等级1.A.求部门平均薪水的等级select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal); 2.求部门平均的薪水等级select deptno,avg(grade) from (select deptno,ename,grade from emp e join salgrade s on (emp.sal between s.losal and s.hisal)) t group by deptno; 3.哪些人是经理select ename2 from (select e1.ename ,e1.mgr mgr1,e2.ename ename2 from emp e1 join emp e2 on (e1.mgr = e2.empno)) t join emp on (t.mgr1 = emp.empno) select ename from emp where empno in (select distinct mgr from emp) 4.不准用组函数,求薪水的最高值select distinct sal from emp where sal not in( select distinct e1.sal from emp e1 join emp e2 on (e1.sal &lt; e2.sal) ) ; 5.求平均薪水最高的部门编号123456789101112131415//方法1select deptno,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno ) where avg_sal = ( select max(avg_sal) from ( select deptno,avg(sal) avg_sal from emp group by deptno ) ) ;//方法2select deptno,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno) where avg_sal = (select max(avg(sal)) from emp group by deptno) ; 6.求平均薪水最高的部门名称12345678910select dname from dept where deptno = ( select deptno from (select deptno,avg(sal) avg_sal from emp group by deptno) where avg_sal = ( select max(avg_sal) from (select deptno,avg(sal) avg_sal from emp group by deptno) ) ) ; 7.求平均薪水等级最低的部门的部门名称错误写法:1234567select min(avg_grade),deptno from ( select deptno,avg(grade) avg_grade ( select ename,deptno,grade from emp e join salgrade s on (e.sal between s.losal and s.hisal) ) group by deptno ) group by deptno 正确写法:123456789101112131415select dname,t1.deptno,grade,avg_sal from ( select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal) ) t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select min(grade) from ( select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal) ) ) ; 错误写法：1234567891011121314select dname,t1.deptno,grade,avg_sal from ( select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal) ) t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select min(grade) from ( t1) ) ;//报错：表或视图不存在。 8.视图:view就是一张虚表,一个子查询 conn sys/bjsxt as sysdba; grant create table,create view to scott; conn scott/tiger;创建视图1234create view v$_dept_avg_sal_info as select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal); 使用视图后可以简写123456select dname,t1.deptno,grade,avg_sal from v$_dept_avg_sal_info t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select min(grade) from v$_dept_avg_sal_info ); 9.求比普通员工最高薪水还要高的经理人的名称先求普通员工的最高薪水12345678910select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null); select ename from emp where empno in (select distinct mgr from emp where mgr is not null) and sal &gt; ( select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null) ); 思考题： 求部门经理人中平均薪水最低的部门名称 求薪水最高的前五名雇员 求薪水最高的第6到第10名雇员（重点掌握） 练习：求最后入职的5名员工 面试题：比较效率select &#42; from emp where deptno = 10 and ename like ‘%A%’; （效率比较高）select &#42; from emp where ename like ‘%A%’ and deptno = 10;（Oracle可能会优化，直接把这条语句转换成上面那条，使效率提高）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（九） 接口]]></title>
    <url>%2F2017%2F10%2F14%2FThinkingInJava9%2F</url>
    <content type="text"><![CDATA[接口和内部类为我们提供了一种将接口与实现分离更加结构化的方法。 抽象类是类与接口之间的一种中庸之道。 9.1 抽象类和抽象方法Java提供了一个叫做抽象方法的机制，类似于C++中的纯虚函数，这种方法仅有声明而没有方法体：abstract void f();抽象类的特点： 如果一个类包含一个或多个抽象方法，则必须被限定为抽象类。（反过来，如果一个类被定义为abstract的，不一定要有抽象方法） 不能实例化抽象类。 继承抽象类，如果没有实现所有的抽象方法，那么还是抽象类。 9.2 接口接口被用来建立类与类之间的协议（某些面向对象编程语言使用关键字protocol来完成这个功能） interface产生一个完全抽象的类，允许创建者确定方法名、参数列表和返回类型。但只提供形式，不提供实现。（Java SE8提供了default关键字，可以定义默认的方法，该方法提供实现）。 接口可以有域，但这些域被隐式的声明为static 和final 可以在接口中显示的把方法声明为public，默认就是public，而且必须是public，方法不能是static和final的。 9.3 完全解耦创建一个能够根据所传递的参数对象的不同而具有不同行为的方法，被称为策略设计模式。这类方法包含所要执行的算法中固定不变的部分，而“策略”包含变化的部分。策略就是传递进去的参数对象，包含要执行的代码，可以根据传递的参数的对象产生不同的行为。 复用代码的第一种方式就是客户端程序员遵循该接口来编写他们的类；第二种方式：如果无法修改使用的类，则可以使用适配器设计模式。 9.4 多重继承接口可以实现多重继承，implements可以接多个接口，用逗号分开即可。 接口使用的核心原因：能向上转型为多个基类型（以及由此带来的灵活性）；与抽象基类相同，防止客户端程序员创建该类的对象。 应该使用接口还是抽象类：如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。事实上，如果知道某事物应该成为一个基类，那么第一选择应该是使它成为一个接口。 9.5 通过继承来扩展接口1234567891011interface Monster&#123; void menace();&#125;interface DangerousMonster extends Monster&#123; void destroy();&#125;interface Vampire extends DangerousMonster , Monster&#123; void drinkBlood();&#125; 在上面的例子中，在Vampire中使用的语法仅适用于接口继承。一般情况下，只可以将extends用于单一类，但是可以引用多个基类接口。就像所看到的那样，只需用逗号将接口名一一分割开即可。 9.5.1 组合接口时的名字冲突在打算组合不同接口中使用相同的方法名通常会造成代码可读性的混乱，应该尽量避免这种情况。 1234567891011interface I1&#123;void f();&#125;interface I2&#123;int f(int i);&#125;interface I3&#123;int f();&#125;class C2 implements I1,I2&#123; public void f()&#123;&#125; public int f(int i)&#123;return 1;&#125;&#125;//class C5 extends C implements I1 &#123;&#125; //出错//interface I4 extends I1 , I3 &#123;&#125; //出错 9.6 适配接口让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方式。这就是使用接口而不是类的强大之处。 9.7 接口中的域放入接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的创建常量组的工具（Java SE5出现了enum）。接口中的域是public的。 9.7.1 初始化接口中的域接口中定义的域不能是“空final”，但是可以被非常量表达式初始化。 如：1234public interface RandVals&#123; Random RAND = new Random(47); int RANDOM_INT = RAND.nextInt(10);&#125; 这个例子中，域不是接口的一部分，值存于静态存储区域内。 9.8 嵌套接口接口中成员默认就是public的，接口嵌套在接口中只能是public的。类中嵌套接口或类可以是4种访问权限。当实现某个接口时，并不需要实现嵌套在其内部的任何接口。而且，private接口不能在定义它的类之外被发现，返回private接口仅可以被定义它的类的方法使用。 9.9 接口与工厂生成遵循某个接口的对象的典型方式就是工厂方法设计模式。通过工厂方法模式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换为另一个实现。 优先选择类而不是接口，从类开始，如果接口的需要性变得非常明确，那么就进行重构。接口是一种重要的工具，但他们容易被滥用。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 默认方法（Default Methods）]]></title>
    <url>%2F2017%2F10%2F14%2FJavaSE8defaultMethod%2F</url>
    <content type="text"><![CDATA[Java 8 引入了新的语言特性——默认方法（Default Methods）。 Default methods enable new functionality to be added to the interfaces of libraries and ensure binary compatibility with code written for older versions of those interfaces.默认方法允许您添加新的功能到现有库的接口中，并能确保与采用旧版本接口编写的代码的二进制兼容性。默认方法是在接口中的方法签名前加上了 default关键字的实现方法。一个简单的例子123456789101112131415interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;class ClassA implements InterfaceA &#123;&#125;public class Test &#123; public static void main(String[] args) &#123; new ClassA().foo(); // 打印：“InterfaceA foo” &#125;&#125; ClassA 类并没有实现 InterfaceA 接口中的 foo 方法，InterfaceA 接口中提供了 foo 方法的默认实现，因此可以直接调用 ClassA 类的 foo 方法。 为什么要有默认方法在 java 8 之前，接口与其实现类之间的 耦合度 太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为 java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。1234567String[] array = new String[] &#123; "hello", ", ", "world",&#125;;List&lt;String&gt; list = Arrays.asList(array);list.forEach(System.out::println); // 这是 jdk 1.8 新增的接口默认方法 这个 forEach 方法是 jdk 1.8 新增的接口默认方法，正是因为有了默认方法的引入，才不会因为 Iterable 接口中添加了 forEach 方法就需要修改所有 Iterable 接口的实现类。 下面的代码展示了 jdk 1.8 的 Iterable 接口中的 forEach 默认方法： 12345678910111213package java.lang;import java.util.Objects;import java.util.function.Consumer;public interface Iterable&lt;T&gt; &#123; default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125;&#125; 默认方法的继承和其它方法一样，接口默认方法也可以被继承。123456789101112131415161718192021222324252627282930313233343536interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;interface InterfaceB extends InterfaceA &#123;&#125;interface InterfaceC extends InterfaceA &#123; @Override default void foo() &#123; System.out.println("InterfaceC foo"); &#125;&#125;interface InterfaceD extends InterfaceA &#123; @Override void foo();&#125;public class Test &#123; public static void main(String[] args) &#123; new InterfaceB() &#123;&#125;.foo(); // 打印：“InterfaceA foo” new InterfaceC() &#123;&#125;.foo(); // 打印：“InterfaceC foo” new InterfaceD() &#123; @Override public void foo() &#123; System.out.println("InterfaceD foo"); &#125; &#125;.foo(); // 打印：“InterfaceD foo” // 或者使用 lambda 表达式 ((InterfaceD) () -&gt; System.out.println("InterfaceD foo")).foo(); &#125;&#125; 接口默认方法的继承分三种情况（分别对应上面的 InterfaceB 接口、InterfaceC 接口和 InterfaceD 接口）：&nbsp;&nbsp;• 不覆写默认方法，直接从父接口中获取方法的默认实现。&nbsp;&nbsp;• 覆写默认方法，这跟类与类之间的覆写规则相类似。&nbsp;&nbsp;• 覆写默认方法并将它重新声明为抽象方法，这样新接口的子类必须再次覆写并实现这个抽象方法。 默认方法的多继承Java 使用的是单继承、多实现的机制，为的是避免多继承带来的调用歧义的问题。当接口的子类同时拥有具有相同签名的方法时，就需要考虑一种解决冲突的方案。12345678910111213141516171819202122232425262728293031323334353637interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;interface InterfaceB &#123; default void bar() &#123; System.out.println("InterfaceB bar"); &#125;&#125;interface InterfaceC &#123; default void foo() &#123; System.out.println("InterfaceC foo"); &#125; default void bar() &#123; System.out.println("InterfaceC bar"); &#125;&#125;class ClassA implements InterfaceA, InterfaceB &#123;&#125;// 错误//class ClassB implements InterfaceB, InterfaceC &#123;//&#125;class ClassB implements InterfaceB, InterfaceC &#123; @Override public void bar() &#123; InterfaceB.super.bar(); // 调用 InterfaceB 的 bar 方法 InterfaceC.super.bar(); // 调用 InterfaceC 的 bar 方法 System.out.println("ClassB bar"); // 做其他的事 &#125;&#125; 在 ClassA 类中，它实现的 InterfaceA 接口和 InterfaceB 接口中的方法不存在歧义，可以直接多实现。 在 ClassB 类中，它实现的 InterfaceB 接口和 InterfaceC 接口中都存在相同签名的 foo 方法，需要手动解决冲突。覆写存在歧义的方法，并可以使用 InterfaceName.super.methodName(); 的方式手动调用需要的接口默认方法。 接口继承行为发生冲突时的解决规则值得注意的是这么一种情况：12345678910111213141516171819202122232425interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;interface InterfaceB extends InterfaceA &#123; @Override default void foo() &#123; System.out.println("InterfaceB foo"); &#125;&#125;// 正确class ClassA implements InterfaceA, InterfaceB &#123;&#125;class ClassB implements InterfaceA, InterfaceB &#123; @Override public void foo() &#123;// InterfaceA.super.foo(); // 错误 InterfaceB.super.foo(); &#125;&#125; 当 ClassA 类多实现 InterfaceA 接口和 InterfaceB 接口时，不会出现方法名歧义的错误。当 ClassB 类覆写 foo 方法时，无法通过 InterfaceA.super.foo(); 调用 InterfaceA 接口的 foo方法。 因为 InterfaceB 接口继承了 InterfaceA 接口，那么 InterfaceB 接口一定包含了所有 InterfaceA 接口中的字段方法，因此一个同时实现了 InterfaceA 接口和 InterfaceB 接口的类与一个只实现了 InterfaceB 接口的类完全等价。 这很好理解，就相当于 class SimpleDateFormat extends DateFormat 与 class SimpleDateFormat extends DateFormat, Object 等价（如果允许多继承）。 或者换种方式理解：1234567891011121314151617181920class ClassC &#123; public void foo() &#123; System.out.println("ClassC foo"); &#125;&#125;class ClassD extends ClassC &#123; @Override public void foo() &#123; System.out.println("ClassD foo"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; ClassC classC = new ClassD(); classC.foo(); // 打印：“ClassD foo” &#125;&#125; 这里的 classC.foo(); 同样调用的是 ClassD 类中的 foo 方法，打印结果为“ClassD foo”，因为 ClassC 类中的 foo 方法在 ClassD 类中被覆写了。 在上面的 ClassA 类中不会出现方法名歧义的原因是所谓“存在歧义”的方法其实都来自于 InterfaceA 接口，InterfaceB 接口中的“同名方法”只是继承自 InterfaceA 接口而来并对其进行了覆写。ClassA 类实现的两个接口不是两个毫不相干的接口，因此不存在同名歧义方法。 而覆写意味着对父类方法的屏蔽，这也是 Override 的设计意图之一。因此在实现了 InterfaceB 接口的类中无法访问已被覆写的 InterfaceA 接口中的 foo 方法。 这是当接口继承行为发生冲突时的规则之一，即 被其它类型所覆盖的方法会被忽略。 如果想要调用 InterfaceA 接口中的 foo 方法，只能通过自定义一个新的接口同样继承 InterfaceA 接口并显示地覆写 foo 方法，在方法中使用 InterfaceA.super.foo(); 调用 InterfaceA 接口的 foo 方法，最后让实现类同时实现 InterfaceB 接口和自定义的新接口，代码如下：12345678910111213141516171819202122232425262728interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;interface InterfaceB extends InterfaceA &#123; @Override default void foo() &#123; System.out.println("InterfaceB foo"); &#125;&#125;interface InterfaceC extends InterfaceA &#123; @Override default void foo() &#123; InterfaceA.super.foo(); &#125;&#125;class ClassA implements InterfaceB, InterfaceC &#123; @Override public void foo() &#123; InterfaceB.super.foo(); InterfaceC.super.foo(); &#125;&#125; 注意！ 虽然 InterfaceC 接口的 foo 方法只是调用了一下父接口的默认实现方法，但是这个覆写 不能省略，否则 InterfaceC 接口中继承自 InterfaceA 接口的隐式的 foo 方法同样会被认为是被 InterfaceB 接口覆写了而被屏蔽，会导致调用 InterfaceC.super.foo() 时出错。 通过这个例子，应该注意到在使用一个默认方法前，一定要考虑它是否真的需要。因为 默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。滥用默认方法可能给代码带来意想不到、莫名其妙的错误。 接口与抽象类当接口继承行为发生冲突时的另一个规则是，类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的。 1234567891011121314151617181920212223242526272829303132interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125; default void bar() &#123; System.out.println("InterfaceA bar"); &#125;&#125;abstract class AbstractClassA &#123; public abstract void foo(); public void bar() &#123; System.out.println("AbstractClassA bar"); &#125;&#125;class ClassA extends AbstractClassA implements InterfaceA &#123; @Override public void foo() &#123; InterfaceA.super.foo(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; ClassA classA = new ClassA(); classA.foo(); // 打印：“InterfaceA foo” classA.bar(); // 打印：“AbstractClassA bar” &#125;&#125; ClassA 类中并不需要手动覆写 bar 方法，因为优先考虑到 ClassA 类继承了的 AbstractClassA抽象类中存在对 bar 方法的实现，同样的因为 AbstractClassA 抽象类中的 foo 方法是抽象的，所以在 ClassA 类中必须实现 foo 方法。 虽然 Java 8 的接口的默认方法就像抽象类，能提供方法的实现，但是他们俩仍然是 不可相互代替的：&nbsp;&nbsp;• 接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。&nbsp;&nbsp;• 接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法，无法保存 状态（state），抽象方法中可以。&nbsp;&nbsp;• 抽象类不能在 java 8 的 lambda 表达式中使用。&nbsp;&nbsp;• 从设计理念上，接口反映的是 “like-a” 关系，抽象类反映的是 “is-a” 关系。 接口静态方法除了默认方法，Java 8 还在允许在接口中定义静态方法。123456789101112131415interface InterfaceA &#123; default void foo() &#123; printHelloWorld(); &#125; static void printHelloWorld() &#123; System.out.println("hello, world"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; InterfaceA.printHelloWorld(); // 打印：“hello, world” &#125;&#125; 其他注意点&nbsp;&nbsp;• default 关键字只能在接口中使用（以及用在 switch 语句的 default 分支），不能用在抽象类中。&nbsp;&nbsp;• 接口默认方法不能覆写 Object 类的 equals、hashCode 和 toString 方法。&nbsp;&nbsp;• 接口中的静态方法必须是 public 的，public 修饰符可以省略，static 修饰符不能省略。&nbsp;&nbsp;• 即使使用了 java 8 的环境，一些 IDE 仍然可能在一些代码的实时编译提示时出现异常的提示（例如无法发现 java 8 的语法错误），因此不要过度依赖 IDE。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（八） 多态]]></title>
    <url>%2F2017%2F10%2F14%2FThinkingInJava8%2F</url>
    <content type="text"><![CDATA[在面向对象的程序设计语言当中，多态是继数据抽象和继承之后的第三种基本特征。 多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能创建可扩展的程序。“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。而多态的作用则是消除类型之间的耦合关系。 多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出来而来的。这种区别是根据方法行为的不同来表现出来的，虽然这些方法都可以通过同一个基类来调用。 8.2 转机8.2.1 方法调用绑定将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定，叫做前期绑定。后期绑定，它的含义就是在运行时根据对象的类型进行绑定，后期绑定也叫动态绑定或者运行时绑定。编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体。 Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着通常情况下，我们不必去判定是否要进行后期绑定，因为它会自动发生。 8.2.3 可扩展性在一个设计良好的OOP程序中，大多数或者所有方法都只会与积累接口通信。这样的程序是可扩展的，因为可以从通用的基类及惩处新的数据类型，从而添加一些新的功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。 我们所做对的代码修改，不会对程序中其他不应受到影响的部分产生破坏。多态是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。 8.2.4 缺陷：“覆盖”私有方法只有非private方法才可以被覆盖；但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切地说，在导出类中，对于基类中的private方法，最好采用不同的名字。 8.2.5 缺陷：域与静态方法只有普通方法的调用是多态的。 1234567891011121314151617181920212223class Super &#123; public int field = 0; public int getField()&#123;return field; &#125;&#125;class Sub extends Super&#123; public int field = 1; public int getField()&#123;return field;&#125; public int getSuperField()&#123;return super.field;&#125;&#125;public class FieldAccess&#123; public static void main(String[] args)&#123; Super sup = new Sub(); System.out.println("sup.field = " + sup.field + ", sup.getField() = " + sup.getField()); Sub sub = new Sub(); System.out.println("sub.field = " + sub.field + ",sub.getField() = " + sub.getField() + ",sub.getSuperField() = " + sub.getSuperField()); &#125;&#125;/*Output:sup.field = 0, sup.getField() = 1sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0*/ 上面的例子中，当Sub对象转型为Super引用的时候，任何域访问操作都将由编译器解析，因此不是多态。在本例中，为Super.field和Sub.field分配了不同的存储空间。这貌似是一个令人混淆的问题，但是在实际操作中从来都不会发生。首先通常会将所有的域都设置成private；其次也会将基类和导出类的域赋予不同的名称。 如果某个方法是静态的，它的行为就不具有多态性。 8.3 构造器和多态8.3.2 继承与清理第七章已经讲过了。然而，如果成员对象中存在于其它一个或多个对象共享的情况，问题就复杂了。这种情况下，也许就必须使用引用计数来跟踪仍旧访问着共享对象的对象数量了，当共享它的对象全部dispose，引用计数为0时，才会dispose。 8.3.3 构造器内部的多态方法的行为如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。然而这个调用的效果是难以预料的，因为被覆盖的方法在对象被完全构造之前就会被调用。这可能会造成一些难以发现的隐藏错误。 123456789101112131415161718192021222324class Glyph&#123; void draw()&#123;System.out.println("Glyph.draw()");&#125; Glyph()&#123; draw(); &#125;&#125;class RoundGlyph extends Glyph&#123; private int radius = 1; Roundglyph(int r)&#123; radius = r; System.out.println("Roundglyph.Roundglyph(),radius=" + radius); &#125; void draw()&#123; System.out.println("Roundglyph.draw(),radius=" + radius); &#125;&#125;public class PolyConstructors&#123; public static void main(String[] args)&#123; new RoundGlyph(5); &#125;&#125;/* output:Roundglyph.draw(),radius=0Roundglyph.RoundGlyph(),radius=5*/ 在上面的例子中，基类Glyph的构造器调用draw()方法时，radius还没有被初始化，不是1，而是0。这可能导致程序无法正常运转。 在编写构造器的时候有一条有效的准则：“用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法”。构造器中唯一能够安全调用的那些方法使基类中的final方法（也适用于private方法，它们自动属于final方法） 8.4协变返回类型Java 5中添加了协变返回类型，它表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。如：12345678910class Grain&#123;&#125;class Wheat extends Grain&#123;&#125;class Mill&#123; Grain process()&#123;return new Grain();&#125;&#125;class WheatMill extends Mill&#123; Wheat process()&#123;return new Wheat();&#125;&#125; 8.5 用继承进行设计组合更加灵活，因为它可以动态选择类型（因此也就选择了行为）；相反，继承在编译时就需要知道确切的类型。 12345678910111213141516171819202122class Actor&#123; public void act()&#123;&#125;&#125;class HappyActor extends Actor&#123; public void act()&#123;&#125;&#125;class SadActor extends Actor&#123; public void act()&#123;&#125;&#125;class Stage&#123; private Actor actor = new Happyactor(); public void change()&#123;actor=new SadActor();&#125; public void performPlay()&#123;actor.act();&#125;&#125;public class Transmogrify&#123; public static void main(String[] args)&#123; Stage stage = new Stage(); stage.performPlay(); stage.change(); stage.performPlay(); &#125;&#125; 上述代码用到了状态模式，可以在运行时将引用与不同的对象重新绑定在一起，然后产生不同的行为。 一条通用的准则就是：“用继承表达行为之间的差异，用字段表达状态之间的差异”。 8.5.1 纯继承与扩展在通常情况下，我们需要重新查明对象的确切类型，以便能够访问该类型所扩充的方法。 8.5.2 向下转型与运行时类型识别Java语言中，所有转型都会得到检查。Java会在运行期间对类型进行检查，这种行为称作“运行时类型识别”(RTTI) 例：1234567891011121314151617181920212223class Useful&#123; public void f()&#123;&#125; public void g()&#123;&#125;&#125;class MoreUserful extends Useful&#123; public void f()&#123;&#125; public void g()&#123;&#125; public void u()&#123;&#125;&#125;public class RTTI &#123; public static void main(String[] args)&#123; Useful[] x = &#123; new Useful(), new MoreUserful() &#125;; x[0].f(); x[1].g(); ((MoreUserful)x[1]).u(); //((MoreUserful)x[0]).u(); //错误，转型失败 &#125;&#125; 如果想要访问MoreUseful对象的扩展接口，就可以尝试向下转型。如果所转的类型是正确的类型，那么转型成功；否则就会返回一个ClassCastException的异常。 RTTI的内容不仅仅包括转型处理。例如它还提供一种方法，使你可以在试图向下转型之前，查看你要处理的类型。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（七） 复用类]]></title>
    <url>%2F2017%2F10%2F09%2FThinkingInJava7%2F</url>
    <content type="text"><![CDATA[有两种方法可以复用现有类，第一种，只需在新的类中产生现有类的对象，称为组合；第二种，按照现有类的类型来创建新类，称为继承。 7.2 继承语法即使一个程序中含有多个类，也只有命令行所调用的那个类的main()方法会被调用。即使一个类只具有包访问权限，其public main()仍然是可以访问的 为了继承，一般的规则是把所有的数据成员都指定为private，将所有方法都指定为public（稍后将会学到，protected成员也可以借助导出类来访问）。 7.2.1 初始化基类当创建了一个导出类的对象时，该对象包含了一个基类的子对象 Java会自动在导出类的构造器中插入对基类构造器的调用，可以显示地调用基类构造器，但是调用基类构造器必须是你在导出类构造器中要做的第一件事。 7.3 代理什么叫代理？代理是组合和继承之间的中庸之道，将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该成员对象的所有方法（就像继承）。 7.4 结合使用组合和继承7.4.1 确保正确清理如果想要某个类去清理一些东西，就必须得显式地编写一个特殊方法来做这件事，必须将这一清理动作置于fially子句之中，以预防异常的出现。 许多情况下，清理并不是问题，交给垃圾回收器就好了。但有时有些资源必须亲自去清理，如果必须这样，最好是编写自己的清理方法，但不要使用finalize()。执行清理的顺序：首先，执行类的所有特定的清理动作，其顺序同生成顺序相反（通常这就要求基类元素仍旧存货）；然后，调用基类的清理方法。 7.4.2 名称屏蔽如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（这一点和C++不同）。 Java SE5新增了@Override注解，虽然不是关键字，但是可以把它当做是关键字来使用。如果想要覆写一个方法，添加@Override注解，可以防止在不想重载时而意外地进行了重载，这种情况下会有错误信息。 7.5 在组合与继承之间选择组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地做。 组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情况(has-a关系)。在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某个特殊需要而将其特殊化(is-a关系)。 一个最清晰的判断方法就是问一问自己是否需要从新类向基类进行向上转型。一般优先考虑组合，只在确实必要时才使用继承。 7.6 protected关键字Protected域对子类是可见的 7.7 向上转型向上转型总是很安全的。 7.8 final关键字7.8.1 final数据使用场景：（1）一个永远不改变的编译时常量；（2）一个在运行时被初始化的值，而你不希望它被改变。 一个既是static又是final的域只占据一段不能改变的存储空间。 对于基本类型，final使数值恒定不变；而对于对象引用，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它指向另一个对象。对象自身却是可以被修改的，这一限制也适用于数组，因为它也是引用。 根据惯例，一个既是static又是final的域（即编译器常量）将用大写表示，并使用下划线来分割各个单词。 “空白final”是指被声明为final但是又没有给定初值的域，可以在每个构造器中用表达式来对final进行赋值，这样就提供了灵活性。 当基本类型被指明为final的时候出现的结果：你可以读参数，但却不能改变参数。 7.8.2 final方法使用final方法的原因：（1） 把方法锁定，以防任何继承类修改它的含义（2） 过去建议使用final方法的第二个原因就是效率 只有想要明确禁止覆盖时，才将方法设置为final。 类中所有的private方法都隐式地指定为是final的。如果某个方法是private的，它就不是基类的接口的一部分。如果这个时候以相同的名称生成一个public、protected或者是包访问权限的方法的话，此时你并没有覆盖该方法，仅是生成了一个新方法。 7.8.3 final类final类没有子类，final类中的域可以不为final，final类中的方法必须为final。 final类不能被继承。不论类是否为final的，相同的规则都适用于定义为final的域。然而，final类中所有方法都隐式指定为final的，因为无法覆盖它们。 7.9 初始化及类的加载“类的代码在初次使用的时候才加载。”这通常是指加载发生于创建类的第一个对象的时候，但是当访问static域或者static方法的时候，也会发生加载。当然，定义为static的东西只会被初始化一次。 加载及初始化顺序： 加载类的基类，如果基类还有基类，则继续加载，如此类推。其它任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。 根基类中的static初始化(static域和static块初始化)，然后下个导出类，以此类推。 根基类初始化：非static显示初始化，调用构造器。 导出类初始化，流程与基类类似。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（六） 访问控制权限]]></title>
    <url>%2F2017%2F10%2F09%2FThinkingInJava6%2F</url>
    <content type="text"><![CDATA[重构就是重写代码 访问权限控制的等级，从最大权限到最小权限依次是：public、protected、包访问权限（没有关键词）和private。 6.1 包：库单元包内包含有一组类，它们在单一的名字空间下被组织在了一起。 一个Java源代码文件（.java文件）通常称为编译单元。每个编译单元只能有一个public类，否则编译器就不会接受，而且该类的名字必须和文件的名称相同。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的。 Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，使用Java的jar文档生成器）的.class文件。Java解释器负责这些文件的查找、装载和解释。 CLASSPATH：对于.class文件，需要写出.class文件存放路径，.jar则需要写清楚.jar文件的名称。例如：CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar CLASSPATH中包含一个或者多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称并且将每一个句点转换成反斜杠，以便从CLASSPATH根中产生一个路径名称。 如果两个含有相同名称的类库都以“*”的形式同时导入，则需要在创建类的时候写明全称：1234import net.mindview.simple.*;import java.util.*;java.util.Vector v = new java.util.Vector(); 用import改变行为：c中有条件编译，java中没有相同功能，可以通过导入不同版本的包，来实现相同功能。调试功能就是这么实现的。 包必须放置在CLASSPATH中设置的目录之中，否则会由于找不到包而出错。 6.2 Java访问权限修饰词 修饰词 本类 同一个包的类 继承类 其他类 Private yes no no no 无（默认） yes yes no no protected yes yes yes no public yes yes yes yes 6.3 接口和实现为了清楚起见，可能会采用一种将public成员置于开头，后头跟着protected、包访问权限和private成员的创建类的形式，这样便于阅读。 6.4 类的访问权限 每个编译单元（文件）都只能有一个public类。 public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。 虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下可以对文件随意命名，但是这会带来阅读和维护的混乱。 类的访问权限有两种：包访问权限和public(内部类可以是protected和private)。如果不希望其它任何人对该类拥有访问权限，可以把所有构造器都指定为private，从而阻止任何人创建该类对象，但是有一个例外，就是你在该类的static成员内部可以创建(单例模式就用到了这一点)。 单例设计模式代码：1234567class Soup &#123; private Soup()&#123;&#125; private static Soup ps1 = new Soup(); public static Soup access()&#123; return ps1; &#125;&#125; 如果不具有package声明，都被视作该目录下默认包的一部分。然而，如果该类的某个static成员是public的话，则客户端程序员仍旧可以调用该static成员，尽管他们不能生成该类的对象。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（五） 初始化与清理]]></title>
    <url>%2F2017%2F10%2F06%2FThinkingInJava5%2F</url>
    <content type="text"><![CDATA[5.1 用构造器确保初始化默认构造器（无参构造器）：不接受任何参数的构造器。 Ex2创建一个类,它包含一个在定义时就被初始化了的String域,以及另一个通过构造器初始化的String域。这两种方式有何差异？123456789101112131415161718public class E02_StringInitialization &#123; String s1 = "Initialized at definition"; String s2; public E02_StringInitialization(String s2i) &#123; s2 = s2i; &#125; public static void main(String args[]) &#123; E02_StringInitialization si = new E02_StringInitialization( "Initialized at construction"); System.out.println("si.s1 = " + si.s1); System.out.println("si.s2 = " + si.s2); &#125;&#125; /* Output:si.s1 = Initialized at definitionsi.s2 = Initialized at construction*///: 不同：s1的域在构造器初始化之前就已经被初始化了，s2的域这时候也被初始化为null，只不过在构造器中又被初始化了一次，即初始化2次。而且通过构造器初始化这种方式更加灵活。 5.2 方法重载区分重载的几个方法： 参数列表不同 参数顺序不同（不建议） 返回值不同（行不通） 5.3 默认构造器如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。 例如：12345678910class Bird&#123; Bird(int i)&#123;&#125; Bird(double)&#123;&#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Bird b = new Bird(); //会报错，因为已经提供了构造器，所以编译器就不会帮你自动创建默认构造器。 &#125;&#125; 5.4 this关键字编译器会暗自把“所操作对象的引用”作为第一个参数传递给方法。this关键词只能在方法内部使用，表示对“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。 • 如果在方法内部调用同一类的另一个方法，不必使用this，直接调用即可。当方法需要返回当前对象的引用时才需要明确使用this，如需要返回当前对象时。• 如果要将当前对象传递给外部的方法，this关键词就很有用。• 可能为一个类写了多个构造器，想在一个构造其中调用另一个构造器，以避免重复代码。this关键字可以做到这一点。 尽管可以用this调用一个构造器，但不能调用两个。此外，必须将构造器置于最起始处，否则编译器会报错。 除了构造器外，编译器禁止在其他任何地方调用构造器。 static方法是属于类的，所以里面不能用this关键字。static方法的内部不能使用非静态方法，反过来倒是可以的。 5.5 清理：终结处理和垃圾回收1. 对象可能不被垃圾回收2. 垃圾回收并不等于“析构”3. 垃圾回收只与内存有关系 finalize() Java中finalize()的作用一主要是清理那些对象(并非使用new，比如调用了native方法)获得了一块“特殊”的内存区域。Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象(并非使用new)获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块“特殊”内存区域，为了应对这种情况，java允许在类中定义一个名为finalize()的方法。它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()的方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。注意这里的finalize()并不是C++里的析构.在C++中，对象一定会被销毁，而在Java里的对象却并非总是被垃圾回收。 垃圾回收只与内存有关。也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说(尤其是finalize()方法)，它们也必须同内存及其回收有关。 在C++中，所有对象都会被销毁，或者说，应该被销毁。但是在Java中，无论是“垃圾回收”还是“终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。 finalize()有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象终结条件的验证。 例如：123456789101112131415161718192021222324class Book&#123; boolean checkedOut = false; Book(boolean checkedOut)&#123; this.checkedOut = checkedOut; &#125; void checkIn() &#123; checkedOut = false; &#125; protected void finalize()&#123; if(checkedOut)&#123; System.out.println("Error : checked out"); &#125; &#125;&#125;public class TerminationCondition&#123; public static void main(String[] args)&#123; Book novel = new Book(true); novel.checkIn(); new Book(true); System.gc(); // 用于强制进行终结动作 &#125;&#125; 这个例子的终结条件是：所有的Book对象在被当做垃圾回收前都应该被签入（check in）。但在main()方法中，由于程序员的失误，有一本书没有被签入。要是没有finalize()来验证终结条件，就很难发现这个缺陷。 5.5.4 垃圾回收器如何工作垃圾回收器如何工作:举一个生活中的例子。你在一个屋子里生活一段时间之后会产生很多垃圾，使你必须清理。清理包括扔掉生活垃圾和自己几乎用不着的东西。 垃圾回收器最简单的方法就是引用计数：当有引用连接至对象的时候，引用计数加一。垃圾回收器遍历全部的对象。当发现有计数为0的对象时就释放。但是每当对象循环调用时会出现应该被回收，但是计数不为0的现象。这就像你收拾屋子时总觉得这个东西还有用其实它对于你没有什么用那样。显然这种方式是不可用的。实际上虚拟机采用的回收思想是;每一个活的对象都可以追溯到它存活的堆栈或者静态存储区的引用。因此从堆栈或者静态存储区开始遍历就可以找到所有活着的对象。在这种方式下采用了自适应的垃圾回收机制：1.停止–复制机制：先暂停程序的运行然后将活的对象从一个堆栈复制到另一个堆栈中，没有复制的都是垃圾将被回收。显然这种方式的缺点还是比较明显的，首先要暂停程序，另外在程序稳定之后几乎不产生垃圾的情况下仍旧会进行大量的复制。这是一种没有必要的浪费。2.标记–清扫：标记每一个活着的对象，在清理时不清理他们。但是这样做的缺点是存储空间不是相连成块的。虚拟机通常都把这两种方式结合来用，在没有新的垃圾产生的时候就从停止–复制模式切换到标记–清扫模式。这样避免了二者的缺点。在虚拟机中内存都以块的形式分配，在垃圾回收时停止–复制机制向已经废弃的块中拷贝新的对象，由于程序的进行，会出现更替，所以每个块都有自己的代数来记录它是否存活。每次回收之后都进行整理，这样垃圾回收就会对大量的短命的临时对象进行回收。因此现行的垃圾回收应该被称呼为“自适应的，分代的，停止–复制，标记–清扫”式垃圾回收器。有些时候我们可能会使用非new形成的内存，这时java中有一个方法为finalize()，每当垃圾回收器启动的时候，会首先调用这个方法，并且在下一次垃圾回收发生的时候才会真正回收对象。这个时候我们需要finalize()来验证终结条件并且调用system.gc()这个方法来进行终结动作。 5.6 成员初始化Java尽力保证：所有变量在使用前都能得到适当的初始化。对于方法的局部变量，如果没有被初始化，就会以异常的方式来提醒。 类的数据成员是基本类型时，就会有默认的初始值。 在类里定义一个对象引用时，如果没有对它进行初始化，此引用就会得到一个特殊值null。 5.7 构造器初始化 5.8 数组初始化int[] a1;这只是一个数组引用。 第一种初始化方法代码： 123Integer[] a = new Integer[2];//对于非基本类型，此时只是创建了一个引用数组，必须对数组中的每个元素创建对象a[0] = new Integer(1);a[1] = new Integer(2); 第二种初始化方法代码： 1Integer[] a = &#123;1,2,&#125;; 第三种初始化方法代码：1Integer[] a = new Integer[]&#123;1,2,&#125;; 第二、三种方法中最后一个逗号是可选的。在方法调用的内部都可以使用第三种方式： 1Other.main(new String[]&#123;"abc","efg"&#125;); 5.8.1 可变参数列表Java SE5中开始提供可变参数列表。代码如下：public void name(Object...args); 可变参数：1. 参数个数或者类型未知2. 必须位于参数列表末尾 当指定参数时，编译器实际上会为你去填充数组。可以直接将数组传递给可变参数列表。0个参数的可变参数列表也是可以的。 当方法重载时，如：12public void name(Integer... args)&#123;&#125;public void name(Long... args)&#123;&#125; 上述代码重载了name方法，当使用name()编译器无法知道调用哪个方法，无法编译。你应该总是只在重载方法的一个版本上使用可变参数列表，或者根本不使用 5.9 枚举类型Java SE5中添加了enum关键字，详细的enum用法在19章将会提到。 • toString()：获得某个enum实例的名字• ordinal()：获得某个enum实例的声明顺序• 静态方法values()：用来按照enum常量的声明顺序，产生由这些常量值构成的数组。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（四） 控制执行流程]]></title>
    <url>%2F2017%2F10%2F02%2FThinkingInJava4%2F</url>
    <content type="text"><![CDATA[4.3 迭代4.3.3 逗号操作符Java里唯一用到逗号操作符的地方就是for循环的控制表达式。 4.4 Foreach语法Java SE5引入了一种新的更加简洁的for语法用于数组和容器，就是foreach语法。如： for(float x : f){…}; Foreach还可以用到任何Iterable对象上。 4.6 break和continue在java中，标签起作用的唯一的地方刚好是在迭代语句之前。“刚好之前”的意思表明，在标签和迭代之间置入任何语句都不好。在迭代之前设置标签的唯一理由：我们希望在其中嵌套另一个迭代或者一个开关。这是由于break和continue关键词通常只中断当前循环（最内层的循环），但若随同标签一起使用，它们就会中断循环，直到标签所在的地方。 一般的continue会退回最内层循环的开头（顶部），继续执行。 带标签的continue会到达标签的位置，重新进入紧接在那个标签后面的循环。 一般的break会中断并跳出当前循环。 带标签的break会中断并跳出标签所指的循环。 4.8 switchswitch现在支持整数(int、short、byte)、char、字符串、枚举类型。 Ex10 吸血鬼问题首先解释一下吸血鬼数字：吸血鬼数字是指位数为偶数的数字，可由一对数字相乘而得到，这对数字各包含乘积的一半位数的数字，以两个0结尾的数字是不允许的。 四位数吸血鬼数字示例：1260=21&#42;60，1827=21&#42;87，2187=27&#42;81…… 先列出结果：一共7个：1260=21&#42;60，1395=15&#42;93，1435=41&#42;35，1530=51&#42;30，1827=87&#42;21，2187=27&#42;81，6880=86&#42;80 方法一：本方法是顺向思维，即先有四位数，再拆分，四个数字组合相乘，若乘积与原数相等，则输出，并计算为一个吸血鬼数字。算法效率较低，共比较107976次 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142/*解法1*/public class E10_Vampire_0 &#123; /*本方法是顺向思维，即先有四位数，再拆分，四个数字组合相乘，若乘积与原数相等，则输出，并计算为一个吸血鬼数字。 其实sum的结果为107976次，非常大，算法效率很低，并且出现了重复（6880 = 86 * 80，6880 = 80 * 86）。*/ static int sum=0;//记录调用判断的次数,TMJG添加此行并注释 static int a(int i) &#123; return i/1000; //求千位数字 &#125; static int b(int i) &#123; return (i%1000)/100; //求千位数字 &#125; static int c(int i) &#123; return ((i%1000)%100)/10; //求十位数字 &#125; static int d(int i) &#123; return ((i%1000)%100)%10; //求个位数字 &#125; static int com(int i, int j) &#123; //形成10~99的两位数 return (i * 10) + j; &#125; static void productTest (int i, int m, int n) &#123; sum++; if(m * n == i) System.out.println(i + " = " + m + " * " + n); &#125; public static void main(String[] args) &#123; for(int i = 1001; i &lt; 9999; i++) &#123; productTest(i, com(a(i), b(i)), com(c(i), d(i))); productTest(i, com(a(i), b(i)), com(d(i), c(i))); productTest(i, com(a(i), c(i)), com(b(i), d(i))); productTest(i, com(a(i), c(i)), com(d(i), b(i))); productTest(i, com(a(i), d(i)), com(b(i), c(i))); productTest(i, com(a(i), d(i)), com(c(i), b(i))); productTest(i, com(b(i), a(i)), com(c(i), d(i))); productTest(i, com(b(i), a(i)), com(d(i), c(i))); productTest(i, com(b(i), c(i)), com(d(i), a(i))); productTest(i, com(b(i), d(i)), com(c(i), a(i))); productTest(i, com(c(i), a(i)), com(d(i), b(i))); productTest(i, com(c(i), b(i)), com(d(i), a(i))); &#125; System.out.println("总共调用判断的次数为："+sum);//TMJG添加此行并注释 &#125;&#125; 方法二：本方法是对方法一的改进，跳过了一些数字（如1100这样末尾两个0的，如1010、1001这样明显不可能是吸血鬼数字的数字），并且避免了出现重复的可能性，但是效率仍然很低，需要判断104942次。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*解法2*/public class E10_Vampire_1 &#123; public static int count = 0;// 记录一共有多少个吸血鬼数字 public static int k = 0;//记录调用判断多少次 public static void main(String[] args) &#123; for (int i = 1001; i &lt; 10000; i++) &#123; // 如果数字是像1100这种末尾至少有2个0的，则跳过 if (i % 100 == 0) &#123; continue; &#125; // 获得数字四个数值位上的数字,这里我们假定四位数表示为abcd int a = i / 1000; int b = (i - a * 1000) / 100; int c = (i - a * 1000 - b * 100) / 10; int d = i - a * 1000 - b * 100 - c * 10; // 判断四个位置上是否有两个0存在的情况，如1010，并跳过这些数，由于千位不可能为0，因此只需要判断另外三位是否有2个0的情况 // 当3个数中有2个0时，必然存在“3个数之和等于其中某一个数”，以此作为判断依据，而后两位为0的也已经排除，其实只需要判断如1001，和1010这种情况即可 if (b + c + d == c || b + c + d == d) &#123; continue; &#125; // 排除掉各种情况后，可以开始真正的吸血鬼数字筛选了 // 那么一共有12种情况：abcd,abdc,acbd,acdb,adbc,adcb,bacd,badc,bcda,bdca,cadb,cbda if (search(i, a, b, c, d)) &#123; &#125; else if (search(i, a, b, d, c)) &#123; &#125; else if (search(i, a, c, b, d)) &#123; &#125; else if (search(i, a, c, d, b)) &#123; &#125; else if (search(i, a, d, b, c)) &#123; &#125; else if (search(i, a, d, c, b)) &#123; &#125; else if (search(i, b, a, c, d)) &#123; &#125; else if (search(i, b, a, d, c)) &#123; &#125; else if (search(i, b, c, d, a)) &#123; &#125; else if (search(i, b, d, c, a)) &#123; &#125; else if (search(i, c, a, d, b)) &#123; &#125; else if (search(i, c, b, d, a)) &#123; &#125; &#125; System.out.println("四位数的吸血鬼数字一共有" + count + "个。"); System.out.println("一共调用判断次数为" + k); &#125; //判断是否满足条件 static boolean search(int i, int a, int b, int c, int d) &#123; k++; if ((a * 10 + b) * (c * 10 + d) == i) &#123; searchfor(i,a,b,c,d);//如果满足条件，则打印结果 return true; &#125;else&#123; return false; &#125; &#125; //满足条件即打印，并且统计个数 static void searchfor(int i, int a, int b, int c, int d) &#123; count++; System.out.println(i + "=" + (a * 10 + b) + "*" + (c * 10 + d)); &#125;&#125; 方法三：该算法采用逆向思维，4位数字的吸血鬼数字只能拆分成两个2位数，因此遍历所有两个两位数相乘的情况，除去不符合的情况不用判断，其他挨个判断即可。该方法只需判断3721次。 代码如下： 12345678910111213141516171819202122232425262728293031/*解法三*/public class E10_Vampire &#123; /** * 代码来自网络，略作修改并添加了注释 * 该算法只需要执行3721次 */ public static void main(String[] args) &#123; String[] targetNum = null; String[] gunNum = null; //目标数字和枪数字（即对比数字） int sum = 0; //吸血鬼数字的总个数 int count = 0; //有效判断次数，那些乘积不是4位数的就排除了 for (int i = 10; i &lt; 100; i++) &#123; for (int j = i + 1; j &lt; 100; j++) &#123; //没有哪个两位数满足ab*ab=abab（不信可以编程验证），所以这里j从i+1开始就可以了 int i_target = i * j; if (i_target &lt; 1000 || i_target &gt; 9999) continue; // 积不是4位数则跳过 count++; targetNum = String.valueOf(i_target).split(""); //将其转换为一个字符串数组 gunNum = (String.valueOf(i) + String.valueOf(j)).split(""); java.util.Arrays.sort(targetNum); //升序排列，因为只有排列了再比较才能保证不遗漏abcd=ba*dc这样的情况 java.util.Arrays.sort(gunNum); if (java.util.Arrays.equals(targetNum, gunNum)) &#123; // 排序后比较,为真则找到一组 sum++; System.out.println("第" + sum + "个: " + i_target + "=" + i + "*" + j); &#125; &#125; &#125; System.out.println("共进行了" + count + "次判断，找到" + sum + "个吸血鬼数字。"); &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（三） 操作符]]></title>
    <url>%2F2017%2F10%2F02%2FThinkingInJava3%2F</url>
    <content type="text"><![CDATA[在最底层，Java是通过操作符来对数据进行操作的。 3.1 更简单的打印语句123456789101112131415161718//: operators/E01_PrintStatements.java/****************** Exercise 1 ****************** Write a program that uses the "short" and* normal form of print statement.***********************************************/package operators;import java.util.Date;import static net.mindview.util.Print.*;public class E01_PrintStatements &#123;public static void main(String[] args) &#123;Date currDate = new Date();System.out.println("Hello, it's: " + currDate);print("Hello, it's: " + currDate);&#125;&#125; /* Output: (Sample)Hello, it's: Wed Mar 30 17:39:26 CEST 2005Hello, it's: Wed Mar 30 17:39:26 CEST 2005*///:~ 上面的import static net.mindview.util.Print.*;简化了打印操作。 3.2 使用Java操作符几乎所有的操作符都只能操作基本类型。例外的操作符是“=”，“==”，“!=”。另外String支持“+”和“+=” 3.3 优先级先乘除后加减 3.4 赋值基本类型赋值是直接将一个地方的内容复制到另一个地方。而“将一个对象赋值给另一个对象”实际是将“引用”从一个地方复制到另一个地方。 3.5 算数操作符通过Random类的对象，程序可以生成许多不同类型的随机数字。只需要调用方法nextInt()和nextFloat()就可以了（或者nextLong()或nextDouble()）。 一元减号是用于转变数据的符号，一元加号只是为了与一元减号相对应，唯一的作用仅仅是将较小类型的操作符提升为int。 3.7 关系操作符对于对象==，!=比较的是引用。要比较对象的实际内容，应该使用equals()方法。默认equals()方法是比较引用（Object类中就是返回this==obj），所以要想实现自己想要的功能应该在自己的类中覆盖此方法。Java不允许普通数字作为布尔值使用。 基本类型直接使用==，!=比较内容即可。 3.8 逻辑操作符逻辑操作符“与”（&amp;&amp;）、“或”（||）、“非”（！ ）能根据参数的逻辑关系，生成一个boolean值。短路现象：一旦能明确无误地确定整个表达式的值，就不再计算表达式余下的值了。 直接常量后面的后缀字符标志了它的类型。&nbsp;&nbsp;&nbsp;&nbsp;• 若为大写（或小写）的L，代表long。&nbsp;&nbsp;&nbsp;&nbsp;• 若为大写（或小写）的F，代表float。&nbsp;&nbsp;&nbsp;&nbsp;• 若为大写（或小写）的D，代表double。对于long和float必须写出后缀字符。默认整型和浮点型是int和double。Integer和Long类的静态方法toBinaryString()可以得到二进制字符串。 3.9 指数计数法1.39e-43f代表1.39乘上10的-43次幂。 3.10 按位操作符我们将布尔类型作为一种单比特值对待。可以进行按位与(&amp;)、或(|)、异或(^)操作，但是不能进行按位非(~)操作。对于布尔值，按位操作符与逻辑操作符有相同的效果，只是不能中途“短路”。 3.11 移位操作符&nbsp;&nbsp;&nbsp;&nbsp;• &nbsp;&nbsp;左移位操作符（&lt;&lt;）：按操作符右边指定数值移位后，低位补0 。&nbsp;&nbsp;&nbsp;&nbsp;• “有符号”右移位操作符（&gt;&gt;）：按操作符右边指定数值移位后，使用符号扩展，补齐高位，若符号为正，则在高位插入0，若符号为负，则插入1 。&nbsp;&nbsp;&nbsp;&nbsp;• “无符号”右移位操作符（&gt;&gt;&gt;）：按操作符右边指定数值移位后，无论正负都在高位补0 。 char、byte、short类型的数值进行移位时，移位进行之前会先转为int，最后结果也是int型。只有右操作数的低5位才是有用的。这样可以防止我们移位超过int型值所具有的位数。 若对一个long类型的数值进行处理，最后结果也是long。此时只会用到数值右端的低6位，以防止移位超过long类型数值所具有的位数。 int是32位，所以50&lt;&lt;33相当于50&lt;&lt;(33%32)。 Java数字的二进制表示形式称为有符号的二进制补码 3.15 类型转换操作符窄化转换：将容纳更多信息的数据类型转换成无法容纳那么多信息的数据类型，可能面临信息丢失的危险。需要进行显式转换。扩展转换：不需要进行显式转换，因为新类型肯定会容纳原来类型的信息，不会造成任何信息的丢失。 3.15.1 截尾和舍去将float和double转型为整型值时，总是对该数值执行截尾。如果想要得到舍入结果，就需要使用java.lang.Math中的round()方法。 3.15.2 提升对于基本类型执行算术运算或位运算，只要类型比int小（char、byte、short），在运算之前会自动转成int，最终结果也是int。复合赋值（+=、-=等）并不需要类型转换，尽管它们执行类型提升，但也会获得与直接算术运算相同的结果。表达式中出现的最大的类型决定了表达式最终结果的数据类型。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（二） 一切都是对象]]></title>
    <url>%2F2017%2F09%2F30%2FThinkingInJava2%2F</url>
    <content type="text"><![CDATA[2.1 用引用操作对象尽管一切都看做对象，但是操纵的标识符实际上是对象的一个“引用”(reference)。可以将这个情形看做是遥控器（引用）来操纵电视机（对象）一种安全的做法是，创建一个引用的同时就对其进行初始化。String s = “hello”; 2.2 必须由你创建所有对象String s = new String(“hello”);一旦创建了一个引用，就能与一个对象相关联。 2.2.1 存储到什么地方程序运行时候有五个地方可以存储数据： 寄存器：处理器内部，最快的存储区，数量极其有限 堆栈：位于通用RAM，通过堆栈指针来分配和释放内存，速度仅次于寄存器。灵活性受限（必须知道存储其中的对象的确切生命周期）。对象引用存于此处。 堆：一种通用内存池，也位于RAM。灵活性大，分配与清理耗时，所有的Java对象存储于此。 常量存储：存放在程序内部，在嵌入式系统中，可以选择将其存放于ROM中。 非RAM存储：数据在程序没有运行时也可以存在，两个典型的例子就是流对象和持久化对象 2.2.2 特例：基本类型基本类型不需要new来创建对象，而是创建一个并非是引用的“自动”变量。这个变量直接存储值，并置于堆栈中。 Java中，没有无符号数，基本类型占用空间的大小也不会像其它语言随机器硬件架构变化。&rarr;（更具有可移植性） Java 每种基本类型都提供了包装器类型。同时提供了两个用于高精度计算的类：BigInteger（任意精度的整数）和BigDecimal（任意精度的定点数）。 2.2.3 Java中的数组C和C++的数组就是内存块，访问很危险Java则会确保数组会被初始化，而且不能再范围外访问。但是增加了检查开销。 Java中创建数组对象时，实际上就是创建引用数组（数组对象是由java虚拟机创建的），且每个引用都会自动被初始化为一个特定值（null）。编译器会把基本类型数组的内存全部置零。 2.3 永远不需要销毁对象2.3.1 作用域以花括号为例，说明与C、C++的作用域区别：123456&#123; int x = 12; &#123; int x = 96; //不合法，而在C、C++中外面花括号中的变量会被隐藏 &#125;&#125; 2.3.2 对象的作用域Java使用new创建的对象可以存活于作用域之外123&#123; String s = new String("a string");&#125; 上面例子中，引用s在作用域终点就消失了，s指向的String对象仍继续占用内存空间。 Java有一个垃圾回收器，用于监视new创建的所有对象，并辨别不再被引用的对象。 2.4 创建新的数据类型：类在Java中，所做的全部工作就是：定义类、产生类对象、发送消息给类对象。类中有两种类型的元素：字段（或数据成员）和方法（或成员函数）。 当变量成为类的字段使用时，Java确保给定其默认值（内存中填0），以确保其得到初始化（C++无此功能），对于局部变量，不做初始化，可能是任意值。 2.5 方法、参数和返回值方法：做某些事情的方式。基本组成包括：名称、参数、返回值和方法体。其中方法名和参数列表（参数类型及参数顺序），合起来称为“方法签名”，唯一标识出某个方法。 Java中的方法只能作为类的一部分来进行创建。方法只能通过对象才能被调用。 Java在参数列表中必须指定每个所传递对象的类型和名字。 关于方法的参数传递，这是一个被争议的话题。 • 先说说参数传递的几个术语：&nbsp;&nbsp;&nbsp;&nbsp;值调用(call by vale):表示方法接收的是调用者传递的值。&nbsp;&nbsp;&nbsp;&nbsp;引用调用(call by reference):表示方法接收的是调用者传递的变量地址。&nbsp;&nbsp;&nbsp;&nbsp;一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值； JAVA语言总是采用值调用，也就是说，JAVA方法得到的是所有参数值的一个拷贝，方法不能修改传递给他的任何参数变量的内容。例如：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package ch2;/*JAVA方法得到的是所有参数值的一个拷贝，方法不能修改传递给他的任何参数变量的内容。*/public class Parameter &#123; public static void swap(int a, int b)&#123; int tmp = a; a = b; b = tmp; System.out.println("a: "+a+" b: "+b); &#125; public static void swap(StringAddress a, StringAddress b)&#123; StringAddress tmp = a; a = b; b = tmp; System.out.println("a: "+a+" b: "+b); &#125; public static void change(StringAddress a)&#123; a.setS("hi"); System.out.println("a: "+a); &#125; public static void main(String[] args) &#123; int x = 1,y=20; StringAddress sax = new StringAddress("hello"),say = new StringAddress("world"); swap(x,y); System.out.println("x: "+x+" y: "+y); swap(sax,say); System.out.println("sax: "+sax+" say: "+say); change(sax); System.out.println("sax: "+sax); &#125;&#125;class StringAddress&#123; private String s; public StringAddress(String s)&#123; this.s = s; &#125; public String toString()&#123; return super.toString() + " " + s; &#125; public void setS(String s)&#123; this.s = s; &#125;&#125;/*a: 20 b: 1x: 1 y: 20a: ch2.StringAddress@1540e19d world b: ch2.StringAddress@677327b6 hellosax: ch2.StringAddress@677327b6 hello say: ch2.StringAddress@1540e19d worlda: ch2.StringAddress@677327b6 hisax: ch2.StringAddress@677327b6 hi*/ 通过以上实例,可以看出基本类型参数传递的是变量值的拷贝，对象参数传递的是对象引用的拷贝,对象引用及其他的拷贝同时引用同一个对象。 很多程序语言提供两种传递方式:值传递和引用传递(C++和Pascal)。有些程序员认为java语言对对象参数传递也是用的引用调用。实际上是理解错误，这种错误具有一定的普遍性。 上例中swap方法并没有改变存储在变量sax和say中的对象引用。swap方法的参数a和b被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。在方法结束时，参数变量a和b被丢弃了。原来的变量sax和say仍然引用这个方法调用之前所引用的对象。这个过程说明：java语言对对象采用的不是引用调用，实际上对象引用进行的是值传递。最后总结一下在JAVA中，方法参数的使用情况： &nbsp;&nbsp;•一个方法不能修改一个基本数据类型的参数；&nbsp;&nbsp;•一个方法可以改变一个对象参数的状态（属性）；&nbsp;&nbsp;•一个方法不能实现让对象参数引用一个新对象； C++有值调用和引用调用。引用参数标有&amp;符号。例如，void swap(int&amp; a,int&amp; b)。引用即可以当做变量的一个别名，仅此而已。而Java的引用，如果理解为像指针一样存的是对象地址，传递时都会把它拷贝一份，这样可能会好理解些。 2.6 构建一个Java程序2.6.1名字可见性为了解决命名冲突，Java程序员使用反写Internet域名来确保名字的独一无二。如：net.mindview.utility.foibles 2.6.2 运用其他构件想使用其他文件定义好的类，可以使用import。 2.6.3 static关键字static解决的两个需求：（1） 只想为某特定域分配单一的存储空间，而不去考虑究竟要创建多少对象。（2） 即使没有创建对象，也能调用这个方法 即使从未创建某个类的任何对象，也可以调用其static方法或访问static域。 对于static方法，不能简单地通过调用其它非static域或方法而没有指定某个命名对象，来直接访问非static域或方法。普通方法可以直接使用static域或方法。 使用类名是引用static变量的首选方法。语法形式为ClassName.method(); 2.7 Java的第一个程序一个独立运行的程序，文件中必须存在某个类与该文件同名，并且那个类必须包含一个名为main()的方法（事实上Java允许文件名和文件中的类不同命，但是类不能是public的）。 public static void main(String[] args){…}中args用来存储命令行参数。 2.8注释和嵌入式文档javadoc 只能为public和protected成员进行文档注释。 不要在嵌入式html中使用标题标签&lt;h1&gt;&lt;hr&gt;等。因为javadoc会插入这类标签，避免冲突。 一些标签示例• @see：引用其他类该标签允许用户引用其他类的文档 @see classname• {@link package.class#member label}该标签与@see相似，只是它用于行内• {@docRoot}该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接• {@inheritDoc}该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中• @version• @author• @since该标签允许你指定程序代码最早的使用版本• @param该标签用于方法文档中• @return• @throws• @deprecated该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要再使用这些旧特性，因为在不久的将来它们很可能会被删除2.9 编码风格驼峰风格：类名的首字母大写；如果类名由几个单词构成，那么把它们并在一起，其中每个内部单词的首字母都采用大写形式。如：AllTheColorsOfRainbow几乎其他所有内容－－方法、字段（成员变量）以及对象引用名称等，公认的风格与类的风格一样，只是标识符的第一个字母采用小写。如：allTheColorsOfRainbow]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（一） 对象导论]]></title>
    <url>%2F2017%2F09%2F29%2FThinkinginJava1%2F</url>
    <content type="text"><![CDATA[1.1 抽象过程所有语言都提供抽象过程，汇编语言是对底层机器的轻微抽象，“命令式”语言（FORTRAN、BASIC、C等）是对汇编的抽象。 面向对象的五个基本特性：（1） 万物皆为对象（2） 程序是对象的集合，它们通过发送消息来告知彼此所要做的（3） 每个对象都有自己的由其他对象所构成的存储（4） 每个对象都有其类型（5） 某一特定类型的所有对象都可以接收同样的消息对象：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（它们给出了该对象的状态）和方法（它们产生行为），并且每一个对象都可以唯一地与其他对象区分开来。具体说来，就是每一个对象都在内存中有唯一的地址。 1.2 每一个对象都有一个接口类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。 必须有某种方式产生对对象的请求，使对象完成各种任务，如在屏幕上画图、打开开关等等。每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。 1.3 每个对象都提供服务对象是服务提供者，这么看的好处是提高对象的内聚性。 人们在设计对象时面临的问题是，将过多的功能都塞到一个对象中。在良好的面向对象设计中，每个对象都可以很好地完成一件事，而不试图去做多个。 1.4被隐藏的具体实现程序开发人员分为类创建者和客户端程序员。类创建者只向客户端程序员暴露必要的部分。 访问控制的第一个存在原因就是让客户端程序员无法触及他们不应该触及的部分访问控制的第二个存在原因就是允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员 Java用三个关键字在类的内部设定边界：public，private，protected以及暗示性的friendly。若未明确指定其他关键字，则默认为后者。这些关键字的使用和含义都是相当直观的，它们决定了谁能使用后续的定义内容。 “public”（公共）意味着后续的定义任何人均可使用。而在另一方面。 “private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。private在您与客户程序员之间竖起了一堵墙。若有人试图访问私有成员，就会得到一个编译期错误。 “friendly”（友好的）涉及“包装”或“封装”（Package）的概念——即Java用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。 “protected”（受保护的）与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。继承的问题不久就要谈到。 1.5 复用的具体实现最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的对象放在一个新类中 组合：由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。 如果组合是动态发生的，那么它通常称为“聚合”。 组合经常被视为”has-a”（拥有）关系，就像我们常说的”汽车拥有引擎”一样。在建立新类时，应该首先考虑组合，因为它更加简单灵活。 1.6 继承一个基类型包含其所有导出类型所共享的特性和行为。可以创建一个基类型来表示系统中某些对象的核心概念。 当继承一个现有类型的时候，也同时创建了新的类型。这个新的类型不光包括现有类型的所有成员（尽管private成员被隐藏起来，不可访问），而且更重要的是它复制了基类的接口。也就是说，所有可以发给基类的信息也可以发给导出类对象。 有两种方法可以使基类与导出类产生差异： 第一种方法非常直接：直接在导出类中添加新方法。应该仔细考虑是否存在基类也需要这些额外方法的可能性。 第二种也是更重要的一种使导出类和基类之间产生差异的方法是改变现有基类的方法的行为，这被称之为覆盖（overriding）那个方法。 如果继承只覆盖基类的方法（而并不添加在基类中没有的新方法），就意味着导出类和基类是完全相同的类型，因为它们具有完全相同的接口。结果可以用一个导出类对象来完全替代一个基类对象。这可以被视为纯粹替代，通常称之为替代原则。这种情况下的基类与导出类之间的关系称为is-a（是一个）关系，因为可以说”一个圆形就是一个几何形状”。判断是否继承，就是要确定是否可以用is-a来描述类之间的关系，并使之具有实际意义。有时必须在导出类型中添加新的接口元素，这样也就扩展了接口。这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法。这种情况可以描述为is-like-a（像是一个）关系。新类型具有旧类型的接口，但是它还包含其他方法，所以不能说它们完全相同。 1.7 伴随多态的可互换对象试图将导出类型的对象看做其泛化基类型的对象的时候（比如把自行车看做车），仍然存在问题：如果某个方法让泛化交通工具行驶，编译器编译的时候是不知道应该执行哪一段代码。 为了解决这个问题，面向对象程序直到运行时才能确定被调用的代码，这就是后期绑定。为了执行后期绑定，Java使用了一小段代码来替代绝对地址的调用。 在C++中，使用virtual关键字来实现后期绑定，因而不是动态的，而在Java中，默认就是动态绑定，因此也不需要添加额外的关键字来实现多态。 例如：12345void doSomething(Shape shape)&#123; shape.erase(); shape.draw();&#125; 这个方法才可以和任何Shape对话。如果其他程序也用到了dosomething()方法：1234Circle circle = new Circle();Line line = new Line();doSomething(circle);doSomething(line); 对doSomething的调用会自动地正确处理，而不管对象的确切类型。这种把导出类看成是基类的过程叫做向上转型（upcasting）。 1.8 单根继承结构除了C++以外的所有OOP语言都是单根继承。在Java中，终极基类就是Object。 1.9 容器容器：在任何需要的时候都可以扩充自己以容纳你置于其中的东西。因此不需要知道将来会把多少个对象置于容器中，只需要创建一个容器对象，然后让它去处理所有细节。 Java提供了List（用于存储序列），Map（也被称为关联数组，用来建立对象之间的关联），Set（每种对象类型只持有一个），以及诸如队列、树、堆栈等更多的构件。不同容器提供了不同类型的接口和外部行为；不同的容器对于某些操作具有不同的效率。例如ArrayList和LinkedList，选取元素时，LinkedList会比较低效，但是插入元素时，相对要高效。 在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。所以由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，当把它取回的时候，就获取了一个Object对象的引用，而不是对置入时那个对象的引用。 为了解决这个问题，可以采用向下转型的方法来解决。如果不是确切的知道对象的类型，向下转型是危险的。 Java SE5中加入了参数化类型，就是泛型。 1.10 对象的创建和生命期为了追求最大的执行效率，对象的存储空间和生命周期可以在编写程序的时候确定。这可以通过将对象置于堆栈（它们有时被称为自动变量或限域变量）或静态区域来实现。这种方式牺牲了灵活性，在编写程序的时候必须知道对象确切的数量、生命周期和类型。 第二种方式是在堆(heap)内存池中动态地创建对象。这种方式知道运行时才确切知道需要多少对象，生命周期如何，以及它们的具体类型是什么。 动态方式逻辑：对象趋于复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。 Java完全采用了动态内存分配的方式，每当想创建一个新对象的时候，就直接new一个对象出来。 由于在堆上创建对象存活的时间，编译器一无所知，在C++中必须通过delete对象来销毁对象，这样很可能由于处理不当导致内存泄漏。而Java中提供了垃圾回收器机制，用来处理内存释放问题。 1.11 异常处理：处理错误异常是一种对象。异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。这往往使得代码编写变得简单，因为不需要被迫定期检查错误。此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。异常不能被忽略，所以它保证一定会在某处得到处理。 1.12 并发编程隐患：共享资源。如果有多个并行任务都要访问同一项资源，那么就会出问题。对于共享资源，需要加锁。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向下一代光通信的VCSEL激光器仿真模型（数学建模）]]></title>
    <url>%2F2017%2F09%2F23%2Fgmcm%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在2017年9月16日至20日参加“华为杯”全国数学建模竞赛，主要负责解题思路的讨论和论文的撰写。主要解题思路如下：&emsp;&emsp;针对题目中给出的四个问题，分别利用数学方法提出我们自己的解决方案，并在matlab仿真环境下求解验证。 &emsp;&emsp;针对问题一，我们的主要目标就是利用附件提供的1402组测试数据，来对题中给出的L-I模型中各个未知参数进行求解，并根据求出的数学模型，画出不同温度下的L-I曲线，再对激光器在直流输出时平均光功率为2mW这样的临界条件下求解用户正常使用网络的临界温度值。我们的基本思路是：对附件中给出的经验公式进行联立移项，构造出一个残差r。由于附件中给出的数据I，V，P 均为向量数据，所以可以构造一个线性回归方程中的成本函数(Cost function)来求出使系统稳定的未知参数。该成本函数设为J,这样问题就转换成求解J的极小值。我们便可以使用基于Nelder-Mead的fminsearch函数，带入初值，便可以在系统收敛的情况下求出模型中各个参数。在求出模型之后，我们还需要对其稳定性进行检验。检验的方法就是对P_0进行循环迭代，如果系统是稳定的，那么在给P_0赋一个初值后，经过有限步的循环迭代，就可以得到一个稳定收敛的值。假设系统是稳定的，我们便可以利用模型，通过输入不同的T值，就可以描绘出不同温度下的L-I曲线。 &emsp;&emsp;针对问题二，我们的目标是对问题一求出的模型进行评估并对其进行优化。我们可以通过将模型在20℃情况下的L-I曲线与实测画出的L-I曲线进行比对分析。如果二者存在误差，那么可以判断我们求出的模型还不够优化，就可以通过调整模型参数值来继续观察其L-I曲线与实测曲线的差异性。如果调参之后的曲线与实际更加接近，那么这样的模型就是我们想要的优化模型。 &emsp;&emsp;针对问题三，我们分别针对四个小问题给出我们的解决方案： &emsp;&emsp;a. 问题三主要是建立带宽模型，也称作小信号响应模型。题目中的幅度（dB）首先要转换成响应H(f)，根据公式dB=20*〖log〗_10 H(f),将其进行归一化。然后根据附录中的公式进行推导，求出频率f与H(f)之间的关系，代入公式，通过matlab进行非线性拟合，最后求出所需要的参数。然后画出仿真输出曲线； &emsp;&emsp;b. 从带宽模型中可以得知3dB带宽的频率以及10dB带宽的频率，之后通过改变初试电流以及初始温度，测出不同的环境温度以及不同偏置电流的曲线，从画出的曲线中就能看出两者对VCSEL带宽的影响； &emsp;&emsp;c. 首先通过b中以及后面的分析，可以通过改变模型参数的方法获得更大的带宽；其次可以考虑对谐振腔的腔长进行优化的方案，也就是除了温度和电流之外的影响，通过查阅资料，该方案可以提升带宽60%； &emsp;&emsp;d. 首先通过a）中得出的模型参数分别进行敏捷度测试，检验哪些参数会对高于0的位置产生影响，通过增大模型参数以及减小参数并且和原图像对比的方式，我们可以分析参数对其影响； &emsp;&emsp;针对问题四，我们通过对问题三的分析，已知了某些参数会对曲线的带宽产生较大影响，对所有的参数进行敏捷度测试即可发现参数的调节上对于带宽的影响，增大参数与减小参数如何才能获得更宽的带宽。 &emsp;&emsp;下面给出论文全文：]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo从0搭建教程]]></title>
    <url>%2F2017%2F08%2F28%2Fhexo%E4%BB%8E0%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最开始有开博客的想法还是上个学期，因为学东西要去记一些笔记，便觉得为什么不顺便开一个博客，也便于管理。后来发现事实并没有想象中那么简单，网上流行的一些博客如CSDN之类的，在发布文章的时候大多需要审核（有时候只是想单纯的自言自语。。。），很麻烦。而一些非技术免费博客，如新浪博客之类的，界面难看不说，还没有分类（这样和记流水账有什么区别）。所以在熟悉了一定前端知识之后，我开始学着自己搭博客。那么现在，终于有一个界面美观，功能齐全的个人博客问世了！下面我就介绍一下完整的搭博客过程。 1. 安装Git Bash如果你不太喜欢在cmd中的各种操作，那么可以选择使用Git Bash，由于我是windows环境，所以下载windows版本并安装即可。 下载链接 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本： 命令：git version 2. 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧 下载链接(说明：LTS为长期支持版，Current为当前最新版) 安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按win + r快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。 查看版本： 1命令：node -v 3. 安装hexo看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：1npm i -g hexo 安装完成后，查看版本：) 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件： 解释一下： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 做好这些前置工作之后接下来的就是各种配配配置了。 4. 搭桥到github没账号的创建账号，有账号的看下面。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下： 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）： UserName: Email: 创建SSH 在gitbash中输入：ssh-keygen -t rsa -C &quot;youremail@example.com，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。 ssh: 将上面获取的ssh放到github中： 添加一个 New SSH key ，title随便取，key就填刚刚那一段。 在gitbash中验证是否添加成功：ssh -T git@github.com 完成下一步你就成功啦！ 5. 一步之遥用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到gitbash中，进入你的blog目录，分别执行以下命令：123hexo cleanhexo generatehexo server 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。 打开浏览器输入：http://localhost:4000(如果没有反应，就到文件根目录下执行 hexo s -p 5000，换一个端口号就好了) 接着你就可以遇见天使的微笑了~ 6. 上传到github先安装一波：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 执行命令(建议每次都按照如下步骤部署)：123hexo cleanhexo generatehexo deploy 注意deploy的过程中要输入你的username及passward。如下： 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！ 感觉gitbash中东西太多的时候输入clear命令清空。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假期间改过的一些网页小游戏代码]]></title>
    <url>%2F2017%2F08%2F20%2Fevergames%2F</url>
    <content type="text"><![CDATA[暑假期间在创业公司实习，负责修改一些网页小游戏的代码并进行优化，下面是曾经修改过的一些游戏的入口地址，直接点击图片即可进入 1.2048游戏入口： 2.数独游戏入口： 3.Visiontest游戏入口： 4.Eyetest游戏入口：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
