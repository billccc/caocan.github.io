<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring笔记（四） Spring整合Hibernate]]></title>
    <url>%2F2018%2F01%2F08%2FSpring4%2F</url>
    <content type="text"><![CDATA[本节介绍Spring整合Hibernate的过程。 第二十五课. Spring-DataSource-1从这一节开始，我们将spring与hibernate进行整合。 首先我们需要在配置文件中配置dbcp，也就是database connection pool，连接池。 查阅spring文档： 我们把这个复制到beans.xml中：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;!--&lt;aop:aspectj-autoproxy/&gt;--&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/spring"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="09129421"/&gt; &lt;/bean&gt; &lt;bean id="logIntercepter" class="com.bjsxt.aop.LogInterceptor"&gt; &lt;/bean&gt; &lt;aop:config&gt;&lt;!-- &lt;aop:pointcut expression="execution(public * com.bjsxt.service..*.add(..))" id="servicePointcut"/&gt;--&gt; &lt;aop:aspect id="logAspect" ref="logIntercepter"&gt; &lt;aop:before method="before" pointcut="execution(public * com.bjsxt.service..*.add(..))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 然后我们引入我们需要的jar包：commons-dbcp.jarcommons-pool.jar以及jdbc的驱动：mysql-connector-java-5.1.44-bin.jar 在UserDAOImpl中创建dataSource，并且插入一条数据：12345678910111213141516171819202122232425262728293031323334353637package com.bjsxt.dao.impl;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.User;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@Component("u")//userDAOImplpublic class UserDAOImpl implements UserDAO &#123; private DataSource dataSource; @Override public void save(User u) &#123; try &#123; Connection conn = dataSource.getConnection(); conn.createStatement().executeUpdate("insert into user values (null, 'zhangsan')"); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; System.out.println("a user saved!");// throw new RuntimeException("exception"); &#125; public DataSource getDataSource() &#123; return dataSource; &#125; @Resource public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125;&#125; 然后我们创建一个spring的数据库： 运行，查看数据库： 发现成功将我们的数据插入到数据库中。 第二十六课. Spring-DataSource-2除了上面的方式，我们可以在Spring中使用PropertyPlaceHolderConfigure来读取Properties文件的内容。 修改beans.xml：12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 然后在src文件夹下创建一个jdbc.properties文件：1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/springjdbc.username=rootjdbc.password=09129421 运行，正常。 两种方法都可以的。 第二十七课. Spring-整合Hibernate为了让Spring支持Hibernate，我们需要引入下面这些jar包： 重写Model，给User加上注解：123456789101112131415161718192021222324252627package com.bjsxt.model;import javax.persistence.*;@Entitypublic class User &#123; private int id; private String name; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 重写UserDAOImpl，在里面取得SessionFactory，并且保存一个User：1234567891011121314151617181920212223242526272829303132333435363738package com.bjsxt.dao.impl;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.User;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.stereotype.Component;import javax.annotation.Resource;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@Component("u")//userDAOImplpublic class UserDAOImpl implements UserDAO &#123; private SessionFactory sessionFactory; @Override public void save(User u) &#123; System.out.println("session factory class:" + sessionFactory.getClass()); Session s = sessionFactory.openSession(); s.beginTransaction(); s.save(u); s.getTransaction().commit(); System.out.println("a user saved!");// throw new RuntimeException("exception"); &#125; public SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; @Resource public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125;&#125; 参考文档，修改beans,xml的配置：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="annotatedClasses"&gt; &lt;list&gt; &lt;value&gt;com.bjsxt.model.User&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行： 发现SessionFactory并不是AnnotationSessionFactoryBean，而是org.hibernate.impl.SessionFactoryImpl，我们查看数据库： 由于没有设置名字，所以插入一条NULL，正确。 第二十八课. 使用Annotation进行声明式事务管理这一次我们的想法是，每次插入一条用户数据的时候，就同时向数据库中插入一条日志记录。另外，我们这一次不需要自己去写事务相关的逻辑，而是交由Spring帮我们来注入，我们只需要关注于逻辑本身就可以了。 为了达到这个目的，我们需要先在beans.xml中进行声明式事务的配置，在里面加入tx的命名空间：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="annotatedClasses"&gt; &lt;list&gt; &lt;value&gt;com.bjsxt.model.User&lt;/value&gt; &lt;value&gt;com.bjsxt.model.Log&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;!-- enable the configuration of transactional behavior based on annotations --&gt; &lt;tx:annotation-driven transaction-manager="txManager"/&gt;&lt;/beans&gt; 上面的配置主要加入如下语句：xmlns:tx=http://www.springframework.org/schema/tx 其对应的schemaLocation：http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-2.5.xsd“ 以及：123456&lt;bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt;&lt;!-- enable the configuration of transactional behavior based on annotations --&gt;&lt;tx:annotation-driven transaction-manager="txManager"/&gt; 先在Model层创建一个Log的model：12345678910111213141516171819202122232425262728package com.bjsxt.model;import javax.persistence.*;@Entity@Table(name="t_log")public class Log &#123; private int id; private String msg; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125;&#125; 在DAO层创建一个LogDAO：1234567package com.bjsxt.dao;import com.bjsxt.model.User;public interface UserDAO &#123; public void save(User u);&#125; 然后写一个它的实现类：LogDAOImpl：123456789101112131415161718192021222324252627282930313233package com.bjsxt.dao.impl;import com.bjsxt.dao.LogDAO;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.Log;import com.bjsxt.model.User;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Component("logDAO")public class LogDAOImpl implements LogDAO &#123; private SessionFactory sessionFactory; public void save(Log log) &#123; Session s = sessionFactory.getCurrentSession(); s.save(log); &#125; public SessionFactory getSessionFactory() &#123; return sessionFactory; &#125; @Resource public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125;&#125; 注意这一次的实现中，我们没有自己去提交，而是交由spring帮我们提交事务。 那么，一个事务应该是什么样子的？考虑一下，当我们在记录日志的时候，突然出现异常，那么这个时候应该事务回滚，而且插入User这一操作也应该回滚，也就是说，一个事务包括插入User和插入Log两部分，它们一块组成事务。所以我们不应该在DAO层中定义事务，而是应该在Service层中来完成对事务的定义。 UserService：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.bjsxt.service;import com.bjsxt.dao.LogDAO;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.Log;import com.bjsxt.model.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Component;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;@Component("userService")public class UserService &#123; private UserDAO userDAO; private LogDAO logDAO; @Transactional public void add(User u) &#123; this.userDAO.save(u); Log log = new Log(); log.setMsg("a user saved"); logDAO.save(log); &#125; public UserDAO getUserDAO() &#123; return userDAO; &#125; @Resource(name="u") public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125; public void init()&#123; System.out.println("init"); &#125; public void destroy()&#123; System.out.println("destroy"); &#125; @Resource public void setLogDAO(LogDAO logDAO) &#123; this.logDAO = logDAO; &#125; public LogDAO getLogDAO() &#123; return logDAO; &#125;&#125; 这一次，我们通过在add方法上加上@Transactional注解，并且在add方法中加入对Log的存库，这样就把插入User和插入Log两个操作合成了一个事务。 运行后查看数据库： 没问题。 如果我们这个时候在UserDAOImpl中抛出一个RuntimeException，那么就会回滚：123456public void save(Log log) &#123; Session s = sessionFactory.getCurrentSession(); s.save(log); &#125; 运行会报错，而且数据库还和原来一样，没有插入数据。 第二十九课. 使用xml进行声明式事务管理Transaction propagation有多种取值，默认是Required，这个也是我们常用的，唯一需要记住的。它的示例图如下： 也就是说，如果系统中已经有了一个Transaction，那么我们就不需要再新建一个，只是需要把不同的方法加到这个Transaction就可以了。如果没有，那么我们新建一个Transaction。 下面一个取值是MANDATORY，这个取值是说，我们必须有一个数据库事务，如果没有，那么就报错。 NESTED，如果已经有了一个Transaction，那么我们就停止这个Transaction，在里面嵌入一个Transaction，执行完新的Transaction之后，再继续原来的Transaction。这个叫做内嵌，用的极少极少，了解即可。 NEVER：方法执行，必须不能有事务，有事务就抛异常。 NOT_SUPPORT：如果已经有了一个Transaction，那么我们就停止这个Transaction，新启动一个Transaction，执行完新的Transaction之后，再继续原来的Transaction。这个叫做内嵌，用的极少极少，了解即可。 REQUIRES_NEW：创建一个新的Transaction，如果原先有就给它挂起。 SUPPORTS：支持当前Transaction配置，如果有就有Transaction，如果没有就没有Transaction 上面六种就是事务的传播特性。 NESTED用了事务的保存点，也就是说，在旧事务上创建一个保存点，回滚也回滚到这个保存点。 现在我们讲过了传播事务，我们再来讲一下Transactional的取值： 这是Spring官方文档给出的所有取值，第一个就不需要说了，传播特性，上面主要讲的是这个。 第二个isolation，也就是数据库的隔离级别。 第三个readOnly，表明一个方法内部操作都是只读的，如果有修改插入操作等，会报错。比方我们修改原来的代码：1234567@Transactional(readOnly = true)public void add(User u) &#123; this.userDAO.save(u); Log log = new Log(); log.setMsg("a user saved"); logDAO.save(log);&#125; 运行： 抛出异常，警告不能插入。 如果我们新建一个单纯的查询操作的方法，比如一个User的getter方法，那么可以加readOnly=true，因为这样一方面可以防止我们误写了插入操作，另外一方面spring在内部还会帮我们做一些优化。 timeout：如果事务时间太长，就把它抛异常，终止掉，不常见。 rollbackFor：写明在哪些异常情况下回回滚，然后把异常名都写在rollbackFor之后 noRollbackFor：相对应与上面的rollbackFor，这个关键词注明的是哪些异常情况下不会回滚。 上面讲过了annotation情况下声明式事务管理，下面我们介绍xml形式的。 首先beans.xml中的annotation的配置就可以去掉了：12&lt;!-- enable the configuration of transactional behavior based on annotations --&gt; &lt;tx:annotation-driven transaction-manager="txManager"/&gt; 这一句可以去掉了。 原先UserService里面的Transactional注解也可以去掉了。 我们修改beans.xml如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt; &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="annotatedClasses"&gt; &lt;list&gt; &lt;value&gt;com.bjsxt.model.User&lt;/value&gt; &lt;value&gt;com.bjsxt.model.Log&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="hibernateProperties"&gt; &lt;props&gt; &lt;prop key="hibernate.dialect"&gt; org.hibernate.dialect.MySQLDialect &lt;/prop&gt; &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt; &lt;/bean&gt; &lt;!-- enable the configuration of transactional behavior based on annotations --&gt; &lt;!--&lt;tx:annotation-driven transaction-manager="txManager"/&gt;--&gt; &lt;aop:config&gt; &lt;!--定义我们的切面，就是service下的类的方法，命名为bussinessService--&gt; &lt;aop:pointcut id="bussinessService" expression="execution(public * com.bjsxt.service..*.*(..))"/&gt; &lt;!--为上面的切面定义要加的逻辑，具体参考txAdvice--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="bussinessService"/&gt; &lt;/aop:config&gt; &lt;!-- 事务管理器选择txManager，也就是hibernate为我们提供的事务管理器 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt; &lt;!-- the transactional semantics... --&gt; &lt;tx:attributes&gt; &lt;!-- 使得getUser方法变为事务只读 --&gt; &lt;tx:method name="getUser" read-only="true"/&gt; &lt;!-- 为add开头的方法添加事务传播配置，也就是默认的REQUIRED --&gt; &lt;tx:method name="add*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;/beans&gt; 在这个配置中，我们定义我们的切面，在切面上定义我们要加的声明式事务逻辑，并且选择hibernate为我们提供的事务管理器。 第三十课. Spring-Hibernate-packagesToScan-总结以前我们每写一个model，都需要往配置文件里面加一个，太麻烦，怎么办？我们看Spring.jar中有一个类叫做org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean这个类中有一个packagesToScan属性，并且可以设置：123public void setPackagesToScan(String[] packagesToScan) &#123; this.packagesToScan = packagesToScan;&#125; 那么我们就可以利用这个属性，要把我们扫描的包加进来就可以了（beans.xml）：123456789101112&lt;!--&lt;property name="annotatedClasses"&gt; &lt;list&gt; &lt;value&gt;com.bjsxt.model.User&lt;/value&gt; &lt;value&gt;com.bjsxt.model.Log&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;--&gt;&lt;property name="packagesToScan"&gt; &lt;list&gt; &lt;value&gt;com.bjsxt.model&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 这样，我们每次加入一个model，都只需要加到com.bjsxt.model这个package里面就可以了，不需要再写到beans.xml AOP总结（关于面试） 介绍一下什么是AOP？ 画一个图，一个箭头，用两个竖线截断，两个竖线就是连接点。举个例子，一个方法正在运行，前面加一个日志，后面加一个日志，前面加一个transaction begin，后面加一个transaction commit，这就是AOP。具体实现：如果是interface，那么就拿jdk中的proxy加上InvocationHandler来实现，具体的需要查查；如果不是interface，那么就cglib，也需要回去查查。 AOP主要用在哪些方法：权限审查、日志、审计等等 项目中怎么用的？我们在项目中主要是用在声明式事务管理上 第三十一课. HibernateTemplate下面我们介绍三个话题：HibernateTemplate（理解这个）、HibernateCallback、HibernateDaoSupport（不重要）介绍 先来本节介绍HibernateTemplate，它用到了一种设计模式，就是Template Method(模板方法)，理解什么是模板，比方一个试卷，问题都一样，只有答案不一样，这是一个模板；比方人生，出生、青年、中年、老年、死亡，具体怎么过，也是由我们自己决定，这也是模板。 我们先来看一下spring里面的HibernateTemplate怎么用。 先来配置一下beans.xml：123&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt; 原先我们需要在UserDAOImpl中如此设计save方法：1234567891011121314151617181920private SessionFactory sessionFactory;public void save(User u) &#123; Session s = null; try&#123; s = sessionFactory.openSession(); s.getTransaction().begin(); s.save(u); s.getTransaction().commit(); &#125;catch (HibernateException e)&#123; e.printStackTrace(); s.getTransaction().rollback(); &#125;finally &#123; if (s != null)&#123; s.close(); s = null; &#125; &#125;&#125; 现在这些涉及到事务的操作以及异常处理操作都不再需要我们自己来写，由于这些操作都是固定的，所以我们完全可以交由hibernate的模板来帮我们实现，我们只需要来写我们自己的逻辑就可以了。所以精简以后的代码如下：12345private HibernateTemplate hibernateTemplate;@Overridepublic void save(User u) &#123; hibernateTemplate.save(u);&#125; 这样就极大的简化了操作。 具体hibernate是怎么实现这个模板呢？ 我们可以来看一下源码（spring.jar!/org/springframework/orm/hibernate3/HibernateTemplate.class）：12345678public Serializable save(final Object entity) throws DataAccessException &#123; return (Serializable)this.executeWithNativeSession(new HibernateCallback() &#123; public Object doInHibernate(Session session) throws HibernateException &#123; HibernateTemplate.this.checkWriteOperationAllowed(session); return session.save(entity); &#125; &#125;);&#125; 这里用到了一个callback函数，也就是回调函数。 我们来自己写一个函数来模拟这个过程：先定一一个接口，里面封装了我们自己要定义的回调过程：12345import org.hibernate.Session;public interface MyHibernateCallBack &#123; public void doInHibernate(Session s);&#125; 然后我们去实现模板并调用回调函数：1234567891011121314151617181920212223242526272829303132333435363738import org.hibernate.Session;import org.springframework.orm.hibernate3.HibernateCallback;public class MyHibernateTemplate &#123; public void executeWithNativeSession(MyHibernateCallBack callBack)&#123; Session s = null; try&#123; s = getSession(); s.beginTransaction(); callBack.doInHibernate(s); s.getTransaction().commit(); &#125;catch (Exception e)&#123; s.getTransaction().rollback(); &#125;finally &#123; //... &#125; &#125; public Session getSession() &#123; return null; &#125; public void save(final Object o) &#123; class MyHibernateCallbackImpl implements MyHibernateCallBack&#123; @Override public void doInHibernate(Session s) &#123; s.save(o); &#125; &#125; MyHibernateCallBack callBack = new MyHibernateCallbackImpl(); new MyHibernateTemplate().executeWithNativeSession(callBack); &#125;&#125; 可以看到，我们只需要调用模板的save方法，就可以自动帮我们生成事务以及异常处理的相关代码。这就是模板设计模式。 Callback：回调，钩子函数 就是我们在顺序执行模板的时候，突然在某一个地方是需要我们自己去实现的，这个地方就需要调用一个我们自己定义的函数，他就是回调函数，也叫做钩子函数。 第三十二课. HibernateDaoSupport第一种：（建议） 在spring中初始化HibernateTemplate，注入sessionFactory DAO里注入HibernateTemplate save写getHibernateTemplate.save(); 第二种： 从HibernateDaoSupport继承 必须写在xml文件中，无法使用Annotation，因为set方法在父类中，而且是final的 我们基本不用第二种方法，这里只要用第一种方法。 设想这样一个场景，就是我们的LogDAOImpl需要HibernateTemplate，UserDAOImpl也需要，那么按照上一节提供的方法，每一个bean都需要配置注入sessionFactory，如下：123&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt; 有没有办法将这些都抽象到一个父类，我们继承就可以默认来注入呢？先写一个SuperDAO：12345678910111213141516171819202122package com.bjsxt.dao.impl;import org.springframework.orm.hibernate3.HibernateTemplate;import org.springframework.orm.hibernate3.support.HibernateDaoSupport;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Componentpublic class SuperDAO&#123; private HibernateTemplate hibernateTemplate; public HibernateTemplate getHibernateTemplate() &#123; return hibernateTemplate; &#125; @Resource public void setHibernateTemplate(HibernateTemplate hibernateTemplate) &#123; this.hibernateTemplate = hibernateTemplate; &#125;&#125; 这样里面就已经注入了HibernateTemplate，然后我们需要在beans.xml中进行注入：123&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt; 由于我们的SuperDAO中已经有了HibernateTemplate，所以Spring会帮我们来向这个HibernateTemplate中注入sessionFactory，接下来我们只需要继承这个类，就可以使用HibernateTemplate了：1234567891011121314151617@Component("logDAO")public class LogDAOImpl extends SuperDAO implements LogDAO &#123; public void save(Log log) &#123; this.getHibernateTemplate().save(log);// this.save(log); &#125;&#125;@Component("u")//userDAOImplpublic class UserDAOImpl extends SuperDAO implements UserDAO &#123; public void save(User u) &#123; this.getHibernateTemplate().save(u); &#125;&#125; 运行一下，成功。 第三十四课. Spring-Hibernate-HibernateDaoSupport-3这一节我们讲解HibernateDaoSupport：修改SuperDAO：12345678910111213141516package com.bjsxt.dao.impl;import org.hibernate.SessionFactory;import org.springframework.orm.hibernate3.HibernateTemplate;import org.springframework.orm.hibernate3.support.HibernateDaoSupport;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Componentpublic class SuperDAO extends HibernateDaoSupport&#123; @Resource(name="hibernateTemplate") public void setSuperHibernateTemplate(HibernateTemplate hibernateTemplate) &#123; super.setHibernateTemplate(hibernateTemplate); &#125;&#125; 为了使用注解，我们还是在SuperDAO中调用了其父类的setHibernateTemplate方法。 然后我们在beans.xml中配置：123&lt;bean id="hibernateTemplate" class="org.springframework.orm.hibernate3.HibernateTemplate"&gt; &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt; 这样就可以将sessionfactory注入到我们的SuperDAO中了，并且从这个类继承实现的DAO都可以拥有HibernateTemplate（set注入）和sessionfactory了。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 22.Generate Parentheses（生成括号）]]></title>
    <url>%2F2018%2F01%2F07%2Fleetcode22%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/generate-parentheses/description/ 题目大意：给定一个括号序列，写一个函数用于生成正确形式的括号组合。例如，给定n = 3，一个解决方案集是：“((()))”, “(()())”, “(())()”, “()(())”, “()()()” 解决思路：我们先将其的生成过程画出来： 可以看到这个过程其实是一个递归过程： 如果左右括号数都等于n，那么就把这个生成的字符串输出 如果左括号等于n，那么就只允许后续操作添加右括号 左括号不能小于右括号，如果小于，则返回 代码：12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); int left = 0; int right = 0; generateParenthesis(n, 0, 0, 0, new StringBuilder(""), res); return res; &#125; public void generateParenthesis(int n, int pos, int left, int right, StringBuilder tmp, List&lt;String&gt; res)&#123; if(left == n &amp;&amp; right == n) &#123; res.add(tmp.toString()); return; &#125; if(left &lt; right) return; if(left == n)&#123; tmp.replace(pos, pos+1, ")"); System.out.println(tmp.toString()); generateParenthesis(n, pos+1, left, right+1, tmp, res); &#125; else&#123; tmp.replace(pos, pos+1, "("); System.out.println(tmp.toString()); generateParenthesis(n, pos+1, left+1, right, tmp, res); tmp.replace(pos, pos+1, ")"); System.out.println(tmp.toString()); generateParenthesis(n, pos+1, left, right+1, tmp, res); &#125; &#125;&#125; 另外注意，这道题其实是一道经典的卡特兰数问题，卡特兰数公式如下：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring笔记（三） AOP]]></title>
    <url>%2F2018%2F01%2F02%2FSpring3%2F</url>
    <content type="text"><![CDATA[本文主要介绍Spring中的AOP编程方式。 第十九课. AOP-Introduction-1什么是AOP?面向切面编程Aspect-Oriented-Programming是对面向对象的思维方式的有力补充 现在我们设想一个场景，就是要给DAO添加一个记录日志功能，也就是在它执行save函数之前，能够将日志打印到控制台。 首先想到的第一个做法是，在save方法内部记录日志：1234567public class UserDAOImpl implements UserDAO &#123; @Override public void save(User u) &#123; System.out.println("save start..."); System.out.println("a user saved!"); &#125;&#125; 第二种方法，考虑你已经交付代码，这时候则不能修改源码，所以可以采用继承的方式，重写save方法：1234567public class UserDAOImpl2 extends UserDAOImpl&#123; @Override public void save(User u) &#123; System.out.println("save start..."); super.save(u); &#125;&#125; 第三种方法，就是去实现UserDAO接口，然后将我们要加日志的类的对象放入这个新类内部，并对对象加日志：12345678910public class UserDAOImpl3 implements UserDAO &#123; private UserDAO userDAO = new UserDAOImpl(); @Override public void save(User u) &#123; new LogInterceptor().beforeMethod(); userDAO.save(u); &#125;&#125; 设想这样一个场景，我们要给100个UserDAO加日志，怎么办？总不能去挨个组装吧，所以这时候我们需要jdk提供的代理功能了。 第二十一课. AOP-Introduction-3这一节试着用动态代理来处理代码。 重写LogInterceptor，让LogInterceptor去实现InvocationHandler接口：1234567891011121314151617181920212223package com.bjsxt.aop;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class LogInterceptor implements InvocationHandler&#123; private Object target; public void beforeMethod()&#123; System.out.println("save start"); &#125; @Override public Object invoke(Object proxy, Method m, Object[] args) throws Throwable &#123; beforeMethod(); m.invoke(target, args); return null; &#125; public void setTarget(Object target) &#123; this.target = target; &#125;&#125; 这样就可以给target对象的方法前加上beforeMethod这个方法。 我们来测试一下：12345678@Testpublic void testProxy()&#123; UserDAO userDAO = new UserDAOImpl(); LogInterceptor li = new LogInterceptor(); li.setTarget(userDAO); UserDAO userDAOProxy = (UserDAO)Proxy.newProxyInstance(userDAO.getClass().getClassLoader(),new Class[]&#123;UserDAO.class&#125;,li); userDAOProxy.save(new User());&#125; 具体内部怎么实现，可以参考前面的动态代理的笔记：https://caocan.github.io/2017/12/26/DesignPattern5/ 如果我们在UserDAO中增加了一个delete方法：1234public interface UserDAO &#123; public void save(User u); public void delete();&#125; 实现接口：1234567891011public class UserDAOImpl implements UserDAO &#123; @Override public void save(User u) &#123; System.out.println("a user saved!"); &#125; @Override public void delete() &#123; System.out.println("user deleted"); &#125;&#125; 测试：123456789@Testpublic void testProxy()&#123; UserDAO userDAO = new UserDAOImpl(); LogInterceptor li = new LogInterceptor(); li.setTarget(userDAO); UserDAO userDAOProxy = (UserDAO)Proxy.newProxyInstance(userDAO.getClass().getClassLoader(),new Class[]&#123;UserDAO.class&#125;,li); userDAOProxy.save(new User()); userDAOProxy.delete();&#125; 运行： 发现不光给add方法增加了记录日志功能，而且delete方法也被加上了日志功能。 如果我们想针对每一种方法，为止动态生成对应的处理逻辑，怎么做？由于我们可以拿到Method，所以可以根据Method不同来生成对应的结果：123456789101112131415161718public class LogInterceptor implements InvocationHandler&#123; private Object target; public void beforeMethod(Method m)&#123; System.out.println(m.getName() + " start"); &#125; @Override public Object invoke(Object proxy, Method m, Object[] args) throws Throwable &#123; beforeMethod(m); m.invoke(target, args); return null; &#125; public void setTarget(Object target) &#123; this.target = target; &#125;&#125; 这时候运行会报一个小小的错误，需要给UserDAOImpl3中方法的对应函数传入一个参数：123456789101112131415public class UserDAOImpl3 implements UserDAO &#123; private UserDAO userDAO = new UserDAOImpl(); @Override public void save(User u) &#123; new LogInterceptor().beforeMethod(null); userDAO.save(u); &#125; @Override public void delete() &#123; &#125;&#125; 运行： 成功。 第二十二课. AOP-Annotation-1Aspectj是一个专门用来产生动态代理，或者说专门面向切面编程的框架，Spring实现使用了它。 为了让Spring代码可以使用AOP的Annotation，我们可以将两个jar包引入： 然后在beans.xml中进行配置：12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 这样我们就可以使用AOP的注解了。 我们使用AOP的注解在UserDAOImpl的save方法前加一段记录日志的逻辑：1234567891011121314package com.bjsxt.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Aspect@Component //初始化public class LogInterceptor &#123; @Before("execution(public void com.bjsxt.dao.impl.UserDAOImpl.save(com.bjsxt.model.User))") public void before()&#123; System.out.println("method start"); &#125;&#125; 运行一下： 发现逻辑被成功加了上去。 AOP的一些术语： 通知、增强处理（Advice） 就是你想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下。包含Aspect的一段处理代码 连接点（JoinPoint） 这个就更好解释了，就是spring允许你是通知（Advice）的地方，那可就真多了，基本每个方法的钱、后（两者都有也行），或抛出异常是时都可以是连接点，spring只支持方法连接点。其他如AspectJ还可以让你在构造器或属性注入时都行，不过那不是咱们关注的，只要记住，和方法有关的前前后后都是连接点。 切入点（Pointcut） 上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有十几个连接点了对吧，但是你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。 切面（Aspect） 切面是通知和切入点的结合。现在发现了吧，没连接点什么事，链接点就是为了让你好理解切点搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。 引入（introduction） 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗 目标（target） 引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咋们织入切面。二自己专注于业务本身的逻辑。 代理（proxy） 怎么实现整套AOP机制的，都是通过代理，这个一会儿给细说。 织入（weaving） 把切面应用到目标对象来创建新的代理对象的过程。有三种方式，spring采用的是运行时，为什么是运行时，在上一文《Spring AOP开发漫谈之初探AOP及AspectJ的用法》中第二个标提到。 目标对象 – 项目原始的Java组件。 AOP代理 – 由AOP框架生成java对象。 AOP代理方法 = advice + 目标对象的方法。下面的图简化和形象的说明了AOP 形象上看，AOP编程，就像做汉堡一样。原始面包 - 目标对象的方法。业务组件就行了。肉块 - Advice汉堡 - AOP代理的方法。将肉加到面包 - 引入 关键就是：切面定义了哪些连接点会得到通知。 第二十三课. AOP-Annotation-2有了上面的术语，我们现在就用代码来深入理解一下这些概念。 我们想在一个方法的前后都加上日志，那么就需要在方法的前面加@Before，在方法的后面加@AfterReturning。 代码如下：12345678910111213141516171819202122package com.bjsxt.aop;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Aspect@Component //初始化public class LogInterceptor &#123; @Before("execution(public * com.bjsxt.dao..*.*(..))") public void before()&#123; System.out.println("method start"); &#125; @AfterReturning("execution(public * com.bjsxt.dao..*.*(..))") public void afterReturning()&#123; System.out.println("method after returning"); &#125;&#125; 运行后的结果： 发现方法的前后都被成功加上了日志。 但是每对一个方法前后加日志，就需要这么定义一次注解，好麻烦的，能不能简单一些？ 我们可以定义一系列切入点的集合，也就是Pointcut：12345678910111213141516@Aspect@Component //初始化public class LogInterceptor &#123; @Pointcut("execution(public * com.bjsxt.dao..*.*(..))") public void myMethod()&#123; &#125;; @Before("myMethod()") public void before()&#123; System.out.println("method start"); &#125; @AfterReturning("myMethod()") public void afterReturning()&#123; System.out.println("method after returning"); &#125;&#125; 运行后也可以成功加上日志。 再来测试一下@AfterThrowing，先在UserDAOImpl中抛出一个异常：12345678@Component("u")//userDAOImplpublic class UserDAOImpl implements UserDAO &#123; @Override public void save(User u) &#123; System.out.println("a user saved!"); throw new RuntimeException("exception"); &#125;&#125; 然后在LogInterceptor中加上@AfterThrowing注解： 1234@AfterThrowing("myMethod()")public void afterReturning()&#123; System.out.println("method after returning");&#125; 运行，会报错： 这样就成功捕捉到了异常，之后就可以在@AfterThrowing中的方法加入我们对应的处理逻辑。 如果我们想在一个方法前后都加上逻辑，怎么做？这时候用到了@Around：123456@Around("myMethod()")public void aroundMethod(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("method around start"); pjp.proceed(); System.out.println("method around end");&#125; 运行： 成功。 如果我们想在service上加切入点，直接加可以吗？12345@Aspect@Component //初始化public class LogInterceptor &#123; @Pointcut("execution(public * com.bjsxt.service..*.add(..))") public void myMethod()&#123; &#125;; 运行： 很明确说出了一个问题，service实现的不是一个接口，不能直接使用jdk提供的代理功能，所以要引入一个jar包：cglib-nodep-2.1_3.jar 这次我们再运行： 这次就可以顺利运行了。 第二十四课. AOP-XML这一节中，我们不再使用Annotation来完成AOP功能，而是使用xml来实现。 首先需要将上一节的注解以及配置都删除掉，然后我们来配置beans.xml：123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;!--&lt;aop:aspectj-autoproxy/&gt;--&gt; &lt;bean id="logIntercepter" class="com.bjsxt.aop.LogInterceptor"&gt; &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(public * com.bjsxt.service..*.add(..))" id="servicePointcut"/&gt; &lt;aop:aspect id="logAspect" ref="logIntercepter"&gt; &lt;aop:before method="before" pointcut-ref="servicePointcut"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 来讲一下具体执行过程，首先代码执行UserServiceTest，执行到service的add方法的时候，spring发现这个方法符合expression=&quot;execution(public * com.bjsxt.service..*.add(..))&quot;这个表达式，并且这个表达式上面有一个切面，这个切面引用了一个切面类对象logInterceptor，在这个里面它要求，在这个方法（add方法）执行之前，aop:before，会执行我们logInterceptor的方法，哪一个方法呢？它就是before方法，这样我们的切面逻辑就加进去了。 也可以将上面的xml改成这样：12345&lt;aop:config&gt; &lt;aop:aspect id="logAspect" ref="logIntercepter"&gt; &lt;aop:before method="before" pointcut="execution(public * com.bjsxt.service..*.add(..))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 这样就不需要参考了，都可以。 提倡使用xml，因为我们很多时候用的切面都是spring帮我们提供的第三方类，所以不能在上面加注解，这时候用xml方式就是比较好的方式。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring笔记（二） IOC的Annotation]]></title>
    <url>%2F2017%2F12%2F29%2FSpring2%2F</url>
    <content type="text"><![CDATA[本文主要介绍使用IOC注解方式，达到和上一章中xml配置相同的效果。 第十六课. Annotation-Resource-Component之前我们都是在xml中对Spring进行配置，这一课开始，我们进入注解之旅。 参考文档，有这么一段： 也就是说，如果我们想要用Annotation，就必须在beans.xml中加入这些配置。 上面的xmlns就是xml namespace的缩写，也就是一个命名空间 xsd里面装着我们能写的名字，也就是命名空间的具体内容。 我们重新修改我们的beans.xml：1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;bean name="u" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.bjsxt.service.UserService"&gt; &lt;/bean&gt;&lt;/beans&gt; 来讲解一下这个xml：首先&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;是xml文件标准的开头 然后下一句1&lt;beans xmlns="http://www.springframework.org/schema/beans" 没有任何前缀的bean，它们的schemaLocation是从哪里找，就是http://www.springframework.org/schema/beans/spring-beans-2.5.xsd这个文件里面有配置。所以，所有的&lt;bean，都是从上面那个xsd里面读出来的。 下一句：1xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 表明以xsi开头的，都要从http://www.w3.org/2001/XMLSchema-instance 具体的schemaLocation里面去找。 而1xmlns:context="http://www.springframework.org/schema/context" 这一句，表明以context开头的schemaLocation，其具体的对应xsd，就是http://www.springframework.org/schema/context/spring-context-2.5.xsd 从上面我们可以看出来，xsd里面定义的，就是xml具体的语法。所以把xsd文件称作元数据文件。最早确定xml元数据的，是dtd文件。 配置好上面的文件，我们就可以利用注解来重写我们的程序了。 修改UserService.java中对UserDAO的setter：1234@Autowiredpublic void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO;&#125; 编写测试用例：1234567891011public class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); UserService service = (UserService)ctx.getBean("userService"); service.add(new User()); ctx.destroy(); &#125;&#125; 注意：上面的代码必须在java6上运行（在java8不兼容，报错了，所以还是要去学习最新的spring技术） 运行： 重新修改beans.xml，这次定义两个UserDAOImpl：1234567&lt;bean name="u" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt;&lt;/bean&gt;&lt;bean name="u2" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt;&lt;/bean&gt; 运行： 发现报错了。其实还是上面的问题，就是这个@Autowired ,它默认是autowire=”byType”，所以为了避免这个问题，我们可以继续加注解：1234@Autowiredpublic void setUserDAO(@Qualifier("u") UserDAO userDAO) &#123; this.userDAO = userDAO;&#125; 运行： 成功。 第十七课. Annotation-Resource-Component@Resource（重要） 加入：j2ee/common-annotations.jar 默认按名称，名称找不到，按类型 可以指定特定名称 推荐使用 不足：如果没有源码，就无法运用annotation，只能使用xml 代码：1234@Resource(name="u")public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO;&#125; 下面我们演示@Component 修改bean.xml，将UserDAO的bean都删除，然后配置component：123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;context:component-scan base-package="com.bjsxt"/&gt; &lt;bean id="userService" class="com.bjsxt.service.UserService"&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 这样就会去com.bjsxt下面的包去扫描对应的组件。 将UserService中的@Resource中的name去掉：1234@Resourcepublic void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO;&#125; 为UserDAOImpl加上注解：12345678910111213package com.bjsxt.dao.impl;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.User;import org.springframework.stereotype.Component;@Component//userDAOImplpublic class UserDAOImpl implements UserDAO &#123; @Override public void save(User u) &#123; System.out.println("a user saved!"); &#125;&#125; 运行： 成功将一个DAO注入到Service中被注入的DAO默认生成名字userDAOImpl 如果我们想自己为DAO手动设置名字，怎么做？ 修改DAO：1234567@Component("u")//userDAOImplpublic class UserDAOImpl implements UserDAO &#123; @Override public void save(User u) &#123; System.out.println("a user saved!"); &#125;&#125; 修改Service：1234@Resource(name="u")public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO;&#125; 这样就将名字为u的DAO注入到Service中： OK~ 上面我们已经将xml中的DAO的bean替换成了注解形式的了，如果我们还想把Service也替换掉，怎么做？很简单，修改UserService代码： 12@Component("userService")public class UserService &#123; 删掉xml中Service的bean，运行： 成功！ 再详细溜一下上面代码的过程：首先先加载1ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); 即读beans.xml里面的内容，然后通过12&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;&lt;context:component-scan base-package="com.bjsxt"/&gt; 找从com.bjsxt开始“scan”含@component的类， 找到之后就初始化对象，结果在 1234@Resource(name="u")public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO;&#125; 其一个属性的set方法上找到一个源为“u”的一个bean，于是就加载那个bean！ 这样看起来，注解比xml方式方便的多！但是，xml没用了吗？非也！当我们交付程序以后，源码就不能和看到了，所以我们不能在源码上加注解，这时候就需要在xml中进行配置。 @Component @Service @Controller @Repository（四个一样的功能！！） 初始化的名字默认为类名首字母小写 可以指定初始化bean的名字 第十八课. Annotation-修正-Pre-Post-Scope之前我们在xml中使用过scope，如果我们想在注解中使用，只需要在需要的类前加上@Scope注解，并标明是singleton还是prototype 另外，我们为了达到之前的init和destroy效果，就是规定一个bean的生命周期，可以加注解@PostConstruct和@PreDestroy：123456789 @PostConstruct public void init()&#123; System.out.println("init"); &#125; @PreDestroy public void destroy()&#123; System.out.println("destroy");&#125; 这样就不需要在bean中标明了。 运行： OK。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring笔记（一） 模拟Spring]]></title>
    <url>%2F2017%2F12%2F29%2FSpring1%2F</url>
    <content type="text"><![CDATA[本文主要模拟一下Spring。 第一课. 模拟Spring-01课程内容 面向接口（抽象）编程的概念与好处 IOC/DI的概念与好处a) Inversion of controlb) dependency injection AOP的概念与好处 Spring简介 Spring应用IOC/DI（重要）a) xmlb) annotation Spring应用AOP（重要）a) xmlb) annotation Struts2.1.6 + Spring 2.5.6 + Hibernate3.3.2整合（重要）a) opensessionInviewfilter（记住，解决什么问题，怎么解决） 第二课. 模拟Spring-02Spring框架图示： 第三课. 模拟Spring-03这一节开始，我们模拟Spring。 我们来设想一个处理用户的场景，在这个系统里，可以添加用户，并且把用户存储到数据库里。 创建四个包： 在com.bjsxt.model中创建Model，也就是User：12345678910111213141516171819202122package com.bjsxt.model;public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 在com,bjsxt.dao中创建DAO的抽象接口，这个接口的主要功能是去保存一个用户：1234567package com.bjsxt.dao;import com.bjsxt.model.User;public interface UserDAO &#123; public void save(User u);&#125; 然后我们在com.bjsxt.dao.impl包中实现这个接口：1234567891011package com.bjsxt.dao.impl;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.User;public class UserDAOImpl implements UserDAO &#123; @Override public void save(User u) &#123; System.out.println("a user saved!"); &#125;&#125; 在com.bjsxt.service包中，创建业务逻辑，也就是处理用户的service：12345678910111213141516171819202122package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;public class UserService &#123; private UserDAO userDAO = new UserDAOImpl(); public void add(User u) &#123; this.userDAO.save(u); &#125; public UserDAO getUserDAO() &#123; return userDAO; &#125; public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125;&#125; 注意：为什么要创建一个DAO的接口？主要是为了可扩展性，比如这个DAO是要与数据库打交道，那么具体实现可以有Mysql的实现，也可以有Oracle的实现。 第四课. 模拟Spring-04先模拟一下Spring的配置文件，其实这一部分内容之前在工厂模式的笔记中有。 先创建一个test.xml：12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;HD&gt; &lt;disk name="C"&gt; &lt;capacity&gt;8G&lt;/capacity&gt; &lt;directories&gt;200&lt;/directories&gt; &lt;files&gt;1580&lt;/files&gt; &lt;/disk&gt; &lt;disk name="D"&gt; &lt;capacity&gt;10G&lt;/capacity&gt; &lt;directories&gt;500&lt;/directories&gt; &lt;files&gt;3000&lt;/files&gt; &lt;/disk&gt;&lt;/HD&gt; 然后我们引入jdom.jar这个jar包，编写代码去解析xml中内容：(Sample1.java)：12345678910111213141516171819202122232425262728import org.jdom.*;import org.jdom.input.SAXBuilder;import org.jdom.xpath.XPath;import java.util.List;public class Sample1 &#123; public static void main(String[] args) throws Exception &#123; SAXBuilder sb = new SAXBuilder(); Document doc = sb.build(Sample1.class.getClassLoader().getResourceAsStream("test.xml")); Element root = doc.getRootElement(); List list = root.getChildren("disk"); for (int i = 0; i &lt; list.size(); i++) &#123; Element element = (Element) list.get(i); String name = element.getAttributeValue("name"); String capacity = element.getChildText("capacity"); //取disk子元素capacity的内容 String directories = element.getChildText("directories"); String files = element.getChildText("files"); System.out.println("磁盘信息:"); System.out.println("分区盘符:" + name); System.out.println("分区容量:" + capacity); System.out.println("目录数:" + directories); System.out.println("文件数:" + files); System.out.println("-----------------------------------"); &#125; &#125;&#125; 第五课. 模拟Spring-05基于上面的技术，我们把可以替换的类写到配置文件，然后去读xml配置即可。 beans.xml：123&lt;beans&gt; &lt;bean id="u" class="com.bjsxt.dao.impl.UserDAOImpl"/&gt;&lt;/beans&gt; 然后创建一个com.bjsxt.spring的包，在包内创建一个Bean工厂：12345package com.bjsxt.spring;public interface BeanFactory &#123; public Object getBean(String name);&#125; 然后模仿Spring创建一个ClassPathXmlApplicationContext类： 1234567891011121314151617181920212223242526272829303132333435package com.bjsxt.spring;import org.jdom.Document;import org.jdom.Element;import org.jdom.JDOMException;import org.jdom.input.SAXBuilder;import java.io.IOException;import java.util.HashMap;import java.util.List;import java.util.Map;public class ClassPathXmlApplicationContext implements BeanFactory&#123; @Override public Object getBean(String name) &#123; return beans.get(name); &#125; private Map&lt;String, Object&gt; beans = new HashMap&lt;String, Object&gt;(); public ClassPathXmlApplicationContext() throws Exception &#123; SAXBuilder sb = new SAXBuilder(); Document doc = sb.build(this.getClass().getClassLoader().getResourceAsStream("beans.xml")); Element root = doc.getRootElement(); //获取根元素 List list = root.getChildren("bean"); //取名字为disk的所有元素 for(int i = 0; i &lt; list.size(); i++)&#123; Element element = (Element)list.get(i); String id = element.getAttributeValue("id"); String clazz = element.getAttributeValue("class"); System.out.println(id + ":" + clazz); Object o = Class.forName(clazz).newInstance(); beans.put(id, o); &#125; &#125;&#125; 这样就可以解析xml，读到配置文件中的内容。 然后我们按照惯例，在project下创建一个test文件夹，在里面创建一个com.bjsxt.service的包，编写测试代码：12345678910111213141516171819202122package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;import com.bjsxt.spring.BeanFactory;import com.bjsxt.spring.ClassPathXmlApplicationContext;import org.junit.Test;public class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; BeanFactory factory = new ClassPathXmlApplicationContext(); UserService service = new UserService(); UserDAO userDAO = (UserDAO)factory.getBean("u"); service.setUserDAO(userDAO); User u = new User(); service.add(u); &#125;&#125; 注意要把jUnit4引入（最新是5.0版本）。 运行： 成功！ 第七课. 模拟Spring-07上一节中，UserDAO需要我们自己通过bean的名字来到bean工厂查找，就是这一段代码： 1234567BeanFactory factory = new ClassPathXmlApplicationContext();UserService service = new UserService();UserDAO userDAO = (UserDAO)factory.getBean("u");service.setUserDAO(userDAO);User u = new User();service.add(u); 现在我们不想自己去new一个UserDAO，而是改由容器来帮我们装配。也就是把测试代码改成下面这样：123456789101112131415161718192021222324package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;import com.bjsxt.spring.BeanFactory;import com.bjsxt.spring.ClassPathXmlApplicationContext;import org.junit.Test;public class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; BeanFactory factory = new ClassPathXmlApplicationContext(); UserService service = (UserService)factory.getBean("userService"); /*UserService service = new UserService(); UserDAO userDAO = (UserDAO)factory.getBean("u"); service.setUserDAO(userDAO);*/ User u = new User(); service.add(u); &#125;&#125; 怎么做？ 先修改beans,xml，让名字为u的bean成为Service的bean的一个属性：123456&lt;beans&gt; &lt;bean id="u" class="com.bjsxt.dao.impl.UserDAOImpl"/&gt; &lt;bean id="userService" class="com.bjsxt.service.UserService"&gt; &lt;property name="userDAO" bean="u"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 修改ClassPathXmlApplicationContext.java，通过反射机制来让容器帮我们将DAO设置到Service里面：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.bjsxt.spring;import org.jdom.Document;import org.jdom.Element;import org.jdom.JDOMException;import org.jdom.input.SAXBuilder;import java.io.IOException;import java.lang.reflect.Method;import java.util.HashMap;import java.util.List;import java.util.Map;public class ClassPathXmlApplicationContext implements BeanFactory&#123; @Override public Object getBean(String name) &#123; return beans.get(name); &#125; private Map&lt;String, Object&gt; beans = new HashMap&lt;String, Object&gt;(); public ClassPathXmlApplicationContext() throws Exception &#123; SAXBuilder sb = new SAXBuilder(); Document doc = sb.build(this.getClass().getClassLoader().getResourceAsStream("beans.xml")); Element root = doc.getRootElement(); //获取根元素 List list = root.getChildren("bean"); //取名字为disk的所有元素 for(int i = 0; i &lt; list.size(); i++)&#123; Element element = (Element)list.get(i); String id = element.getAttributeValue("id"); String clazz = element.getAttributeValue("class"); System.out.println(id + ":" + clazz); Object o = Class.forName(clazz).newInstance(); beans.put(id, o); for (Element propertyElement : (List&lt;Element&gt;)element.getChildren("property"))&#123; String name = propertyElement.getAttributeValue("name"); //userDAO String bean = propertyElement.getAttributeValue("bean"); //u Object beanObject = beans.get(bean); //UserDAOImpl instance String methodName = "set" + name.substring(0, 1).toUpperCase() + name.substring(1); System.out.println("method name = " + methodName); Method m = o.getClass().getMethod(methodName, beanObject.getClass().getInterfaces()[0]); m.invoke(o, beanObject); &#125; &#125; &#125;&#125; 运行一下Test: 成功！ 什么是IOC（DI），有什么好处 把自己new的东西改为由容器提供a) 初始化具体值b) 装配 好处：灵活配置 第八课. IOC简介上一节中我们试着模拟了一下Spring的过程，这一次我们真正使用Spring来完成和上一节中相同的功能。 首先我们需要引入几个包： 其中名字为Spring的library中，添加的是spring.jar包。 删去原来的spring的package，因为这一次我们要用真正的spring。 查阅spring的文档，编写我们的beans.xml：1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="u" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.bjsxt.service.UserService"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;property name="userDAO"&gt; &lt;ref bean="u"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 将Test引入的包改成spring的jar包中的类： 1234567891011121314151617181920212223242526package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;//Dependency Injection//Inverse of Controlpublic class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; BeanFactory factory = new ClassPathXmlApplicationContext("beans.xml"); UserService service = (UserService)factory.getBean("userService"); /*UserService service = new UserService(); UserDAO userDAO = (UserDAO)factory.getBean("u"); service.setUserDAO(userDAO);*/ User u = new User(); service.add(u); &#125;&#125; 运行一下： 成功~ 第九课. 自动提示-Spring注入类型注入类型：a) setter（重要）b) 构造方法（可以忘记）c) 接口注入（可以忘记） 上面的注入方式是setter注入，一定要记住，所谓setter注入就是调用了set什么什么方法。下面介绍一个构造注入的方式，只需要了解即可：先给UserService中加入一个构造函数：1234567891011121314151617181920212223242526package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;public class UserService &#123; public UserService(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125; private UserDAO userDAO = new UserDAOImpl(); public void add(User u) &#123; this.userDAO.save(u); &#125; public UserDAO getUserDAO() &#123; return userDAO; &#125; public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125;&#125; 然后我们重新修改beans.xml这个配置文件：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="u" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.bjsxt.service.UserService"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt;&lt;!-- &lt;property name="userDAO"&gt; &lt;ref bean="u"/&gt; &lt;/property&gt;--&gt; &lt;constructor-arg&gt; &lt;ref bean="u"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 第十课. Id-Name在beans.xml配置文件中，将bean的id换成name，也是一样的。 第十一课. 简单属性注入这一次我们在UserDAOImpl中加入两个字段：1234567891011121314151617181920212223242526272829303132333435363738package com.bjsxt.dao.impl;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.User;public class UserDAOImpl implements UserDAO &#123; /* (non-Javadoc) * @see com.bjsxt.dao.UserDAO#save(com.bjsxt.model.User) */ private int daoId; private String daoStatus; public int getDaoId() &#123; return daoId; &#125; public void setDaoId(int daoId) &#123; this.daoId = daoId; &#125; public String getDaoStatus() &#123; return daoStatus; &#125; public void setDaoStatus(String daoStatus) &#123; this.daoStatus = daoStatus; &#125; public void save(User user) &#123; System.out.println("user saved!"); &#125; @Override public String toString() &#123; return this.daoId + ":" + this.daoStatus; &#125;&#125; 修改beans.xml，在bean中对DAO中的属性进行简单配置：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt; &lt;bean name="userDAO" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;property name="daoId" value="8"&gt;&lt;/property&gt; &lt;property name="daoStatus" value="good"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.bjsxt.service.UserService"&gt; &lt;!-- &lt;property name="userDAO"&gt; &lt;ref bean="userDAO"/&gt; &lt;/property&gt; --&gt; &lt;constructor-arg&gt; &lt;ref bean="userDAO"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 这种方式在我们自己写程序其实不是很常用，了解即可。但是在Spring帮我们做好的一些配置上会用到，之后会学。 第十二课. scopebean的scope有多种，这里主要讲singleton和prototype默认的scope是singleton，也就是单例模式，我们来验证一下：123456789101112131415161718public class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; BeanFactory factory = new ClassPathXmlApplicationContext("beans.xml"); UserService service = (UserService)factory.getBean("userService"); UserService service2 = (UserService)factory.getBean("userService"); System.out.println(service == service2); /*UserService service = new UserService(); UserDAO userDAO = (UserDAO)factory.getBean("u"); service.setUserDAO(userDAO);*/ User u = new User(); service.add(u); &#125;&#125; 我们创建两个UserService，来看看他们是不是一个UserService，运行： 由运行结果看出，这两个UserService是同一个。 如果我们将scope修改成prototype：1&lt;bean id="userService" class="com.bjsxt.service.UserService" scope="prototype"&gt; 这次再运行： 这次两个Service就不是同一个了，也就是每次创建一个新的对象。 我们struts2中的action就应该是prototype的。 第十三课. 集合装配这一节的内容很少用，不重要，参考程序就可以： com.bjsxt.dao.UserDAO：123456789package com.bjsxt.dao;import com.bjsxt.model.User;public interface UserDAO &#123; public abstract void save(User user);&#125; com.bjsxt.dao.impl.UserDAOImpl：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.bjsxt.dao.impl;import java.util.List;import java.util.Map;import java.util.Set;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.User;public class UserDAOImpl implements UserDAO &#123; /* (non-Javadoc) * @see com.bjsxt.dao.UserDAO#save(com.bjsxt.model.User) */ private Set&lt;String&gt; sets; private List&lt;String&gt; lists; private Map&lt;String , String&gt; maps; public Set&lt;String&gt; getSets() &#123; return sets; &#125; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125; public List&lt;String&gt; getLists() &#123; return lists; &#125; public void setLists(List&lt;String&gt; lists) &#123; this.lists = lists; &#125; public Map&lt;String, String&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125; public UserDAOImpl() &#123; &#125; public void save(User user) &#123; System.out.println("user saved!"); &#125; @Override public String toString() &#123; return "sets size:" + sets.size() + "| lists size:" + lists.size() + "| maps size:" + maps.size() ; &#125;&#125; com.bjsxt.model.User：12345package com.bjsxt.model;public class User &#123;&#125; com.bjsxt.service.UserService：123456789101112131415161718192021222324package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.User;public class UserService &#123; private UserDAO userDAO; private UserService(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125; /*public UserDAO getUserDAO() &#123; return userDAO; &#125; public void setUserDAO(UserDAO userDAO) &#123; System.out.println("set"); this.userDAO = userDAO; &#125;*/ public void add(User user) &#123; System.out.println(this.userDAO); this.userDAO.save(user); &#125;&#125; beans.xml：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt; &lt;bean name="userDAO" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;property name="sets"&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="lists"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="maps"&gt; &lt;map&gt; &lt;entry key="1" value="1"&gt;&lt;/entry&gt; &lt;entry key="2" value="2"&gt;&lt;/entry&gt; &lt;entry key="3" value="3"&gt;&lt;/entry&gt; &lt;entry key="4" value="4"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.bjsxt.service.UserService"&gt; &lt;!-- &lt;property name="userDAO"&gt; &lt;ref bean="userDAO"/&gt; &lt;/property&gt; --&gt; &lt;constructor-arg&gt; &lt;ref bean="userDAO"/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 最后我们将UserDAO打印出来看看：12345678910111213141516171819com.bjsxt.service.UserServiceTest：package com.bjsxt.service;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.bjsxt.dao.UserDAO;public class UserServiceTest &#123; @Test public void testAdd() throws Exception &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); UserDAO u1 = (UserDAO)ctx.getBean("userDAO"); System.out.println(u1); &#125;&#125; 运行结果： 发现在配置文件中配置的集合值都被成功注入。 第十四课. AutoWire为了区分不同的UserDAOImpl，我们给这个类里面加上id的字段：1234567891011121314151617181920212223242526package com.bjsxt.dao.impl;import com.bjsxt.dao.UserDAO;import com.bjsxt.model.User;public class UserDAOImpl implements UserDAO &#123; private int daoId; @Override public void save(User u) &#123; System.out.println("a user saved!"); &#125; public int getDaoId() &#123; return daoId; &#125; public void setDaoId(int daoId) &#123; this.daoId = daoId; &#125; @Override public String toString()&#123; return "daoId=" + daoId; &#125;&#125; UserService.java：12345678910111213141516171819202122package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;public class UserService &#123; private UserDAO userDAO = new UserDAOImpl(); public void add(User u) &#123; this.userDAO.save(u); &#125; public UserDAO getUserDAO() &#123; return userDAO; &#125; public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125;&#125; beans.xml：1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean name="userDAO" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;property name="daoId" value="1"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name="userDAO2" class="com.bjsxt.dao.impl.UserDAOImpl"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;property name="daoId" value="2"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.bjsxt.service.UserService" scope="prototype" autowire="byName"&gt; &lt;!--&lt;property name="userDAO" ref="userDAO1"/&gt;--&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans&gt; 注意上面的userService这个bean的autowire，里面设置的是byName，那么它就会按照userService类内部属性的名字进行自动装配，因为里面是有UserDAO这个成员变量，就会到配置文件去找相同名字的，找到第一个bean名字是userDAO，那么就把这个设置注入。打印一下，看看id是什么： 12345678910111213141516171819202122package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;//Dependency Injection//Inverse of Controlpublic class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; BeanFactory factory = new ClassPathXmlApplicationContext("beans.xml"); UserService service = (UserService)factory.getBean("userService"); System.out.println(service.getUserDAO()); &#125;&#125; 打印： 成功~ 如果我们将autowire改成byType，会是什么样子？ 发现报错了，因为这一次是按类型来找，找到两个都是叫做UserDAO的，所以重复了。如果删去一个bean就可以了。 第十五课. LifeCyclea) lazy-init（不重要）b) init-method destroy-method不要和prototype一起用（了解） 先说lazy-init，举例： 当Context初始化的时候，这个bean不进行初始化，什么时候用到了这个bean，什么时候初始化。 再说第二个。 先为UserService类中加入初始化和销毁函数：12345678910111213141516171819202122232425262728293031323334package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;public class UserService &#123; public UserService(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125; private UserDAO userDAO = new UserDAOImpl(); public void add(User u) &#123; this.userDAO.save(u); &#125; public UserDAO getUserDAO() &#123; return userDAO; &#125; public void setUserDAO(UserDAO userDAO) &#123; this.userDAO = userDAO; &#125; public void init()&#123; System.out.println("init"); &#125; public void destroy()&#123; System.out.println("destroy"); &#125;&#125; 在beans.xml中进行配置：1&lt;bean id="userService" class="com.bjsxt.service.UserService" init-method="init" destroy-method="destroy"&gt; 我们来写一个测试程序测试一下：123456789101112131415161718192021package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;//Dependency Injection//Inverse of Controlpublic class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); UserService service = (UserService)ctx.getBean("userService"); &#125;&#125; 运行： 如果想要执行bean的destroy方法，该怎么做？12345678910111213141516171819202122package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;//Dependency Injection//Inverse of Controlpublic class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); UserService service = (UserService)ctx.getBean("userService"); ctx.destroy(); &#125;&#125; 运行结果： 如果我们创建两个UserService，会是什么结果？ 代码：1234567891011121314151617181920212223package com.bjsxt.service;import com.bjsxt.dao.UserDAO;import com.bjsxt.dao.impl.UserDAOImpl;import com.bjsxt.model.User;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;//Dependency Injection//Inverse of Controlpublic class UserServiceTest &#123; @Test public void testAdd() throws Exception&#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); UserService service = (UserService)ctx.getBean("userService"); UserService service2 = (UserService)ctx.getBean("userService");// ctx.destroy(); &#125;&#125; 运行： 发现也只执行了一次init，和一次destroy。因为默认是单例模式，所有这两个UserService是同一个对象。 将UserService的scope修改成prototype： 1&lt;bean id="userService" class="com.bjsxt.service.UserService" init-method="init" destroy-method="destroy" scope="prototype"&gt; 再运行： 发现只执行了两次init，那么这里就要提醒一条：init-method destroy-methd 不要和prototype一起用。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2017%2F12%2F27%2FReflection%2F</url>
    <content type="text"><![CDATA[本文主要介绍Java中的反射机制。 第一课. classloader初步及动态加载机制ClassLoader的类加载机制 并非一次性加载需要的时候加载（运行期间动态加载）例子： &nbsp; &nbsp; &nbsp; &nbsp;TestDynamicLoading.java &nbsp; &nbsp; &nbsp; &nbsp;java -verbose:class 可以观察类的具体加载过程static语句块在加载后执行一次dynamic语句块每次new新的对象都会执行 &nbsp; &nbsp; &nbsp; &nbsp;等同于构造方法中的语句 &nbsp; &nbsp; &nbsp; &nbsp;用的比较少 TestDynamicLoading.java:123456789101112131415161718192021222324252627282930public class TestDynamicLoading &#123; public static void main(String[] args) &#123; new A(); System.out.println("**--------------------------**"); new B(); new C(); new C(); new D(); new D(); &#125;&#125;class A&#123;&#125;class B&#123;&#125;class C&#123; static &#123; System.out.println("CCCCCCCCCCCCCCCCCCCCCC"); &#125;&#125;class D&#123; &#123; System.out.println("DDDDDDDDDDDDDDDDDDDDDD"); &#125;&#125; 运行效果： 可以看到，先运行A，再运行B，之后输出一次C，两次D. 第二课. JDK中classloader的分类JDK内置ClassLoader bootstrap class loaderimplemented by native language（由本地语言实现，比如C、C++、汇编等）load the core classes of jdk（加载jdk中最核心的类）举个例子，比如下面的程序，由于String类是最核心的类之一，所以打印它的名字是打不出来的： extension class loaderloader the class from jre/lib/ext(从jre/lib/ext中加载其他类) application class Loaderload user-define classesClassLoader.getSystemClassLoader() other class Loader SecureClassLoader URLClassLoader 我们来看例子： 第三课. JDK中classloader的层次关系 每一个classloader通过parent方法来找上一层的classloader是哪一个，它们之间不是继承的关系。说我们可以通过一个程序来测试： 这一层的classloader是AppClassLoader，然后通过parent找到上一层的引用找到上一层的classLoader，就是ExtClassLoader。 第四课. 反射1 第五课. 反射2我们通过一个代码来讲解什么是反射： TestReflection.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class TestReflection &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; String str = "T"; Class c = Class.forName(str); //把T名字的类装载到内存 Object o = c.newInstance(); Method[] methods = c.getMethods(); for (Method m : methods)&#123;// System.out.println(m.getName()); if(m.getName().equals("mm"))&#123; m.invoke(o); &#125; if(m.getName().equals("m1"))&#123; m.invoke(o, 1,2); for (Class paramType : m.getParameterTypes()) System.out.println(paramType.getName()); &#125; if(m.getName().equals("getS"))&#123; Class returnType = m.getReturnType(); System.out.println(returnType.getName()); &#125; &#125; &#125;&#125;class T&#123; static &#123; System.out.println("T loaded"); &#125; public T()&#123; System.out.println("T constructed!"); &#125; int i; String s; public void m1(int i, int j)&#123; this.i = i + j; System.out.println(this.i); &#125; public void mm()&#123; System.out.println("mm invoked"); &#125; public String getS()&#123; return s; &#125;&#125; 首先定义了一个名字叫T，这个类中一个构造函数，一个静态代码块，还有三个方法。 我们通过反射机制来执行类中的方法：1234String str = "T"; Class c = Class.forName(str); //把T名字的类装载到内存 Object o = c.newInstance(); Method[] methods = c.getMethods(); 这一段中首先通过Class.forName方法，将T这个类装载到内存里，然后通过newInstance方法生成一个T的对象o，再通过c的getMethods()方法得到T中所有方法，装在Method数组里面。 123456789101112131415for (Method m : methods)&#123;// System.out.println(m.getName()); if(m.getName().equals("mm"))&#123; m.invoke(o); &#125; if(m.getName().equals("m1"))&#123; m.invoke(o, 1,2); for (Class paramType : m.getParameterTypes()) System.out.println(paramType.getName()); &#125; if(m.getName().equals("getS"))&#123; Class returnType = m.getReturnType(); System.out.println(returnType.getName()); &#125; &#125; 这一段中遍历Method数组，如果一个数组中的名字等于我们想要的方法名，就通过invoke方法来调用这个方法。invoke方法的参数列表是一个可变数组，就是说根据真实类中的参数表的参数个数来定传几个。如果我们想看方法的返回值是什么类型的，就可以通过getReturnType()方法来得到；而参数类型可以通过getParameterTypes()得到。 第六课. 封装打折策略我们先设计一个简易订单系统，里面有三个属性productName、count、unitPrice，代表商品名，总数，单价，并生成它们的get和set方法。然后我们设计一个方法叫getTotalPrice，可以计算所有商品的总价：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Order &#123; private String productName = null; private int count = 0; private int unitPrice = 0; private double discount = 1.0; public String getProductName() &#123; return productName; &#125; public void setProductName(String productName) &#123; this.productName = productName; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public int getUnitPrice() &#123; return unitPrice; &#125; public void setUnitPrice(int unitPrice) &#123; this.unitPrice = unitPrice; &#125; public int getTotalPrice()&#123; return count * unitPrice; &#125; @Override public String toString()&#123; return productName + "-" + getTotalPrice(); &#125; public static void main(String[] args) &#123; Order o = new Order(); o.setProductName("apple"); o.setCount(10); o.setUnitPrice(2); System.out.println(o); &#125;&#125; 现在我们的需求是，设计一种打折策略，可以随时调整，根据不同的情况。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（八） Observer]]></title>
    <url>%2F2017%2F12%2F26%2FDesignPattern8%2F</url>
    <content type="text"><![CDATA[本文主要介绍观察者模式。 第一课. 提出问题-1OOA&amp;OOD：面向对象的分析与设计 问题：请模拟以下情景： 小孩在睡觉 醒来后要求吃东西 第二课. 提出问题-2什么叫分析？确定我们的系统实现什么样的功能。 什么叫设计？设计是说实现这样的功能到底通过什么样的方式。 第三课. 第一种设计方法我们第一次来实现父亲看孩子这一场景。我们的想法是，孩子设计为一个线程，父亲设计为一个线程，孩子五秒以后开始哭，要求吃东西，父亲作为监护者，需要一直轮询。一旦孩子开始哭，父亲就会检测到，然后开始喂东西。 实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Child implements Runnable&#123; boolean wakeup = false; public boolean isWakeup() &#123; return wakeup; &#125; public void setWakeup(boolean wakeup) &#123; this.wakeup = wakeup; &#125; void wakeUp()&#123; wakeup = true; &#125; @Override public void run() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.wakeUp(); &#125;&#125;class Dad implements Runnable&#123; Child c; public Dad(Child c)&#123; this.c = c; &#125; public void run()&#123; while(!c.isWakeup())&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; feed(c); &#125; private void feed(Child c) &#123; System.out.println("feed child"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Child d = new Child(); new Thread(d).start(); new Thread(new Dad(d)).start(); &#125;&#125; 第四课. 第二种设计方法之前我们让父亲一直盯着孩子看，这对于资源是一种及其的浪费，想一想，如果父亲还有其他事情要做，比方做饭，比方看电视，由于要盯着孩子，所以什么事情都做不了。那么最好是让孩子来通知父亲，一旦孩子醒了，就告诉父亲一下，父亲就来照顾孩子。 具体实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Child implements Runnable&#123; private Dad d; boolean wakeup = false; public Child(Dad d)&#123; this.d = d; &#125; public boolean isWakeup() &#123; return wakeup; &#125; public void setWakeup(boolean wakeup) &#123; this.wakeup = wakeup; &#125; void wakeUp()&#123; wakeup = true; d.feed(this); &#125; @Override public void run() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.wakeUp(); &#125;&#125;class Dad &#123; public void feed(Child c) &#123; System.out.println("feed child"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Dad d = new Dad(); Child c = new Child(d); new Thread(c).start(); &#125;&#125; 第五课. 对于事件的处理上一种设计方式是在Child中对其父亲加入一种检测机制，这一次我们再将醒来这一事件分离出来，一旦孩子醒来，我们就讲孩子所有的信息，包括醒来的时间、所在地方，对象等具体信息都返回给父亲。而且我们不光要返回给父亲，爷爷、叔叔等也可以被孩子通知： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class WakeUpEvent&#123; private long time; private String loc; private Child source; public WakeUpEvent(long time, String loc, Child source) &#123; this.time = time; this.loc = loc; this.source = source; &#125; public long getTime() &#123; return time; &#125; public void setTime(long time) &#123; this.time = time; &#125; public String getLoc() &#123; return loc; &#125; public void setLoc(String loc) &#123; this.loc = loc; &#125; public Child getSource() &#123; return source; &#125; public void setSource(Child source) &#123; this.source = source; &#125;&#125;class Child implements Runnable&#123; private Dad d; private GrandFather gf; public Child(Dad d)&#123; this.d = d; &#125; void wakeUp()&#123; d.ActionToWakenUp(new WakeUpEvent(System.currentTimeMillis(), "bed", this)); &#125; @Override public void run() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.wakeUp(); &#125;&#125;class Dad &#123; public void ActionToWakenUp(WakeUpEvent wakeUpEvent) &#123; System.out.println("feed child"); &#125;&#125;class GrandFather &#123; public void ActionToWakenUp(WakeUpEvent wakeUpEvent) &#123; System.out.println("hug child"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Dad d = new Dad(); Child c = new Child(d); new Thread(c).start(); &#125;&#125; 第六课. 第三种设计方法-Observer上面的例子是有弊端的。父亲要看孩子，Child内部就得保存一个父亲的对象；爷爷要看孩子，Child内部就得保存一个爷爷的对象。所以这很不利于程序的扩展。那么比较好的模式是什么？ 最好是把孩子醒来这一事件做一个监听器，父亲也好，爷爷也好，都继承这个监听器就可以。孩子内部保存一个监听器列表，如果有一个新角色来监听，就往列表中加一个监听器对象，这个对象可以是爷爷，可以是爸爸，甚至是一条狗。这样程序就更加利于扩展： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.util.ArrayList;import java.util.List;class WakeUpEvent&#123; private long time; private String loc; private Child source; public WakeUpEvent(long time, String loc, Child source) &#123; this.time = time; this.loc = loc; this.source = source; &#125; public long getTime() &#123; return time; &#125; public void setTime(long time) &#123; this.time = time; &#125; public String getLoc() &#123; return loc; &#125; public void setLoc(String loc) &#123; this.loc = loc; &#125; public Child getSource() &#123; return source; &#125; public void setSource(Child source) &#123; this.source = source; &#125;&#125;class Child implements Runnable&#123; private List&lt;WakenUpListener&gt; wakenUpListeners = new ArrayList&lt;WakenUpListener&gt;(); public void addWakenUpListener(WakenUpListener l)&#123; wakenUpListeners.add(l); &#125; void wakeUp() &#123; for (int i = 0; i &lt; wakenUpListeners.size(); i++)&#123; WakenUpListener l = wakenUpListeners.get(i); l.ActionToWakenUp(new WakeUpEvent(System.currentTimeMillis(), "bed", this)); &#125; &#125; @Override public void run() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.wakeUp(); &#125;&#125;class Dad implements WakenUpListener &#123; public void ActionToWakenUp(WakeUpEvent wakeUpEvent) &#123; System.out.println("feed child"); &#125;&#125;class GrandFather implements WakenUpListener&#123; public void ActionToWakenUp(WakeUpEvent wakeUpEvent) &#123; System.out.println("hug child"); &#125;&#125;class Dog implements WakenUpListener&#123; @Override public void ActionToWakenUp(WakeUpEvent wakeUpEvent) &#123; System.out.println("wang wang..."); &#125;&#125;interface WakenUpListener &#123; public void ActionToWakenUp(WakeUpEvent wakeUpEvent);&#125;public class Test &#123; public static void main(String[] args) &#123; Dad d = new Dad(); GrandFather gf = new GrandFather(); Child c = new Child(); c.addWakenUpListener(d); c.addWakenUpListener(gf); c.addWakenUpListener(new Dog()); new Thread(c).start(); &#125;&#125; 第七课. 用属性文件管理Observers上一节中我们需要哪些监听器需要到Child类中进行注册，这一节中，我们试着把需要用到的监听器放到配置文件里：com/bjsxt/dp/observer/observer.properties：observers=com.bjsxt.dp.observer.Dad,com.bjsxt.dp.observer.GrandFather,com.bjsxt.dp.observer.Dog Test代码：123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args)&#123; Child c = new Child(); Properties props = new Properties(); try &#123; props.load(Test.class.getClassLoader().getResourceAsStream("com/bjsxt/dp/observer/observer.properties")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String[] observers = props.getProperty("observers").split(","); for (String s : observers)&#123; try &#123; c.addWakenUpListener((WakenUpListener) Class.forName(s).newInstance()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; new Thread(c).start(); &#125;&#125; 这样就把需要的被通知者放在了配置文件中，需要的时候拿出来就可以了。 第八课. 单例初步及缓存上一节中我们使用Properties来读取配置文件，但是是写在Test文件，里面，这一次我们想将其分离出来，而且我们使用单例模式，使得资源只加载一次即可：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.bjsxt.dp.observer;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.Properties;class WakeUpEvent&#123; private long time; private String loc; private Child source; public WakeUpEvent(long time, String loc, Child source) &#123; this.time = time; this.loc = loc; this.source = source; &#125; public long getTime() &#123; return time; &#125; public void setTime(long time) &#123; this.time = time; &#125; public String getLoc() &#123; return loc; &#125; public void setLoc(String loc) &#123; this.loc = loc; &#125; public Child getSource() &#123; return source; &#125; public void setSource(Child source) &#123; this.source = source; &#125;&#125;class Child implements Runnable&#123; private List&lt;WakenUpListener&gt; wakenUpListeners = new ArrayList&lt;WakenUpListener&gt;(); public void addWakenUpListener(WakenUpListener l)&#123; wakenUpListeners.add(l); &#125; void wakeUp() &#123; for (int i = 0; i &lt; wakenUpListeners.size(); i++)&#123; WakenUpListener l = wakenUpListeners.get(i); l.ActionToWakenUp(new WakeUpEvent(System.currentTimeMillis(), "bed", this)); &#125; &#125; @Override public void run() &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.wakeUp(); &#125;&#125;class Dad implements WakenUpListener &#123; public void ActionToWakenUp(WakeUpEvent wakeUpEvent) &#123; System.out.println("feed child"); &#125;&#125;class GrandFather implements WakenUpListener&#123; public void ActionToWakenUp(WakeUpEvent wakeUpEvent) &#123; System.out.println("hug child"); &#125;&#125;class Dog implements WakenUpListener&#123; @Override public void ActionToWakenUp(WakeUpEvent wakeUpEvent) &#123; System.out.println("wang wang..."); &#125;&#125;interface WakenUpListener &#123; public void ActionToWakenUp(WakeUpEvent wakeUpEvent);&#125;public class Test &#123; public static void main(String[] args)&#123; Child c = new Child(); String[] observers =PropertyMgr.getProperty("observers").split(","); for (String s : observers)&#123; try &#123; c.addWakenUpListener((WakenUpListener) Class.forName(s).newInstance()); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; new Thread(c).start(); &#125;&#125;class PropertyMgr &#123; private static Properties props = new Properties(); static &#123; try &#123; props.load(Test.class.getClassLoader().getResourceAsStream("com/bjsxt/dp/observer/observer.properties")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static String getProperty(String key)&#123; return props.getProperty(key); &#125;&#125; 第九课. 模拟AWT事件处理先看一下AWT的事件处理：1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.bjsxt.dp.observer.awt;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;public class TestFrame extends Frame &#123; public void launch() &#123; Button b = new Button("press me"); b.addActionListener(new MyActionListener()); b.addActionListener(new MyActionListener2()); this.add(b); this.pack(); this.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; System.exit(0); &#125; &#125;); this.setVisible(true); &#125; public static void main(String[] args) &#123; new TestFrame().launch(); &#125; private class MyActionListener implements ActionListener&#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("button pressed"); &#125; &#125; private class MyActionListener2 implements ActionListener&#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("button pressed 2"); &#125; &#125;&#125; 我们发现，这就是一个观察者模式，我们来模拟一下AWT的运行过程，就是创建一个Button类，里面保存着一个列表来存储ActionListener监听器，可以向里面添加监听器。一旦我们按下按钮，就依次通知所有监听器，并生成事件，执行事件。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.bjsxt.dp.observer.awt;import java.util.ArrayList;import java.util.List;public class Test &#123; public static void main(String[] args) &#123; Button b = new Button(); b.addActionListener(new MyActionListener()); b.addActionListener(new MyActionListener2()); b.buttonPressed(); &#125;&#125;class Button&#123; private List&lt;ActionListener&gt; actionListeners = new ArrayList&lt;ActionListener&gt;(); public void buttonPressed()&#123; ActionEvent e = new ActionEvent(System.currentTimeMillis(), this); for (int i = 0; i &lt; actionListeners.size(); i++)&#123; ActionListener l = actionListeners.get(i); l.actionPerformed(e); &#125; &#125; public void addActionListener(ActionListener l)&#123; actionListeners.add(l); &#125;&#125;interface ActionListener &#123; public void actionPerformed(ActionEvent e);&#125;class MyActionListener implements ActionListener&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println("button pressed"); &#125;&#125;class MyActionListener2 implements ActionListener&#123; public void actionPerformed(ActionEvent e) &#123; System.out.println("button pressed 2"); &#125;&#125;class ActionEvent &#123; long when; Object source; public Object getSource() &#123; return source; &#125; public ActionEvent(long when, Object source) &#123; this.when = when; this.source = source; &#125; public long getWhen() &#123; return when; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（七） 追美眉的技术]]></title>
    <url>%2F2017%2F12%2F26%2FDesignPattern7%2F</url>
    <content type="text"><![CDATA[本文主要介绍桥接模式、适配器模式、状态模式、命令模式和中介者模式。 第一课Bridge模式（桥接模式）： 我们来设想一个场景，就是一个男生要去追求一个MM，那么就需要一个男生的类和一个MM的类，男生想要追MM，就得有一个追MM的方法。这个方法我们定义为送礼物，既然要送礼物，就得有礼物的类。礼物分为两种：追狂野的MM就得用狂野的礼物；追温柔的MM就得送温柔的礼物。 所以这里我们用到了桥接模式来设计：Gift.java：12345package com.bjsxt.dp.bridge;public class Gift &#123; GiftImpl impl;&#125; Gift类里面包括一个GiftImpl，也就是聚合。 GiftImpl.java：1234package com.bjsxt.dp.bridge;public class GiftImpl &#123;&#125; 两类礼物：12345678910111213141516package com.bjsxt.dp.bridge;public class WarmGift extends Gift &#123; public WarmGift(GiftImpl impl) &#123; this.impl = impl; &#125;&#125;package com.bjsxt.dp.bridge;public class WildGift extends Gift &#123; public WildGift(GiftImpl impl)&#123; this.impl = impl; &#125;&#125; 具体的礼物都直接去继承GiftImpl：123456789package com.bjsxt.dp.bridge;public class Flower extends GiftImpl &#123;&#125;package com.bjsxt.dp.bridge;public class Ring extends GiftImpl &#123;&#125; MM类：12345678910111213package com.bjsxt.dp.bridge;public class MM &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Boy类：1234567891011121314151617181920212223package com.bjsxt.dp.bridge;public class Boy &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void pursue(MM mm)&#123;// Gift g = new WarmGift(new Flower()); Gift g = new WildGift(new Ring()); give(g, mm); &#125; public void give(Gift g, MM mm)&#123; &#125;&#125; 这就是Bridge模式，用图形来表示就是： 用一句话总结桥接模式就是：两个维度，排列组合。 第四课Adapter(适配器)模式： 经典面试题：java.io的设计模式 InputStreamReader：Adapter模式（把一个InputStream转成Reader） 第五课Command模式：设想场景：MM可以命令男生去做任何事情，包括陪购物，包括拥抱等等，当然也可以撤回一个命令。 先来设计Command抽象类：123456package com.bjsxt.dp.bridge;public abstract class Command &#123; public abstract void execute(); public abstract void unDo();&#125; 设计两个命令来继承这个抽象类：ShoppingCommand.java：12345678910111213package com.bjsxt.dp.bridge;public class ShoppingCommand extends Command&#123; @Override public void execute() &#123; System.out.println("zoo"); &#125; @Override public void unDo() &#123; System.out.println("undo zoo"); &#125;&#125; HugCommand.java：12345678910111213package com.bjsxt.dp.bridge;public class HugCommand extends Command&#123; @Override public void execute() &#123; System.out.println("hug"); &#125; @Override public void unDo() &#123; System.out.println("open your arms"); &#125;&#125; 设计Boy类，用一个数组来存储一系列的命令：12345678910111213141516171819202122232425262728293031323334package com.bjsxt.dp.bridge;import java.util.ArrayList;import java.util.List;public class Boy &#123; private String name; private List&lt;Command&gt; commands = new ArrayList&lt;Command&gt;(); public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void addCommand(Command c1)&#123; this.commands.add(c1); &#125; public void executeCommands() &#123; for (Command c : commands)&#123; c.execute(); &#125; &#125; public void undoCommands()&#123; for (Command c : commands)&#123; c.unDo(); &#125; &#125;&#125; MM可以来通过向男生容器中添加命令来执行一系列命令（当然也可以撤回）：123456789101112131415161718192021package com.bjsxt.dp.bridge;public class MM &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void order(Boy b)&#123; Command c1 = new ShoppingCommand(); b.addCommand(c1); Command c2 = new HugCommand(); b.addCommand(c2); b.executeCommands(); &#125;&#125; 其实存储命令的容器一般采用栈的方式来实现，就是后加入的命令先被撤回。 第七课State模式 设想场景，MM会哭，会笑，会说，但是这三种能力在不同状态下表示不一样。比方在开心的时候哭起来和在不开心的时候哭起来就不同。 我们创建一个MM的状态抽象类：1234567package com.bjsxt.dp.bridge;public abstract class MMState &#123; public abstract void smile(); public abstract void cry(); public abstract void say();&#125; 然后从这个类这里继承实现两个不一样的状态，一个开心的状态和一个不开心的状态：1234567891011121314151617181920212223242526272829303132333435363738package com.bjsxt.dp.bridge;public class MMHappyState extends MMState &#123; @Override public void smile() &#123; &#125; @Override public void cry() &#123; &#125; @Override public void say() &#123; &#125;&#125;package com.bjsxt.dp.bridge;public class MMUnHappyState extends MMState &#123; @Override public void smile() &#123; &#125; @Override public void cry() &#123; &#125; @Override public void say() &#123; &#125;&#125; MM类内部存储着一个状态，然后可以根据状态不同来决定自己最后行为执行情况的不同：123456789101112131415161718192021222324252627package com.bjsxt.dp.bridge;public class MM &#123; private String name; private MMState state = new MMHappyState(); public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void smile()&#123; state.smile(); &#125; public void cry()&#123; state.cry(); &#125; public void say()&#123; state.say(); &#125;&#125; 第八课Mediator模式： 设想场景：MM有很多亲戚，他们都对MM有很多要求，而且亲戚之间也有很多关联。这时候我们设计一个中介者的角色，来对它们之间的关系进行调停，这就是中介者模式。 从网上找的一个例子：]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（六） 工厂系列]]></title>
    <url>%2F2017%2F12%2F26%2FDesignPattern6%2F</url>
    <content type="text"><![CDATA[本文主要介绍静态工厂、简单工厂、抽象工厂和spring的bean工厂，另外还简单介绍了单例模式、多例模式。 第一课我们先来实现一个需求，就是只给司机一辆车，不能多给。 为了实现这样的功能，我们这么设计我们的Car类：12345678910111213141516package com.bjsxt.dp.factory;public class Car &#123; private static Car car = new Car(); private Car()&#123;&#125; public static Car getInstance()&#123; return car; &#125; public void run()&#123; System.out.println("冒着烟奔跑中car......"); &#125;&#125; 这样就不能由用户来自己new一个Car，而是将Car的构造函数设置为private，然后在内部创建一个private的静态Car对象，这个就是单例模式，然后我们设置一个getInstance方法，来获取这唯一的Car对象，这个就是静态工厂模式。 写一个测试代码来验证一下它的唯一性：12345678910package com.bjsxt.dp.factory;public class Test &#123; public static void main(String[] args) &#123; Car c = Car.getInstance(); Car c2 = Car.getInstance(); if (c == c2) System.out.println("same car"); c.run(); &#125;&#125; 运行： OK。上面提及的两种模式，一种叫做单例模式，另外一个叫做静态工厂模式。 其实还有一种多例模式，就是设置一组容器来存储不同的Car：12345678910111213141516public class Car &#123; private static Car car = new Car(); private static List&lt;Car&gt; cars = new ArrayList&lt;Car&gt;(); private Car()&#123;&#125; public static Car getInstance()&#123; return car; &#125; public void run()&#123; System.out.println("冒着烟奔跑中car......"); &#125;&#125; 这第一个需求我们已经实现，现在我们来实现第二个需求：任意定制交通工具的类型和生产过程。 这其实也算两个需求，我们先来实现任意定制交通工具的类型：之前我们实现了一个Car的类，现在我们想不光开汽车，飞机也能开，这样，我们为了多态，要去实现一个接口，我们起名叫做Movable：12345package com.bjsxt.dp.factory;public interface Movable &#123; void run();&#125; 让Car来实现这个接口：public class Car implements Movable{ 然后我们实现一个Plane类，也来实现这个接口：12345678package com.bjsxt.dp.factory;public class Plane implements Movable &#123; @Override public void run() &#123; System.out.println("扇着翅膀前进中plane......."); &#125;&#125; 好的，到目前为止，我们在测试类中就可以随意指定我们的交通工具了：123456789package com.bjsxt.dp.factory;public class Test &#123; public static void main(String[] args) &#123; Movable m = new Plane(); m.run(); &#125;&#125; 接下来，我们还想任意指定生产过程，不过这个不能着急，得一步步来。 我们先去设计一个飞机的生产过程出来：1234567package com.bjsxt.dp.factory;public class PlaneFactory &#123; public Plane createPlane()&#123; return new Plane(); &#125;&#125; 生产：12345678910package com.bjsxt.dp.factory;public class Test &#123; public static void main(String[] args) &#123; PlaneFactory factory = new PlaneFactory(); Movable m = factory.createPlane(); m.run(); &#125;&#125; 这样是没问题的。但是如果想生产一个Car呢？我们最朴素的想法是模仿PlaneFactory，写一个CarFactory：1234567package com.bjsxt.dp.factory;public class CarFactory &#123; public Car createCar()&#123; return new Car(); &#125;&#125; 上面需要注意的是，得把Car的构造函数设置为public，因为工厂模式和单例有冲突。 但是这样的话，整个测试用例代码也需要整体修改，很麻烦。 我们决定重新设计这个过程。 先设计一个VehicleFactory的抽象类：12345package com.bjsxt.dp.factory;public abstract class VehicleFactory &#123; abstract Movable create();&#125; 然后我们去继承这个抽象类，实现两个工厂类：PlaneFactory.java：12345678package com.bjsxt.dp.factory;public class PlaneFactory extends VehicleFactory&#123; @Override Movable create() &#123; return new Plane(); &#125;&#125; CarFactory.java：12345678package com.bjsxt.dp.factory;public class CarFactory extends VehicleFactory&#123; @Override Movable create() &#123; return new Car(); &#125;&#125; 这时测试类就可以这么写：123456789public class Test &#123; public static void main(String[] args) &#123; VehicleFactory factory = new CarFactory(); Movable m = factory.create(); m.run(); &#125;&#125; 如果需要换其他的类的生产方式，只需要换成VehicleFactory factory = new XXXFactory(); 我们将这个整体过程用图示来表示出来： 创建一个新的类，就需要创建一个对应的工厂，并且继承自VehicleFactory抽象类。这个就叫做简单工厂模式 第二课这一节我们介绍抽象工厂 设计一个抽象工厂，它是一个抽象类，可以生产交通工具，可以生产武器，还可以生产食物：1234567package com.bjsxt.dp.factory.abstractfactory;public abstract class AbstractFactory &#123; public abstract Vehicle createVehicle(); public abstract Weapon createWeapon(); public abstract Food createFood();&#125; 我们来定义这三种类，其实它们也都是抽象类：Vehicle.java：12345package com.bjsxt.dp.factory.abstractfactory;public abstract class Vehicle &#123; public abstract void run();&#125; Weapon.java：12345package com.bjsxt.dp.factory.abstractfactory;public abstract class Weapon &#123; public abstract void shoot();&#125; Food.java：12345package com.bjsxt.dp.factory.abstractfactory;public abstract class Food &#123; public abstract void printName();&#125; 我们来实现两个Vehicle的具体类，两个Weapon的具体类，两个Food的具体类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.bjsxt.dp.factory.abstractfactory;public class Broom extends Vehicle&#123; public void run() &#123; System.out.println("一路沙尘暴飞奔而来broom......"); &#125;&#125;package com.bjsxt.dp.factory.abstractfactory;public class Car extends Vehicle&#123; public void run()&#123; System.out.println("冒着烟奔跑中car......"); &#125;&#125;package com.bjsxt.dp.factory.abstractfactory;public class MagicStick extends Weapon&#123; @Override public void shoot() &#123; System.out.println("fire ho ho ho...."); &#125;&#125;package com.bjsxt.dp.factory.abstractfactory;public class AK47 extends Weapon&#123; public void shoot()&#123; System.out.println("哒哒哒..."); &#125;&#125;package com.bjsxt.dp.factory.abstractfactory;public class Apple extends Food&#123; public void printName()&#123; System.out.println("apple"); &#125;&#125;package com.bjsxt.dp.factory.abstractfactory;public class MushRoom extends Food&#123; @Override public void printName() &#123; System.out.println("mushroom"); &#125;&#125; 接下来我们从抽象工厂上继承实现两个工厂类，它们分别用相同的标准实现不同的一套物件：DefaultFactory.java：12345678910111213141516171819package com.bjsxt.dp.factory.abstractfactory;public class DefaltFactory extends AbstractFactory&#123; @Override public Vehicle createVehicle() &#123; return new Car(); &#125; @Override public Weapon createWeapon() &#123; return new AK47(); &#125; @Override public Food createFood() &#123; return new Apple(); &#125;&#125; MagicFactory.java：12345678910111213141516171819package com.bjsxt.dp.factory.abstractfactory;public class MagicFactory extends AbstractFactory&#123; @Override public Vehicle createVehicle() &#123; return new Broom(); &#125; @Override public Weapon createWeapon() &#123; return new MagicStick(); &#125; @Override public Food createFood() &#123; return new MushRoom(); &#125;&#125; 编写测试代码：12345678910111213141516package com.bjsxt.dp.factory.abstractfactory;public class Test &#123; public static void main(String[] args) &#123; AbstractFactory f = new DefaltFactory(); Vehicle v = f.createVehicle(); v.run(); Weapon w = f.createWeapon(); w.shoot(); Food a = f.createFood(); a.printName(); &#125;&#125; 如果我们不想使用DefaultFactory的产品，就直接将工厂名换了即可：AbstractFactory f = new MagicFactory(); 将抽象工厂的整体过程画出来就是： 第三课对于简单工厂，我们能控制产品的扩展，但是如果产品多了以后，要产生产品系列的时候，容易产生工厂泛滥的情况。但是抽象工厂模式，不会产生工厂泛滥的情况，但是产品不容易扩展。 我们这一次介绍一下Spring的bean工厂。 先创建一个Movable的接口：12345package com.bjsxt.spring.factory;public interface Movable &#123; void run();&#125; 然后从这个接口上实现两个类：Car.java：123456789101112package com.bjsxt.spring.factory;import java.util.ArrayList;import java.util.List;public class Car implements Movable &#123; @Override public void run()&#123; System.out.println("冒着烟奔跑中car......"); &#125;&#125; Train.java：12345678package com.bjsxt.spring.factory;public class Train implements Movable &#123; @Override public void run() &#123; System.out.println("小火车呜呜呜呜呜"); &#125;&#125; 这一次我们写一个配置文件，需要用什么交通工具直接在配置文件上写好：spring.properties：VehicleType=com.bjsxt.spring.factory.Car 写一个测试文件：1234567891011121314151617package com.bjsxt.spring.factory;import java.io.IOException;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws Exception &#123; Properties props = new Properties(); props.load(Test.class.getClassLoader(). getResourceAsStream("com/bjsxt/spring/factory/spring.properties")); String vehicleTypeName = props.getProperty("VehicleType"); System.out.println(vehicleTypeName); Object o = Class.forName(vehicleTypeName).newInstance(); Movable m = (Movable)o; m.run(); &#125;&#125; 这一次我们就可以使用Car这样的交通工具了。如果需要换交通工具，只需要改配置文件，不需要再去修改Test代码。 第四课这一节我们入门一下spring，下载好spring的包并解压到电脑一个具体的位置： 创建一个project叫做Spring，加入我们需要的支持spring的jar包： 另外还需要加入一个日志的jar包： 把上一个项目的一些类复制过来：Movable.java：12345package com.bjsxt.spring.factory;public interface Movable &#123; void run();&#125; Car.java：123456789package com.bjsxt.spring.factory;public class Car implements Movable &#123; @Override public void run()&#123; System.out.println("冒着烟奔跑中car......"); &#125;&#125; Train.java：12345678package com.bjsxt.spring.factory;public class Train implements Movable &#123; @Override public void run() &#123; System.out.println("小火车呜呜呜呜呜"); &#125;&#125; 参考spring的文档，创建一个applicationContext.xml的配置文件：123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="v" class="com.bjsxt.spring.factory.Car"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;/beans&gt; 这样就相当于和上一个项目达到相同的效果。然后修改Test代码：123456789101112131415package com.bjsxt.spring.factory;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws Exception &#123; BeanFactory f = new ClassPathXmlApplicationContext("applicationContext.xml"); Object o = f.getBean("v"); Movable m = (Movable)o; m.run(); &#125;&#125; 先通过配置文件拿到工厂，然后通过工厂获取交通工具，这种编程方式叫IOC，也就是面向切面编程，或者叫面向抽象编程，我们因为具体的实现全在配置文件里。 Spring我们已经有了一个基本的认识，下面我们来模拟Spring。 还是回到最初我们的Factory项目，将在Spring的配置文件拷贝过来（applicationContext.xml）：12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans&gt; &lt;bean id="v" class="com.bjsxt.spring.factory.Car"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;/beans&gt; 如何从这个xml文档中读取信息呢？这个可以到网上进行搜索： 发现有四种解析xml的方式，这里我们采用jdom的方式来处理xml。关于jdom，ibm写过一篇教程：https://www.ibm.com/developerworks/cn/xml/x-jdom/index.html直接参考这个文档学习即可。 下面我们直接下载jdom的压缩包进行解压： 然后创建一个名字叫JDOM的project，在project里面加入需要的jar包： 再引入另外一个需要的jar包： 在ibm的介绍文档中有一个小例子： 我们就把这个例子复制到我们的工程里面并进行修改：123456789101112131415161718192021222324252627282930import java.util.*;import org.jdom.*;import org.jdom.input.SAXBuilder;import org.jdom.xpath.XPath;public class Sample2 &#123; public static void main(String[] args) throws Exception &#123; SAXBuilder sb = new SAXBuilder(); Document doc = sb.build(Sample2.class.getClassLoader().getResourceAsStream("sample.xml")); Element root = doc.getRootElement(); System.out.println(root); List list = XPath.selectNodes(root, "/HD/disk"); System.out.println(list.size()); for (int i = 0; i &lt; list.size(); i++) &#123; Element disk_element = (Element) list.get(i); String name = disk_element.getAttributeValue("name"); String capacity = ( (Text) XPath.selectSingleNode(disk_element, "//disk[@name='" + name + "']/capacity/text()")).getTextNormalize(); String directories = ( (Text) XPath.selectSingleNode(disk_element, "//disk[@name='" + name + "']/directories/text()")).getTextNormalize(); String files = ( (Text) XPath.selectSingleNode(disk_element, "//disk[@name='" + name + "']/files/text()")).getTextNormalize(); System.out.println("磁盘信息:"); System.out.println("分区盘符:" + name); System.out.println("分区容量:" + capacity); System.out.println("目录数:" + directories); System.out.println("文件数:" + files); System.out.println("-----------------------------------"); &#125; &#125;&#125; 然后我们把例子里面给出的sample.xml也复制过来：12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;HD&gt; &lt;disk name="C"&gt; &lt;capacity&gt;8G&lt;/capacity&gt; &lt;directories&gt;200&lt;/directories&gt; &lt;files&gt;1580&lt;/files&gt; &lt;/disk&gt; &lt;disk name="D"&gt; &lt;capacity&gt;10G&lt;/capacity&gt; &lt;directories&gt;500&lt;/directories&gt; &lt;files&gt;3000&lt;/files&gt; &lt;/disk&gt;&lt;/HD&gt; 运行： 发现java程序是可以解析xml文件并取到其中的元素的。 那我们就可以在我们模拟Spring的项目中使用这样的技术来解析xml文件中的元素。 先创建一个BeanFactory，就是bean工厂：12345package com.bjsxt.spring.factory;public interface BeanFactory &#123; Object getBean(String id);&#125; 再实现这个接口，设计一个ClassPathXmlApplicationContext类，内容在上面Sample2的基础上进行修改：123456789101112131415161718192021222324252627282930313233package com.bjsxt.spring.factory;import org.jdom.Document;import org.jdom.Element;import org.jdom.Text;import org.jdom.input.SAXBuilder;import org.jdom.xpath.XPath;import java.util.List;public class ClassPathXmlApplicationContext implements BeanFactory &#123; public ClassPathXmlApplicationContext(String fileName) throws Exception&#123; SAXBuilder sb = new SAXBuilder(); Document doc = sb.build(this.getClass().getClassLoader().getResourceAsStream(fileName)); Element root = doc.getRootElement(); List list = XPath.selectNodes(root, "/beans/bean"); System.out.println(list.size()); for (int i = 0; i &lt; list.size(); i++) &#123; Element bean = (Element) list.get(i); String id = bean.getAttributeValue("id"); String clazz = bean.getAttributeValue("class"); System.out.println(id + " " + clazz); &#125; &#125; @Override public Object getBean(String id) &#123; return null; &#125;&#125; 写一段测试代码：12345678910package com.bjsxt.spring.factory;import java.io.IOException;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws Exception &#123; BeanFactory f = new ClassPathXmlApplicationContext("com/bjsxt/spring/factory/applicationContext.xml"); &#125;&#125; 运行发现，可以取到我们的applicationContext.xml中bean节点的数量和bean的具体信息： 下面我们就顺着这个思路，完善ClassPathXmlApplicationContext代码，增加一个Map来存储bean的id和对应的对象：1234567891011121314151617181920212223242526272829303132333435363738package com.bjsxt.spring.factory;import org.jdom.Document;import org.jdom.Element;import org.jdom.Text;import org.jdom.input.SAXBuilder;import org.jdom.xpath.XPath;import java.util.HashMap;import java.util.List;import java.util.Map;public class ClassPathXmlApplicationContext implements BeanFactory &#123; private Map&lt;String, Object&gt; container = new HashMap&lt;String, Object&gt;(); public ClassPathXmlApplicationContext(String fileName) throws Exception&#123; SAXBuilder sb = new SAXBuilder(); Document doc = sb.build(this.getClass().getClassLoader().getResourceAsStream(fileName)); Element root = doc.getRootElement(); List list = XPath.selectNodes(root, "/beans/bean"); System.out.println(list.size()); for (int i = 0; i &lt; list.size(); i++) &#123; Element bean = (Element) list.get(i); String id = bean.getAttributeValue("id"); String clazz = bean.getAttributeValue("class"); Object o = Class.forName(clazz).newInstance(); container.put(id, o); System.out.println(id + " " + clazz); &#125; &#125; @Override public Object getBean(String id) &#123; return container.get(id); &#125;&#125; 通过getBean方法，我们就可以用id号来找到我们想要的Object对象。 我们通过测试代码来创建我们想要的交通工具：1234567891011121314package com.bjsxt.spring.factory;import java.io.IOException;import java.util.Properties;public class Test &#123; public static void main(String[] args) throws Exception &#123; BeanFactory f = new ClassPathXmlApplicationContext("com/bjsxt/spring/factory/applicationContext.xml"); Object o = f.getBean("v"); Movable m = (Movable)o; m.run(); &#125;&#125; 运行： OK了！如此看来，Spring就是一个容器，里面存储着我们想要的对象，我们需要时候可以直接帮我们生成。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（五） 动态代理]]></title>
    <url>%2F2017%2F12%2F26%2FDesignPattern5%2F</url>
    <content type="text"><![CDATA[本文主要介绍动态代理模式。 第一课写一个Movable接口：12345package com.bjsxt.proxy;public interface Movable &#123; void move();&#125; 写一个类Tank来实现这个接口：123456789101112131415import com.bjsxt.proxy.Movable;import java.util.Random;public class Tank implements Movable &#123; @Override public void move() &#123; System.out.println("Tank Moving...."); try &#123; Thread.sleep(new Random().nextInt(10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这个类实现了Movable接口中的move方法，在里面打印了一行话，而且让线程睡眠了10s。 现在我们想记录一下这个类的move方法运行的时间，该怎么实现呢？第一种方法是在Tank类中的move方法上加时间戳，然后计算出运行时间。第二种方法是继承这个类，然后在调用Tank类的move方法，在方法前后记录时间，做差就可以得出运行时间：1234567891011package com.bjsxt.proxy;public class Tank2 extends Tank &#123; @Override public void move() &#123; long start = System.currentTimeMillis(); super.move(); long end = System.currentTimeMillis(); System.out.println("time:" + (end - start)); &#125;&#125; 还有一种，就是采用聚合的思想，实现一个Movable接口，在类中加入Tank类的一个成员变量，在自己的move方法中加入对Tank对象的时间计算： 123456789101112131415161718package com.bjsxt.proxy;public class TankTimeProxy implements Movable&#123; Movable t; public TankTimeProxy(Movable t) &#123; this.t = t; &#125; @Override public void move()&#123; long start = System.currentTimeMillis(); System.out.println("starttime:" + start); t.move(); long end = System.currentTimeMillis(); System.out.println("time:" + (end - start)); &#125;&#125; 如果我们还想实现对Tank的日志记录，那么和上面的方法一样：12345678910111213141516package com.bjsxt.proxy;public class TankLogProxy implements Movable&#123; Movable t; public TankLogProxy(Movable t) &#123; this.t = t; &#125; @Override public void move()&#123; System.out.println("Tank Start....."); t.move(); System.out.println("Tank Stop....."); &#125;&#125; 最初其实我们设计的时候，成员变量都是Tank类型的，但是我们要考虑这样一种需求，就是我们想先记录Tank的运行时间，再记录Tank的日志，那么就需要一个包含一个，所以为了可拓展性，我们将成员变量都定义为Movable类型，这样就可以写出如下的测试代码：1234567891011package com.bjsxt.proxy;public class Client &#123; public static void main(String[] args) &#123; Tank t = new Tank(); TankTimeProxy ttp = new TankTimeProxy(t); TankLogProxy tlp = new TankLogProxy(ttp); Movable m = tlp; m.move(); &#125;&#125; 这样就先记录了运行时间，后又记录了日志。 如果我们想先记录日志，后记录运行时间，那么可以很简单的修改:1234567891011package com.bjsxt.proxy;public class Client &#123; public static void main(String[] args) &#123; Tank t = new Tank(); TankLogProxy tlp = new TankLogProxy(t); TankTimeProxy ttp = new TankTimeProxy(tlp); Movable m = ttp; m.move(); &#125;&#125; 第二课前面的代理我们只能对Tank类产生代理，那我们能不能设计一个代理，可以对任何类都代理？ 这一次，我们就写测试类，叫Test1，里面呢，是把TankTimeProxy这个类的代码完完全全复制进来，并且做成一个字符串，然后我们利用jdk提供的编译器，来编译我们的这个字符串，使它形成一个二进制文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.bjsxt.compiler.test;import javax.tools.JavaCompiler;import javax.tools.StandardJavaFileManager;import javax.tools.ToolProvider;import java.io.File;import java.io.FileWriter;public class Test1 &#123; public static void main(String[] args) throws Exception&#123; String rt = "\r\n"; String src = "package com.bjsxt.proxy;" + rt + "public class TankTimeProxy implements Movable&#123;" + rt + " public TankTimeProxy(Movable t) &#123;" + rt + " this.t = t;" + rt + " &#125;" + rt + " Movable t;" + rt + " @Override " + rt + " public void move()&#123;" + rt + " long start = System.currentTimeMillis();" + rt + " System.out.println(\"starttime:\" + start);" + rt + " t.move();" + rt + " long end = System.currentTimeMillis();" + rt + " System.out.println(\"time:\" + (end - start));" + rt + " &#125;" + rt + "&#125;"; System.out.println(System.getProperty("user.dir")); String fileName = System.getProperty("user.dir") + "/src/com/bjsxt/proxy/TankTimeProxy.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); //先拿到编译器对象 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); System.out.println(compiler.getClass().getName()); //拿到fileManager，动态管理文件 StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); JavaCompiler.CompilationTask t = compiler.getTask(null,fileMgr,null,null,null,units); //编译了我们的类 t.call(); fileMgr.close(); &#125;&#125; 最后运行起来发现，果真生成了一个TankTimeProxy.class文件： 第四课刚刚我们将那个字符串编译成了二进制文件，接下来我们想把这个二进制文件load到内存中并且生成新对象：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.bjsxt.compiler.test;import javax.tools.JavaCompiler;import javax.tools.StandardJavaFileManager;import javax.tools.ToolProvider;import java.io.File;import java.io.FileWriter;import java.net.URL;import java.net.URLClassLoader;public class Test1 &#123; public static void main(String[] args) throws Exception&#123; String rt = "\r\n"; String src = "package com.bjsxt.proxy;" + rt + "public class TankTimeProxy implements Movable&#123;" + rt + " public TankTimeProxy(Movable t) &#123;" + rt + " this.t = t;" + rt + " &#125;" + rt + " Movable t;" + rt + " @Override " + rt + " public void move()&#123;" + rt + " long start = System.currentTimeMillis();" + rt + " System.out.println(\"starttime:\" + start);" + rt + " t.move();" + rt + " long end = System.currentTimeMillis();" + rt + " System.out.println(\"time:\" + (end - start));" + rt + " &#125;" + rt + "&#125;"; System.out.println(System.getProperty("user.dir")); String fileName = System.getProperty("user.dir") + "/src/com/bjsxt/proxy/TankTimeProxy.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); /*编译*/ //先拿到编译器对象 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); System.out.println(compiler.getClass().getName()); //拿到fileManager，动态管理文件 StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); JavaCompiler.CompilationTask t = compiler.getTask(null,fileMgr,null,null,null,units); //编译了我们的类 t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir") + "/src")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.bjsxt.proxy.TankTimeProxy"); System.out.println(c); &#125;&#125; 注意，用ClassLoader去load二进制文件时候，二进制文件必须在classpath下面，而这一次我们的二进制文件并不在classpath，所以我们这次使用URLClassLoader来load。 第五课上一节中已经把二进制文件load到内存中，并且生成了新对象，现在我们要做的，就是拿到这个对象的构造器，然后创建一个新的实例，去调用这个实例的方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Test1 &#123; public static void main(String[] args) throws Exception&#123; String rt = "\r\n"; String src = "package com.bjsxt.proxy;" + rt + "public class TankTimeProxy implements Movable&#123;" + rt + " public TankTimeProxy(Movable t) &#123;" + rt + " this.t = t;" + rt + " &#125;" + rt + " Movable t;" + rt + " @Override " + rt + " public void move()&#123;" + rt + " long start = System.currentTimeMillis();" + rt + " System.out.println(\"starttime:\" + start);" + rt + " t.move();" + rt + " long end = System.currentTimeMillis();" + rt + " System.out.println(\"time:\" + (end - start));" + rt + " &#125;" + rt + "&#125;"; System.out.println(System.getProperty("user.dir")); String fileName = System.getProperty("user.dir") + "/src/com/bjsxt/proxy/TankTimeProxy.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); /*编译*/ //先拿到编译器对象 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); System.out.println(compiler.getClass().getName()); //拿到fileManager，动态管理文件 StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); JavaCompiler.CompilationTask t = compiler.getTask(null,fileMgr,null,null,null,units); //编译了我们的类 t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir") + "/src")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.bjsxt.proxy.TankTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Movable.class); Movable m = (Movable) ctr.newInstance(new Tank()); m.move(); &#125;&#125; 运行： 发现也可以去执行我们TankTimeProxy的move方法，实现了和我们之前写的TankTimeProxy相同的代理功能。 第六课上面我们实现的都是一个写死的接口代理，现在我们想代理任何的接口，不光局限于Movable，怎么做？ 我们新创建一个Proxy类，这个类和之前的Test写法几乎一模一样，只是我们在创建一个新代理实例的时候，需要传入一个参数，这个参数指定我们想要给哪一个接口去生成代理：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.bjsxt.proxy;import javax.tools.JavaCompiler;import javax.tools.StandardJavaFileManager;import javax.tools.ToolProvider;import java.io.File;import java.io.FileWriter;import java.lang.reflect.Constructor;import java.net.URL;import java.net.URLClassLoader;public class Proxy &#123; public static Object newProxyInstance(Class infce) throws Exception&#123; //JDK6 Complier API， CGLib， ASM String rt = "\r\n"; String src = "package com.bjsxt.proxy;" + rt + "public class TankTimeProxy implements " + infce.getName() + "&#123;" + rt + " public TankTimeProxy(Movable t) &#123;" + rt + " this.t = t;" + rt + " &#125;" + rt + " Movable t;" + rt + " @Override " + rt + " public void move()&#123;" + rt + " long start = System.currentTimeMillis();" + rt + " System.out.println(\"starttime:\" + start);" + rt + " t.move();" + rt + " long end = System.currentTimeMillis();" + rt + " System.out.println(\"time:\" + (end - start));" + rt + " &#125;" + rt + "&#125;"; System.out.println(System.getProperty("user.dir")); String fileName = System.getProperty("user.dir") + "/src/com/bjsxt/proxy/TankTimeProxy.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); /*编译*/ //先拿到编译器对象 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); System.out.println(compiler.getClass().getName()); //拿到fileManager，动态管理文件 StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); JavaCompiler.CompilationTask t = compiler.getTask(null,fileMgr,null,null,null,units); //编译了我们的类 t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir") + "/src")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.bjsxt.proxy.TankTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Movable.class); Movable m = (Movable) ctr.newInstance(new Tank()); m.move(); return null; &#125;&#125; 这样当我们在测试程序中传入一个Movable.class的时候，生成的.java文件和.class文件就会自动实现这个接口：12345678910111213package com.bjsxt.proxy;import java.io.Serializable;public class Client &#123; public static void main(String[] args) throws Exception&#123; Tank t = new Tank(); Movable m = (Movable) Proxy.newProxyInstance(Movable.class); m.move(); &#125;&#125; 运行之后生成的.java文件为： 如果我们换成传入Serializable.class，那么结果为： Ok，这一段很清晰。就是我们可以去实现任何接口的代理，只要我们去传递参数。 有了这个基础，我们可以利用java的反射机制，来获取一个接口中拥有的所有方法，然后动态的为每一个方法去生成代理方法。先来测试一个反射： 123456789101112package com.bjsxt.compiler.test;import java.lang.reflect.Method;public class Test2 &#123; public static void main(String[] args) &#123; Method[] methods = com.bjsxt.proxy.Movable.class.getMethods(); for (Method m : methods) System.out.println(m.getName()); &#125;&#125; 运行： 我们已经获取到了Movable的方法。 下面我们就在我们的Proxy类中对这种方式进行应用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.bjsxt.proxy;import javax.tools.JavaCompiler;import javax.tools.StandardJavaFileManager;import javax.tools.ToolProvider;import java.io.File;import java.io.FileWriter;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;public class Proxy &#123; public static Object newProxyInstance(Class infce) throws Exception&#123; //JDK6 Complier API， CGLib， ASM String methodString = ""; String rt = "\r\n"; Method[] methods = infce.getMethods(); for (Method m : methods)&#123; methodString += "@Override" + rt + "public void " + m.getName() + "() &#123;" + rt + " long start = System.currentTimeMillis();" + rt + " System.out.println(\"starttime:\" + start);" + rt + " t." + m.getName() + "();" + rt + " long end = System.currentTimeMillis();" + rt + " System.out.println(\"time:\" + (end - start));" + rt + "&#125;" + rt; &#125; System.out.println(methodString); String src = "package com.bjsxt.proxy;" + rt + "public class TankTimeProxy implements " + infce.getName() + "&#123;" + rt + " public TankTimeProxy(Movable t) &#123;" + rt + " this.t = t;" + rt + " &#125;" + rt + " Movable t;" + rt + methodString + "&#125;"; System.out.println(System.getProperty("user.dir")); String fileName = System.getProperty("user.dir") + "/src/com/bjsxt/proxy/TankTimeProxy.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); /*编译*/ //先拿到编译器对象 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); System.out.println(compiler.getClass().getName()); //拿到fileManager，动态管理文件 StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); JavaCompiler.CompilationTask t = compiler.getTask(null,fileMgr,null,null,null,units); //编译了我们的类 t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + System.getProperty("user.dir") + "/src")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.bjsxt.proxy.TankTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Movable.class);// Movable m = (Movable) ctr.newInstance(new Tank());//// m.move(); return null; &#125;&#125; 通过methodString字符串，我们就可以生成所有这个接口的方法的代理，并且最后嵌入总的代码中。我们来运行试一下，看看能不能生成想要的代码： 非常完美！ 我们试着换一下接口，去实现Comparable接口的代理代码： 且不管语法对错，总之也可以生成我们想要的代码。 我们想让Proxy代码返回目标对象，然后去执行对象方法，需要做一点小小的修改：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class Proxy &#123; public static Object newProxyInstance(Class infce) throws Exception&#123; //JDK6 Complier API， CGLib， ASM String methodString = ""; String rt = "\r\n"; Method[] methods = infce.getMethods(); for (Method m : methods)&#123; methodString += "@Override" + rt + "public void " + m.getName() + "() &#123;" + rt + " long start = System.currentTimeMillis();" + rt + " System.out.println(\"starttime:\" + start);" + rt + " t." + m.getName() + "();" + rt + " long end = System.currentTimeMillis();" + rt + " System.out.println(\"time:\" + (end - start));" + rt + "&#125;" + rt; &#125; System.out.println(methodString); String src = "package com.bjsxt.proxy;" + rt + "public class TankTimeProxy implements " + infce.getName() + "&#123;" + rt + " public TankTimeProxy(Movable t) &#123;" + rt + " this.t = t;" + rt + " &#125;" + rt + " Movable t;" + rt + methodString + "&#125;"; System.out.println(System.getProperty("user.dir")); String fileName = "d:/src/com/bjsxt/proxy/TankTimeProxy.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); /*编译*/ //先拿到编译器对象 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); System.out.println(compiler.getClass().getName()); //拿到fileManager，动态管理文件 StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); JavaCompiler.CompilationTask t = compiler.getTask(null,fileMgr,null,null,null,units); //编译了我们的类 t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + "d:/src/")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.bjsxt.proxy.TankTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(Movable.class); Object m = ctr.newInstance(new Tank());// Movable m = (Movable) ctr.newInstance(new Tank());//// m.move(); return m; &#125;&#125; 就是我们自己去建立一个文件夹d:/src/com/bjsxt/proxy，然后将fileName和URL进行修改，并且将方法返回类型改成Object，这样就可以去执行代理的move方法了： 第八课上面已经实现可以为任意接口做代理的功能，那如果我们想动态实现任意的代理，就是说，可以实现记录时间的代理，或者记录日志的代理，等等，这个该怎么动态实现呢？ 这一次我们定义一个InvocationHandler接口：1234567package com.bjsxt.proxy;import java.lang.reflect.Method;public interface InvocationHandler &#123; public void invoke(Object o, Method m);&#125; 然后需要实现什么功能的代理就去实现这个接口，比如我们去实现一个TimeHandler类：1234567891011121314151617181920212223242526272829303132333435363738package com.bjsxt.proxy;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class TimeHandler implements InvocationHandler&#123; private Object target; public TimeHandler(Object target) &#123; this.target = target; &#125; public Object getO() &#123; return target; &#125; public void setO(Object o) &#123; this.target = o; &#125; @Override public void invoke(Object o, Method m) &#123; long start = System.currentTimeMillis(); System.out.println("starttime:" + start); System.out.println(o.getClass().getName()); try &#123; m.invoke(target); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; long end = System.currentTimeMillis(); System.out.println("time:" + (end-start)); &#125;&#125; 在这个实现中，我们内部加入了一个Object类的target成员变量，这个变量其实就是我们将来要去为之实现代理的类。 然后重新设计Proxy类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.bjsxt.proxy;import javax.tools.JavaCompiler;import javax.tools.StandardJavaFileManager;import javax.tools.ToolProvider;import java.io.File;import java.io.FileWriter;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;public class Proxy &#123; public static Object newProxyInstance(Class infce, InvocationHandler h) throws Exception&#123; //JDK6 Complier API， CGLib， ASM String methodString = ""; String rt = "\r\n"; Method[] methods = infce.getMethods(); for (Method m : methods)&#123; methodString += "@Override" + rt + "public void " + m.getName() + "() &#123;" + rt + " try&#123; " + rt + " Method md = " + infce.getName() + ".class.getMethod(\"" + m.getName() + "\");" + rt + " h.invoke(this, md);" + rt + " &#125;catch(Exception e)&#123;e.printStackTrace();&#125;" + rt + "&#125;" + rt; &#125; System.out.println(methodString); String src = "package com.bjsxt.proxy;" + rt + "import java.lang.reflect.Method;" + rt + "public class TankTimeProxy implements " + infce.getName() + "&#123;" + rt + " public TankTimeProxy(InvocationHandler h) &#123;" + rt + " this.h = h;" + rt + " &#125;" + rt + " com.bjsxt.proxy.InvocationHandler h;" + rt + methodString + "&#125;"; System.out.println(System.getProperty("user.dir")); String fileName = "d:/src/com/bjsxt/proxy/TankTimeProxy.java"; File f = new File(fileName); FileWriter fw = new FileWriter(f); fw.write(src); fw.flush(); fw.close(); /*编译*/ //先拿到编译器对象 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); System.out.println(compiler.getClass().getName()); //拿到fileManager，动态管理文件 StandardJavaFileManager fileMgr = compiler.getStandardFileManager(null, null, null); Iterable units = fileMgr.getJavaFileObjects(fileName); JavaCompiler.CompilationTask t = compiler.getTask(null,fileMgr,null,null,null,units); //编译了我们的类 t.call(); fileMgr.close(); //load into memory and create an instance URL[] urls = new URL[] &#123;new URL("file:/" + "d:/src/")&#125;; URLClassLoader ul = new URLClassLoader(urls); Class c = ul.loadClass("com.bjsxt.proxy.TankTimeProxy"); System.out.println(c); Constructor ctr = c.getConstructor(InvocationHandler.class); Object m = ctr.newInstance(h); return m; &#125;&#125; 这一次，我们通过getConstructor方法拿到InvocationHandler类的构造器，然后去传入一个被传入的InvocationHandler参数，这里是h，其实可以就是我们刚刚的TimeHandler，这样就可以构造出一个加了被代理的类的对象。 我们在测试代码中这么写： 1234567891011121314package com.bjsxt.proxy;import java.io.Serializable;public class Client &#123; public static void main(String[] args) throws Exception&#123; Tank t = new Tank(); InvocationHandler h = new TimeHandler(t); Movable m = (Movable) Proxy.newProxyInstance(Movable.class, h); m.move(); &#125;&#125; 运行一下： 这样就完成了对任意的对象，任意的接口方法，实现任意的代理。 第九课有了上面的基础，我们来完成一个例子，就是定义一个用户管理的接口，这个管理者有一个add方法，我们现在就是想用上面的方法，为这个类设计一个动态的代理，可以使得这个类在执行add方法之外包上一个事务管理的代理功能。 先设计UserMgr接口：12345package com.bjsxt.proxy.test;public interface UserMgr &#123; void addUser();&#125; 设计一个UserMgrImpl类来实现这个接口：123456789package com.bjsxt.proxy.test;public class UserMgrImpl implements UserMgr &#123; @Override public void addUser() &#123; System.out.println("1: 插入记录到User表"); System.out.println("2: 做日志在另外一张表"); &#125;&#125; 接下来我们就要去实现一个事务管理的代理（TransactionHandler.java）：1234567891011121314151617181920212223242526package com.bjsxt.proxy.test;import com.bjsxt.proxy.InvocationHandler;import java.lang.reflect.Method;public class TransactionHandler implements InvocationHandler &#123; public TransactionHandler(Object target) &#123; this.target = target; &#125; private Object target; @Override public void invoke(Object o, Method m) &#123; System.out.println("Transaction Start"); try &#123; m.invoke(target); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("Transaction Commit"); &#125;&#125; 写一个测试代码，将UserMgrImpl传入到TransactionHandler中，然后将这个代理传入到Proxy的newProxyInstance方法中，构造一个被代理的类，接下来就可以调用其addUser方法了：123456789101112131415package com.bjsxt.proxy.test;import com.bjsxt.proxy.InvocationHandler;import com.bjsxt.proxy.Proxy;import com.bjsxt.proxy.TimeHandler;public class Client &#123; public static void main(String[] args) throws Exception &#123; UserMgr mgr = new UserMgrImpl(); InvocationHandler h = new TransactionHandler(mgr); UserMgr u = (UserMgr) Proxy.newProxyInstance(UserMgr.class, h); u.addUser(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（四） Strategy]]></title>
    <url>%2F2017%2F12%2F26%2FDesignPattern4%2F</url>
    <content type="text"><![CDATA[本文主要介绍策略模式。 第一课先写出我们的main函数：123456789package com.bjsxt.dp.strategy;public class Test &#123; public static void main(String[] args) &#123; int[] a = &#123;9, 5, 3, 7, 1&#125;; DataSorter.sort(a); DataSorter.p(a); &#125;&#125; 接下来，我们要实现一个类DataSorter，里面实现两个方法：sort()对数组进行排序p()对数组进行打印 第二课排序口诀：冒择路（入）兮（希尔）快归堆 我们实现DataSorter类：12345678910111213141516171819202122232425package com.bjsxt.dp.strategy;public class DataSorter &#123; public static void sort(int[] a) &#123; for (int i = a.length; i &gt; 0; i--)&#123; for (int j = 0; j &lt; i - 1; j++)&#123; if(a[j] &gt; a[j+1]) swap(a, j, j+1); &#125; &#125; &#125; private static void swap(int[] a, int x, int y) &#123; int temp = a[x]; a[x] = a[y]; a[y] = temp; &#125; public static void p(int[] a) &#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 排序算法使用的是冒泡。 第三课我们在这一节中，实现一个Cat类：1234567891011121314151617181920212223242526272829package com.bjsxt.dp.strategy;public class Cat &#123; public Cat(int height, int weight) &#123; this.height = height; this.weight = weight; &#125; public int getHeight() &#123; return height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; private int height; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; private int weight;&#125; 我们想在DataSorter中也实现对Cat的排序和打印功能：123456789101112131415161718192021public static void sort(Cat[] a) &#123; for (int i = a.length; i &gt; 0; i--)&#123; for (int j = 0; j &lt; i - 1; j++)&#123; if(a[j].getHeight() &gt; a[j+1].getHeight()) swap(a, j, j+1); &#125; &#125;&#125;private static void swap(Cat[] a, int x, int y) &#123; Cat temp = a[x]; a[x] = a[y]; a[y] = temp;&#125;public static void p(Cat[] a) &#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i].getHeight() + "|" + a[i].getWeight() + " "); System.out.println();&#125; 在Test.java中对Cat数组进行排序：12345678910package com.bjsxt.dp.strategy;public class Test &#123; public static void main(String[] args) &#123;// int[] a = &#123;9, 5, 3, 7, 1&#125;; Cat[] a = &#123;new Cat(5,5), new Cat(1,9), new Cat(3,6)&#125;; DataSorter.sort(a); DataSorter.p(a); &#125;&#125; 第四课现在不光想对猫进行排序，还想对狗进行排序，这时候就比较麻烦了，我们已经有了对int数组的排序，对猫的排序，如果现在加进来对狗的排序，我们的DataSorter类就会越来越臃肿，不利于扩展。 现在我们的想法是设计一个可以比较大小的接口，然后让猫、狗等都实现这个接口，每一种实现内部都对比较函数进行自己的实现。 Comparable接口：123456package com.bjsxt.dp.strategy;public interface Comparable &#123; public int compareTo(Object o);&#125; Cat对这个方法进行实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.bjsxt.dp.strategy;public class Cat implements Comparable&#123; public Cat(int height, int weight) &#123; this.height = height; this.weight = weight; &#125; public int getHeight() &#123; return height; &#125; public void setHeight(int height) &#123; this.height = height; &#125; private int height; public int getWeight() &#123; return weight; &#125; public void setWeight(int weight) &#123; this.weight = weight; &#125; private int weight; @Override public int compareTo(Object o) &#123; if(o instanceof Cat)&#123; Cat c = (Cat)o; if (this.getHeight() &gt; c.getHeight()) return 1; else if(this.getHeight() &lt; c.getHeight()) return -1; else return 0; &#125; return -100; &#125; @Override public String toString() &#123; return this.getHeight() + "|" + this.getWeight(); &#125;&#125; 狗也对这个方法进行实现：12345678910111213141516171819202122232425262728293031323334package com.bjsxt.dp.strategy;public class Dog implements Comparable&#123; public Dog(int food) &#123; this.food = food; &#125; public int getFood() &#123; return food; &#125; public void setFood(int food) &#123; this.food = food; &#125; private int food; @Override public int compareTo(Object o) &#123; Dog d = (Dog)o; if(this.food &gt; d.food) return 1; else if(this.food &lt; d.food) return -1; else return 0; &#125; @Override public String toString()&#123; return this.food + ""; &#125;&#125; 对DataSorter.java重新设计：12345678910111213141516171819202122232425262728package com.bjsxt.dp.strategy;public class DataSorter &#123; public static void sort(Object[] a) &#123; for (int i = a.length; i &gt; 0; i--)&#123; for (int j = 0; j &lt; i - 1; j++)&#123; Comparable o1 = (Comparable)a[j]; Comparable o2 = (Comparable)a[j+1]; if(o1.compareTo(o2) == 1) swap(a, j, j+1); &#125; &#125; &#125; private static void swap(Object[] a, int x, int y) &#123; Object temp = a[x]; a[x] = a[y]; a[y] = temp; &#125; public static void p(Object[] a) &#123; for (int i = 0; i &lt; a.length; i++) System.out.print(a[i] + " "); System.out.println(); &#125;&#125; 这样就可以对任意一种自己设计的类进行排序了。 第六课上一节中，我们每设计一个类，都要让它去实现Comparable接口，然后根据自己需要去实现compareTo方法，从而使得相同类的对象之间可以做比较，从而就实现了排序。 这一节中，我们采取与上一节中不同的想法，让比较器成为一个组件，在类中拥有它，调用它的方法就可以实现比较。 先设计一个Comparator接口：12345package com.bjsxt.dp.strategy;public interface Comparator &#123; int compare(Object o1, Object o2);&#125; 然后如果要对猫的身高进行排序，那么我们就来实现一个Comparator的类：12345678910111213package com.bjsxt.dp.strategy;public class CatHeightComparator implements Comparator&#123; @Override public int compare(Object o1, Object o2) &#123; Cat c1 = (Cat)o1; Cat c2 = (Cat)o2; if(c1.getHeight() &gt; c2.getHeight()) return 1; else if(c1.getHeight() &lt; c2.getHeight()) return -1; return 0; &#125;&#125; 有了这个类之后，我们只需要在Cat类中实例化这个类，就可以拥有对猫身高的比较功能： 123456789101112131415161718public class Cat implements Comparable&#123; private int height; private Comparator comparator = new CatHeightComparator(); public Comparator getComparator() &#123; return comparator;&#125;public void setComparator(Comparator comparator) &#123; this.comparator = comparator;&#125;@Overridepublic int compareTo(Object o) &#123; return comparator.compare(this, o);&#125;&#125; 在Test.java中维持原来的代码，依然可以做到排序：12345678910public class Test &#123; public static void main(String[] args) &#123;// int[] a = &#123;9, 5, 3, 7, 1&#125;; Cat[] a = &#123;new Cat(5,5), new Cat(1,9), new Cat(3,6)&#125;;// Dog[] a = &#123;new Dog(5), new Dog(3), new Dog(1)&#125;; DataSorter.sort(a); DataSorter.p(a); &#125;&#125; 既然我们可以比较身高，那相同的做法，我们也可以比较体重：123456789101112package com.bjsxt.dp.strategy;public class CatWeightComparator implements Comparator&#123; @Override public int compare(Object o1, Object o2) &#123; Cat c1 = (Cat)o1; Cat c2 = (Cat)o2; if(c1.getWeight() &gt; c2.getWeight()) return 1; else if(c1.getWeight() &lt; c2.getWeight()) return -1; return 0; &#125;&#125; 然后我们在Cat类中将拥有的Comparator对象实现换做身高比较器就可以了：private Comparator comparator = new CatWeightComparator(); 其他的统统保持不变，这样就提高了代码的可拓展性。 第七课之前我们实现的比较函数中，也就是compareTo函数中，参数只能是Object类型的，而且在函数内部必须进行强制转型，比如Cat类中必须写：Cat c1 = (Cat)o1;但实际上，java的jdk已经帮我们封装好了一个Comparable，这个Comparable采用泛型，也就是直接在实现这个接口的时候，在后面指定后期相比较的类型，便可以在compareTo函数中直接使用要比较类型的对象了，从而省去了强制转型的麻烦。 123456789101112131415161718package com.bjsxt.dp.strategy;public class Cat implements java.lang.Comparable&lt;Cat&gt;&#123; private int height; private java.util.Comparator&lt;Cat&gt; comparator = new CatHeightComparator(); public java.util.Comparator getComparator() &#123; return comparator; &#125; public void setComparator(java.util.Comparator comparator) &#123; this.comparator = comparator; &#125; public int compareTo(Cat o) &#123; return comparator.compare(this, o); &#125;&#125; 而CatHeightComparator也直接去实现jdk封装好的Comparator：12345678910111213package com.bjsxt.dp.strategy;public class CatHeightComparator implements java.util.Comparator&lt;Cat&gt;&#123; @Override public int compare(Cat o1, Cat o2) &#123; Cat c1 = (Cat)o1; Cat c2 = (Cat)o2; if(c1.getHeight() &gt; c2.getHeight()) return 1; else if(c1.getHeight() &lt; c2.getHeight()) return -1; return 0; &#125;&#125; 这样我们直接在main函数中去比较就可以了：12345678910public class Test &#123; public static void main(String[] args) &#123; Cat[] a = &#123;new Cat(5,5), new Cat(1,9), new Cat(3,6)&#125;; DataSorter.sort(a); DataSorter.p(a); &#125;&#125; 其实，我们连比较器都不需要实现，因为java的jdk已经帮我们实现了排序算法，而且支持泛型，我们只需要把对象传进去就可以了：1234567891011package com.bjsxt.dp.strategy;public class Test &#123; public static void main(String[] args) &#123; Cat[] a = &#123;new Cat(5,5), new Cat(1,9), new Cat(3,6)&#125;; java.util.Arrays.sort(a); DataSorter.p(a); &#125;&#125; 所以策略模式只是帮助我们理解Comparable和Comparator，真正在使用中可以直接采用jdk封装好的东西。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（三） Iterator]]></title>
    <url>%2F2017%2F12%2F26%2FDesignPattern3%2F</url>
    <content type="text"><![CDATA[本文主要介绍迭代器模式。 第一课模拟实现一个ArrayList： ArrayList.java:123456789101112131415161718192021222324252627package com.bjsxt.dp.iterator;public class ArrayList &#123; Object[] objects = new Object[10]; //用于表示objects下一个空的位置 int index = 0; public void add(Object o) &#123; if(index == objects.length)&#123;// 当当前数组装满，就在这个长度基础上扩展两倍 Object[] newObjects = new Object[objects.length * 2];// 将原数组复制到新数组 System.arraycopy(objects, 0, newObjects, 0, objects.length); objects = newObjects; &#125; objects[index] = o; index++; &#125; //返回长度 public int size()&#123; return index; &#125;&#125; Cat.java:123456789package com.bjsxt.dp.iterator;public class Cat &#123; private int id; public Cat(int id) &#123; this.id = id; &#125;&#125; Test.java:12345678910111213package com.bjsxt.dp.iterator;import com.bjsxt.dp.iterator.ArrayList;public class Test &#123; public static void main(String[] args) &#123; ArrayList al = new ArrayList(); for(int i = 0; i &lt; 15; i++)&#123; al.add(new Cat(i)); &#125; System.out.println(al.size()); &#125;&#125; 这节我们是在用数组实现的ArrayList，下一节，我们想用链表来实现。 第二课本节实现一个链表，也就是LinkedList： Node.java:1234567891011121314151617181920212223242526272829package com.bjsxt.dp.iterator;public class Node &#123; private Object data; private Node next; public Node(Object data, Node next) &#123; this.data = data; this.next = next; &#125; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node next) &#123; this.next = next; &#125;&#125; LinkedList.java:12345678910111213141516171819202122232425package com.bjsxt.dp.iterator;public class LinkedList &#123; Node head = null; Node tail = null; int size = 0; public void add(Object o)&#123; Node n = new Node(o, null); if(head == null) &#123; head = n; tail = n; &#125; else&#123; tail.setNext(n); tail = n; &#125; size++; &#125; public int size()&#123; return 0; &#125;&#125; 修改Test.java:1234567891011121314package com.bjsxt.dp.iterator;import com.bjsxt.dp.iterator.ArrayList;public class Test &#123; public static void main(String[] args) &#123;// ArrayList al = new ArrayList(); LinkedList al = new LinkedList(); for(int i = 0; i &lt; 15; i++)&#123; al.add(new Cat(i)); &#125; System.out.println(al.size()); &#125;&#125; 第三课上两节我们实现了两个可以动态添加对象的容器，这一节我们考虑一下容器得到可替换性。就是说，我们定义一套统一的标准，让链表和数组都用相同的接口，那么为了实现这个目标，我们定义一个Collection.java：123456package com.bjsxt.dp.iterator;public interface Collection &#123; void add(Object o); int size();&#125; 然后让数组和链表实现这个集合接口：123public class ArrayList implements Collectionpublic class LinkedList implements Collection 这样我们就统一了标准修改Test.java：123456789101112131415package com.bjsxt.dp.iterator;import com.bjsxt.dp.iterator.ArrayList;public class Test &#123; public static void main(String[] args) &#123;// ArrayList al = new ArrayList();// LinkedList al = new LinkedList(); Collection c = new ArrayList(); for(int i = 0; i &lt; 15; i++)&#123; c.add(new Cat(i)); &#125; System.out.println(c.size()); &#125;&#125; 这样我们就由父类引用指向子类对象，我们的代码就变成了面向接口编程，更加灵活，可扩展。现在，我们想实现对容器的遍历，怎么实现呢？ 第四课现在想实现对各种容器的遍历，但是每一种容器由于结构的不同，它们的遍历方式也不同。 首先我们定义一个迭代器接口：123456package com.bjsxt.dp.iterator;public interface Iterator &#123; Object next(); boolean hasNext();&#125; 在Collection.java中添加对Iterator接口的支持：1234567package com.bjsxt.dp.iterator;public interface Collection &#123; void add(Object o); int size(); public Iterator iterator();&#125; 在ArrayList中实现迭代器方法，返回一个迭代器：123456789101112131415161718192021public Iterator iterator()&#123; return new ArrayListIterator(); &#125; private class ArrayListIterator implements Iterator&#123; private int currentIndex = 0; @Override public Object next() &#123; Object o = objects[currentIndex]; currentIndex ++; return o; &#125; @Override public boolean hasNext() &#123; if(currentIndex &gt;= index) return false; else return true; &#125;&#125; 在Main方法中调用集合中的iterator方法：12345Iterator it = c.iterator();while(it.hasNext())&#123; Object o = it.next(); System.out.println(o + " ");&#125; 第五课我们这一节研究泛型: 123456789101112131415161718192021222324252627282930package com.bjsxt.dp.iterator.generic;public class GenericArrayList&lt;E&gt; &#123; Object[] objects = new Object[10]; //用于表示objects下一个空的位置 int index = 0; public void add(E o) &#123; if(index == objects.length)&#123;// 当当前数组装满，就在这个长度基础上扩展两倍 Object[] newObjects = new Object[objects.length * 2];// 将原数组复制到新数组 System.arraycopy(objects, 0, newObjects, 0, objects.length); objects = newObjects; &#125; objects[index] = o; index++; &#125; //返回长度 public int size()&#123; return index; &#125; public static void main(String[] args) &#123; GenericArrayList&lt;String&gt; a = new GenericArrayList&lt;String&gt;(); a.add("hello"); &#125;&#125; 泛型中可以指定特定类型，这样我们就不需要再强制转换了。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（二） Thinking in OO]]></title>
    <url>%2F2017%2F12%2F26%2FDesignPattern2%2F</url>
    <content type="text"><![CDATA[本文主要介绍面向对象的设计思想 抽丝剥茧策略模式C&amp;C接口详细解析(Comparable &amp; Comparator)要求：初步具备面向对象的设计思维了解多态的概念 项目背景老张开车去东北撞了肇事司机耍流氓跑了多亏一个东北人送到医院缝五针好了老张请他吃顿饭喝得少了他不干他说……..俺们那嘎都是东北人…俺们那嘎盛产高丽参…俺们那嘎猪肉炖粉条…俺们都是活雷锋…俺们那嘎没有这种人…撞了车哪能不救人…俺们哪嘎山上有珍蘑…那个人他不是东北人 …翠花上酸菜 第一个版本（Test1.java）：12345public class Test1 &#123; public static void main(String[] args) &#123; System.out.println("老张开车去东北"); &#125;&#125; 第二个版本（Test2.java）:12345678public class Test2 &#123; public static void main(String[] args) &#123; String driverName = "老张"; String vehicle = "车"; String targetPlace = "东北"; System.out.println(driverName + "开" + vehicle + "去" + targetPlace); &#125;&#125; 第三个版本（Test3.java）:123456789101112public class Test3 &#123; public static void main(String[] args) &#123; String driverName = "老张"; String vehicle = "车"; String targetPlace = "东北"; go(driverName, vehicle, targetPlace); &#125; public static void go(String driverName, String vehicle, String targetPlace)&#123; System.out.println(driverName + "开" + vehicle + "去" + targetPlace); &#125;&#125; 第四个版本：Driver.java：1234567891011121314151617181920public class Driver &#123; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private String name; public void drive(Vihecle v)&#123; v.go(new Address("东北")); &#125; //重载方法，提供不同的调用支持 public void drive(Car c, Address dest)&#123; c.go(dest); &#125;&#125; Vihecle.java： 123public abstract class Vihecle &#123; public abstract void go(Address dest);&#125; Car.java：12345public class Car extends Vihecle&#123; public void go(Address dest)&#123; System.out.println("一路哼着歌，冒着烟，去了" + dest.getName()); &#125;&#125; Plane.java：12345public class Plane extends Vihecle &#123; public void go(Address dest)&#123; System.out.println("一路扇着翅膀，去了" + dest.getName()); &#125;&#125; Broom.java：123456public class Broom extends Vihecle &#123; @Override public void go(Address dest) &#123; System.out.println("一路扫着土去了" + dest.getName()); &#125;&#125; Address.java：123456789101112131415public class Address &#123; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; private String name; public Address(String name) &#123; this.name = name; &#125;&#125; Test.java：1234567public class Test &#123; public static void main(String[] args) &#123; Driver d = new Driver(); d.setName("老张"); d.drive(new Broom()); &#125;&#125; 通过多态，可以在drive的交通工具中创建任何的子类对象。比如Broom，Car，Plane 总结：OO思维(Object Oriented) 考虑类&nbsp;&nbsp;&nbsp;&nbsp;名词属性&nbsp;&nbsp;&nbsp;&nbsp;不可脱离具体的应用环境方法类之间的关系隐藏（封装）&nbsp;&nbsp;&nbsp;&nbsp;降低耦合度继承&nbsp;&nbsp;&nbsp;&nbsp;继承关系耦合度非常强，应该谨慎使用多态&nbsp;&nbsp;&nbsp;&nbsp;继承其实就是为了多态，多态给我们带来了可扩展性 多态 核心中的核心可扩展性（Extensibility）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式笔记（一） 责任链]]></title>
    <url>%2F2017%2F12%2F26%2FDesignPattern1%2F</url>
    <content type="text"><![CDATA[本文介绍设计模式中的责任链模式。 第一课考虑一个场景：我们要做一个网站，客户端给服务器要发一些信息，服务器要对一些敏感信息进行过滤修改，最简单的办法就是写一个类，对客户端发来的字符串进行字符替换。代码如下：Main.java: 123456789101112131415161718192021222324252627282930313233343536package com.bjsxt.dp.filter;public class Main &#123; public static void main(String[] args) &#123; String msg = "大家好:),&lt;script&gt;,敏感,被就业,网络授课没感觉,因为看不见大家伙儿"; MsgProcessor mp = new MsgProcessor(); mp.setMsg(msg); String result = mp.process(); System.out.println(result); &#125;&#125;package com.bjsxt.dp.filter;public class MsgProcessor &#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public String process()&#123; //处理html tag &lt;&gt; String r = msg.replace('&lt;','[').replace('&gt;',']'); //处理敏感字眼 r = r.replace("被就业", "就业") .replace("敏感", ""); return r; &#125;&#125; 第二课重新对上面的代码进行设计，使我们的过滤器成为一个接口，需要制作一个新的过滤器规则时，就实现这个接口，然后在自己的代码里创建一个过滤器数组，需要什么规则就添加哪个过滤器即可。 看代码： 设计Filter的接口（Filter.java）: 12345package com.bjsxt.dp.filter;public interface Filter &#123; String doFilter(String str);&#125; 设计一个HTMLFilter类，实现Filter，用来处理信息中包括的&lt;&gt;：12345678910package com.bjsxt.dp.filter;public class HTMLFilter implements Filter &#123; @Override public String doFilter(String str) &#123; //处理html tag &lt;&gt; String r = str.replace('&lt;','[').replace('&gt;',']'); return r; &#125;&#125; 设计一个SesitiveFilter类，实现Filter，用来过滤敏感词汇： 123456789101112package com.bjsxt.dp.filter;public class SesitiveFilter implements Filter &#123; @Override public String doFilter(String str) &#123; //处理敏感字眼 String r = str.replace("被就业", "就业") .replace("敏感", ""); return r; &#125;&#125; 设计一个FaceFilter类，实现Filter，用来将笑脸替换成我们想要的笑脸： 12345678package com.bjsxt.dp.filter;public class FaceFilter implements Filter&#123; @Override public String doFilter(String str) &#123; return str.replace(":)","^V^"); &#125;&#125; 设计一个MsgProcessor类，创建一个Filter数组，用来将刚刚创建的一些过滤器都装入这个数组，然后对遍历数组，对我们的信息依次调用这些过滤器规则： 123456789101112131415161718192021222324252627package com.bjsxt.dp.filter;public class MsgProcessor &#123; private String msg; Filter[] filters = &#123;new HTMLFilter(), new SesitiveFilter(), new FaceFilter()&#125;; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public String process()&#123; String r = msg; for (Filter f : filters)&#123; r = f.doFilter(r); &#125; return r; &#125;&#125; Main.java：1234567891011package com.bjsxt.dp.filter;public class Main &#123; public static void main(String[] args) &#123; String msg = "大家好:),&lt;script&gt;,敏感,被就业,网络授课没感觉,因为看不见大家伙儿"; MsgProcessor mp = new MsgProcessor(); mp.setMsg(msg); String result = mp.process(); System.out.println(result); &#125;&#125; 在考虑一个问题：比如我们有了一组现成的过滤器规则，但是这时候想在中间插入一组其他过滤器规则，该怎么实现呢？ 第三节我们对上面的代码重新进行设计：先创建一个FilterChain类，这个类的作用就是保存我们需要的过滤器，并且可以在执行过滤过程：1234567891011121314151617181920package com.bjsxt.dp.filter;import java.util.ArrayList;import java.util.List;public class FilterChain &#123; List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); public FilterChain addFilter(Filter r)&#123; this.filters.add(r); return this; &#125; public String doFilter(String str)&#123; String r = str; for (Filter f : filters) r = f.doFilter(r); return r; &#125;&#125; 然后再重新设计MsgProcessor类，使其内部封装一个FilterChain，并且可以接受客户端传来的消息： 1234567891011121314151617181920212223242526272829package com.bjsxt.dp.filter;public class MsgProcessor &#123; private String msg; FilterChain fc; public String getMsg() &#123; return msg; &#125; public FilterChain getFc() &#123; return fc; &#125; public void setFc(FilterChain fc) &#123; this.fc = fc; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public String process()&#123; return fc.doFilter(msg); &#125;&#125; 重新设计Main.java： 1234567891011121314151617package com.bjsxt.dp.filter;public class Main &#123; public static void main(String[] args) &#123; String msg = "大家好:),&lt;script&gt;,敏感,被就业,网络授课没感觉,因为看不见大家伙儿"; MsgProcessor mp = new MsgProcessor(); mp.setMsg(msg); FilterChain fc = new FilterChain(); fc.addFilter(new HTMLFilter()).addFilter(new SesitiveFilter()).addFilter(new FaceFilter()); mp.setFc(fc); String result = mp.process(); System.out.println(result); &#125;&#125; 注意上面的FilterChain可以链式调用addFilter方法，这是由于addFilter返回了一个FilterChain本身的类。 上面代码的类结构图如下： 用序列图表示就是： 为了实现上一节可提出的，在过滤器链中插入一组过滤器，我们可以对前面的代码再次重新设计：使FilterChain实现Filter接口：public class FilterChain implements Filter{…} 在Main中定义两个链，一个fc，一个fc2，两个都包含一组过滤器，那么由于fc和fc2实现了Filter，所以直接在fc中添加fc2就可以了：123456789101112131415161718192021package com.bjsxt.dp.filter;public class Main &#123; public static void main(String[] args) &#123; String msg = "大家好:),&lt;script&gt;,敏感,被就业,网络授课没感觉,因为看不见大家伙儿"; MsgProcessor mp = new MsgProcessor(); mp.setMsg(msg); FilterChain fc = new FilterChain(); fc.addFilter(new HTMLFilter()).addFilter(new SesitiveFilter()); FilterChain fc2 = new FilterChain(); fc2.addFilter(new FaceFilter()); fc.addFilter(fc2); mp.setFc(fc); String result = mp.process(); System.out.println(result); &#125;&#125; 现在可以说是基本有了责任链模式的意思了。 现在考虑一个问题，就是我们之前都是处理从客户端到服务端的消息，那么怎么样能处理从服务端到客户端的信息？就像下面图像表示的那样： 第四课为了完成能同时对来回的消息都进行过滤处理，我们进行如下设计：创建两个类，一个Request，一个Response： Request.java:12345678910111213package com.bjsxt.dp.filter;public class Request &#123; public String getRequestStr() &#123; return requestStr; &#125; public void setRequestStr(String requestStr) &#123; this.requestStr = requestStr; &#125; String requestStr;&#125; Response.java:12345678910111213package com.bjsxt.dp.filter;public class Response &#123; public String getResponseStr() &#123; return responseStr; &#125; public void setResponseStr(String responseStr) &#123; this.responseStr = responseStr; &#125; String responseStr;&#125; 重新设计Filter.java:12345package com.bjsxt.dp.filter;public interface Filter &#123; String doFilter(Request request, Response response);&#125; FilterChain要重新实现这个接口：1234567891011121314151617package com.bjsxt.dp.filter;import java.util.ArrayList;import java.util.List;public class FilterChain implements Filter&#123; List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); @Override public void doFilter(Request request, Response response)&#123; for (Filter f : filters) f.doFilter(request, response); &#125;&#125; HTMLFilter.java： 12345678910package com.bjsxt.dp.filter;public class HTMLFilter implements Filter &#123; @Override public void doFilter(Request request, Response response) &#123; //处理html tag &lt;&gt; request.requestStr = request.requestStr.replace('&lt;','[').replace('&gt;',']'); &#125;&#125; SesitiveFilter.java： 1234567891011package com.bjsxt.dp.filter;public class SesitiveFilter implements Filter &#123; @Override public void doFilter(Request request, Response response) &#123; //处理敏感字眼 request.requestStr = request.requestStr.replace("被就业", "就业") .replace("敏感", ""); &#125;&#125; 把FaceFilter.java和MsgProcessor.java删掉，并修改Main.java:123456789101112131415161718192021package com.bjsxt.dp.filter;public class Main &#123; public static void main(String[] args) &#123; String msg = "大家好:),&lt;script&gt;,敏感,被就业,网络授课没感觉,因为看不见大家伙儿"; Request request = new Request(); request.setRequestStr(msg); Response response = new Response(); response.setResponseStr("response"); FilterChain fc = new FilterChain(); fc.addFilter(new HTMLFilter()).addFilter(new SesitiveFilter()); fc.doFilter(request, response); System.out.println(request.getRequestStr()); System.out.println(response.getResponseStr()); &#125;&#125; 运行发现，现在只有request消息被处理，response没有被处理： 为了使response也被处理，修改前面的代码，对response进行处理： SesitiveFilter.java: 12345678910111213package com.bjsxt.dp.filter;public class SesitiveFilter implements Filter &#123; @Override public void doFilter(Request request, Response response) &#123; //处理敏感字眼 request.requestStr = request.requestStr.replace("被就业", "就业") .replace("敏感", "") + "---SesitiveStrFilter()"; response.responseStr += "---SesitiveStrFilter()"; &#125;&#125; HTMLFilter.java: 123456789101112package com.bjsxt.dp.filter;public class HTMLFilter implements Filter &#123; @Override public void doFilter(Request request, Response response) &#123; //处理html tag &lt;&gt; request.requestStr = request.requestStr.replace('&lt;','[').replace('&gt;',']') + "---HTMLFilter()"; response.responseStr += "---HTMLFilter()"; &#125;&#125; 运行效果： 发现顺序有问题，因为response的过滤器顺序应该反过来才对。 为了实现这个需求，我们重新设计Filter.java，使其参数中传入一个FilterChain：12345package com.bjsxt.dp.filter;public interface Filter &#123; void doFilter(Request request, Response response, FilterChain chain);&#125; FilterChain.java:1234567891011121314151617181920212223package com.bjsxt.dp.filter;import java.util.ArrayList;import java.util.List;public class FilterChain implements Filter&#123; List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); int index = 0; public FilterChain addFilter(Filter r)&#123; this.filters.add(r); return this; &#125; public void doFilter(Request request, Response response, FilterChain chain)&#123; if(index == filters.size()) return; Filter f = filters.get(index); index ++; f.doFilter(request, response, chain); &#125;&#125; HTMLFilter.java:1234567891011121314package com.bjsxt.dp.filter;public class HTMLFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; //处理html tag &lt;&gt; request.requestStr = request.requestStr.replace('&lt;','[').replace('&gt;',']') + "---HTMLFilter()"; chain.doFilter(request, response, chain); response.responseStr += "---HTMLFilter()"; &#125;&#125; SesitiveFilter.java: 1234567891011121314package com.bjsxt.dp.filter;public class SesitiveFilter implements Filter &#123; @Override public void doFilter(Request request, Response response, FilterChain chain) &#123; //处理敏感字眼 request.requestStr = request.requestStr.replace("被就业", "就业") .replace("敏感", "") + "---SesitiveStrFilter()"; chain.doFilter(request, response, chain); response.responseStr += "---SesitiveStrFilter()"; &#125;&#125; Main.java:12345678910111213141516171819202122package com.bjsxt.dp.filter;public class Main &#123; public static void main(String[] args) &#123; String msg = "大家好:),&lt;script&gt;,敏感,被就业,网络授课没感觉,因为看不见大家伙儿"; Request request = new Request(); request.setRequestStr(msg); Response response = new Response(); response.setResponseStr("response"); FilterChain fc = new FilterChain(); fc.addFilter(new HTMLFilter()).addFilter(new SesitiveFilter()); fc.doFilter(request, response, fc); System.out.println(request.getRequestStr()); System.out.println(response.getResponseStr()); &#125;&#125; 运行结果： 发现成功实现了倒序！ 这是怎么做到的？ 发现在FilterChain中对request进行递归处理，就是使用完一个过滤器，马上又递归调用下一个过滤器。直到最后一个过滤器处理完request，才对response进行处理，处理完返回，就到了上一个过滤器的处理。所以整体就实现了一个堆栈的过程。 其实Java Web和Struts2的过滤器就是这么实现的。 那么如果我们在对request进行处理的时候，想要终止后续操作，该怎么做呢？ 直接在处理时候不调下一个filter就可以了。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate笔记（八） Hibernate性能优化]]></title>
    <url>%2F2017%2F12%2F21%2FHibernate8%2F</url>
    <content type="text"><![CDATA[本文主要介绍Hibernate的性能优化方式，最后总结一下Hibernate。 第六十四课. 1+N问题重置上一节中数据库的数据，然后我们插入一些数据：12345678910111213141516171819@Testpublic void testSave() &#123; Session session = sf.openSession(); session.beginTransaction(); for(int i=0; i&lt;10; i++) &#123; Category c = new Category(); c.setName("c" + i); Topic t = new Topic(); t.setCategory(c); t.setTitle("t" + i); t.setCreateDate(new Date()); session.save(c); session.save(t); &#125; session.getTransaction().commit(); session.close();&#125; 运行： 可以看到，这一次我们每一个版块中插入一条数据。 接下来我们写一个测试程序，用来往出取数据：123456789101112131415 @Test public void testQuery1() &#123; Session session = sf.openSession(); session.beginTransaction();// List&lt;Topic&gt; topics = (List&lt;Topic&gt;)session.createCriteria(Topic.class).list(); List&lt;Topic&gt; topics = (List&lt;Topic&gt;)session.createQuery("from Topic").list(); for(Topic t : topics) &#123; System.out.println(t.getId() + "-" + t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125; 执行： 发现除了发出一个在Topic表中进行查询的sql语句之外，还另外发出了十条查询category表的sql语句。我们本来期望只发出第一条语句，这就是1+N问题。原因就是在Topic类中的ManyToOne默认设置是fetch为Eager的，所以会将与其关联的category都取出来。 这个问题怎么解决呢？ @ManyToOne(fetch=FetchType.LAZY) BatchSize(本例就是在Category类上面加一条注解：@BatchSize(size = 5))：运行： 这样就将原来十条sql合并成了两条，提高了效率。 join fetch@Testpublic void testQuery4() { Session session = sf.openSession(); session.beginTransaction(); // List topics = (List)session.createCriteria(Topic.class).list(); List topics = (List)session.createQuery(“from Topic t left join fetch t.category c”).list(); for(Topic t : topics) { System.out.println(t.getId() + &quot;-&quot; + t.getTitle()); } session.getTransaction().commit(); session.close(); } 这样也可以解决1+N问题。 第六十五课. list-iteratelist和iterate不同之处（//主要为了面试 详见hibernate_2900_Hibernate_list_iterate）a) list取所有b) iterate先取 ID,等用到的时候再根据ID来取对象c) session中list第二次发出，仍会到数据库査询d) iterate 第二次，首先找session 级缓存 第六十六课. 一级缓存-二级缓存-查询缓存先来研究一级缓存：123456789101112@Testpublic void testCache1()&#123; Session session = sf.openSession(); session.beginTransaction(); Category c = (Category)session.load(Category.class, 1); System.out.println(c.getName()); Category c2 = (Category)session.load(Category.class, 1); System.out.println(c2.getName()); session.getTransaction().commit(); session.close();&#125; 运行： 发现只发出一次sql查询，由于第二次取的是相同的数据，而且第一次已经存入到一级缓存中，所以第二次没有去数据库去取，而是直接到一级缓存去取。 下面我们研究session：123456789101112131415161718@Testpublic void testCache2()&#123; Session session = sf.openSession(); session.beginTransaction(); Category c = (Category)session.load(Category.class, 1); System.out.println(c.getName()); session.getTransaction().commit(); session.close(); Session session2 = sf.openSession(); session2.beginTransaction(); Category c2 = (Category)session2.load(Category.class, 1); System.out.println(c2.getName()); session2.getTransaction().commit(); session2.close();&#125; 运行： 发现一个session的不能去另外一个session中取数据。 现在我们试图打开二级缓存，让两个session可以使用相同的缓存。i. hibernate.cfg.xml 设定：1234&lt;propertyname= "cache.use_second_level_cache"&gt;true&lt;/property&gt;&lt;propertyname="cache.provider_class"&gt;org.hibernate.cache.EhCacheProvider&lt;/property&gt; ii. @Cache注解(由hibernate扩展提供) 在Category.java里加上：@Cache(usage=CacheConcurrencyStrategy.READ_WRITE)然后我们加入需要的jar包（ehcache-1.2.3.jar及commons-logging-1.0.4.jar包）： 运行： 发现hibernate这一次只发了一次sql，说明二级缓存已经打开，所以两个session可以共用缓存。 总结： 一级缓存和二级缓存和査询缓存（面试题）(详见hibernate_3000_Hibernate_3KindsOf_Cache)a) 什么是缓存b) 什么是一级缓存，session级别的缓存c) 什么是二级缓存，SessionFactory级别的缓存，可以跨越session存在i. 经常被访间ii. 改动不大不会经常改动iii. 数重有限 第六十七课. 查询缓存.查询缓存依赖于二级缓存。 我们打开查询缓存：在hibernate.cfg.xml中加入：&lt;property name=&quot;cache.use_query_cache&quot;&gt;true&lt;/property&gt; 写一个测试程序： 12345678910@Testpublic void testQueryCache()&#123; Session session = sf.openSession(); session.beginTransaction(); List&lt;Category&gt; categories = (List&lt;Category&gt;) session.createQuery("from Category").list(); List&lt;Category&gt; categories2 = (List&lt;Category&gt;) session.createQuery("from Category").list(); session.getTransaction().commit(); session.close();&#125; 我们调用了两个相同的查询，运行： 但是这毕竟是两个相同的查询，为什么不可以使用查询缓存呢？我们在测试程序中打开查询缓存的设置：12List&lt;Category&gt; categories = (List&lt;Category&gt;) session.createQuery("from Category").setCacheable(true).list();List&lt;Category&gt; categories2 = (List&lt;Category&gt;) session.createQuery("from Category").setCacheable(true).list(); 再运行： 发现这一次就只发出了一次sql，说明查询缓存被使用了。 即使我们在两个不同的session中使用相同的查询，如果已经打开了查询缓存，也会只发出一次sql。 缓存算法：（纯为了面试）i. LRU LFU FIFO Least Recently Used –最近很少被使用 Least Frequently Used (命中率高低) First In First Out 按顺序替换 ii. memoryStoreEvictionPolicy = “LRU” (ehcache.xml中配置) 第六十八课. 事务隔离机制-悲观锁-乐观锁-1事务并发处理(面试的意义更大)a) 事务：ACIDi. Atomic Consistency Itegrity Durabilityb) 事务并发时可能出现的问题：第一类丢失更新(Lost Update) dirty read脏读(读到了另一个事务在处理中还未提交的数据) non-repeatable read 不可重复读 second lost update problem 第二类丢失更新(不可重复读的特殊情况) phantom read 幻读 c) 数据库的事务隔离机制i. 查看 java.sql.Connection 文档ii. 1：read-uncommitted 2：read-committed 4：repeatable read 8：serializable（数字代表对应值）为什么取值要使用 1 2 4 8 而不是 1 2 3 41=0001 2=0010 4=0100 8=1000(位移计算效率高) 只要数据库支持事务,就不可能出现第一类丢失更新 read-uncommitted(允许读取未提交的数据) 会出现dirty read, phantom-read,non-repeatable read 问题 read-commited(读取已提交的数据 项目中一般都使用这个)不会出现dirty read,因为只有另一个事务提交才会读出来结果，但仍然会出现 non-repeatable read 和 phantom-read使用read-commited机制可用悲观锁 乐观锁来解决non-repeatable read 和 phantom-read问题 repeatable read(事务执行中其他事务无法执行修改或插入操作 较安全) serializable解决一切问题(顺序执行事务 不并发，实际中很少用) 第六十九课. 事务隔离机制-悲观锁-乐观锁-2d) 设定hibernate的事务隔离级别(使用hibernate.connection.isolation配置 取值1、2、4、8)i. hibernate.connection.isolation = 2（如果不设 默认依赖数据库本身的级别）ii. 用悲观锁解决repeatable read的问题（依赖于数据库的锁）(详见项目 hibernate_3100_Hibernate_Concurrency_Pessimistic_Lock) select … for update 使用另一种load方法–load(xx.class , i , LockMode.Upgrade)a) LockMode.None无锁的机制，Transaction结束时，切换到此模式b) LockMode.read在査询的时候hibernate会自动获取锁c) LockMode.write insert update hibernate 会自动获取锁d) 以上3种锁的模式，是hibernate内部使用的(不需要设)e) LockMode.UPGRADE_NOWAIT是 ORACLE 支持的锁的方式e) Hibernate(JPA)乐观锁定(ReadCommitted)(详见项目hibernate_3200_Hibernate_Concurrency_Optimistic_Lock)实体类中增加version属性(数据库也会对应生成该字段,初始值为0)，并在其get方法前加@Version注解，则在操作过程中没更新一次该行数据则version值加1，即可在事务提交前判断该数据是否被其他事务修改过.@Version 先看悲观锁的代码：先执行testSchemaExport()来创建一个Account表，再执行一个testSave()，存取一个数据：123456789101112@Testpublic void testSave() &#123; Session session = sf.openSession(); session.beginTransaction(); Account a = new Account(); a.setBalance(100); session.save(a); session.getTransaction().commit(); session.close();&#125; 查询数据库： 成功插入一条数据。 然后我们看一个对数据库的操作：12345678910111213@Testpublic void testOperation1() &#123; Session session = sf.openSession(); session.beginTransaction(); Account a = (Account)session.load(Account.class, 1); int balance = a.getBalance(); //do some caculations balance = balance - 10; a.setBalance(balance); session.getTransaction().commit(); session.close();&#125; 这个操作就是将数据库的数据取出来，修改，再存放回去。但是考虑一个问题，如果这个时候，另外一个用户也对数据库进行操作，那么就会被这个操作冲掉数据，导致结果不正确，这个应该怎么解决？悲观锁就是一种解决方案：12345678910111213@Testpublic void testPessimisticLock() &#123; Session session = sf.openSession(); session.beginTransaction(); Account a = (Account)session.load(Account.class, 1, LockMode.UPGRADE); int balance = a.getBalance(); //do some caculation balance = balance - 10; a.setBalance(balance); session.getTransaction().commit(); session.close();&#125; 就是在操作之前，就给这个操作上锁，使得其他对数据库的操作不能往下进行。我们执行一下： 看到在查询数据时加上了一个for update，这其实就是给数据库上了一个悲观锁，使得其他对数据库的更新不能进行。 我们再来看乐观锁：这个代码中，Account类中如此设计：1234567891011121314151617181920212223242526272829@Entitypublic class Account &#123; private int id; private int balance; private int version; @Version public int getVersion() &#123; return version; &#125; public void setVersion(int version) &#123; this.version = version; &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getBalance() &#123; return balance; &#125; public void setBalance(int balance) &#123; this.balance = balance; &#125; &#125; 这里多加了一个version字段，乐观锁在程序运行过程中加锁，如果一个用户对数据库进行了更新，version就加1，然后如果在这个用户更新的同时，另一个用户也对这个数据库的同一条数据进行更新，他在更新后之后要检查version字段，如果和之前的不一样，那么就判定有其他用户对这个数据进行过更新，那么就报错。我们看代码：12345678910111213141516171819202122232425262728@Testpublic void testOptimisticLock() &#123; Session session = sf.openSession(); Session session2 = sf.openSession(); session.beginTransaction(); Account a1 = (Account) session.load(Account.class, 1); session2.beginTransaction(); Account a2 = (Account) session2.load(Account.class, 1); a1.setBalance(900); a2.setBalance(1100); session.getTransaction().commit(); System.out.println(a1.getVersion()); session2.getTransaction().commit(); System.out.println(a2.getVersion()); session.close(); session2.close();&#125; 运行： 发现session2在commit的时候会报错。 乐观锁的执行效率要比悲观锁要高。 第七十课. hibernate总结]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate笔记（七） Hibernate查询]]></title>
    <url>%2F2017%2F12%2F21%2FHibernate7%2F</url>
    <content type="text"><![CDATA[本文主要介绍Hibernate查询，包括HQL，EJBQL，QBC和QBE HQL vs EJBQL NativeSQL &gt; HQL &gt; EJBQL(JPQL 1.0) &gt; QBC(Query By Criteria) &gt; QBE(Query By Example) 总结:QL应该和导航关系结合，共同为查询提供服务。 第六十课. Hibernate查询 HQL-EJBQL-QBC-QBE-2Category.java：12345678910111213141516171819202122232425package com.bjsxt.hibernate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class Category &#123; private int id; private String name; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Msg.java：123456789101112131415161718192021222324252627282930313233343536package com.bjsxt.hibernate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.ManyToOne;@Entitypublic class Msg &#123; private int id; private String cont; private Topic topic; @ManyToOne public Topic getTopic() &#123; return topic; &#125; public void setTopic(Topic topic) &#123; this.topic = topic; &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getCont() &#123; return cont; &#125; public void setCont(String cont) &#123; this.cont = cont; &#125; &#125; MsgInfo.java：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.bjsxt.hibernate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.ManyToOne;public class MsgInfo &#123; //VO DTO Value Object username p1 p2 UserInfo-&gt;User-&gt;DB private int id; private String cont; private String topicName; private String categoryName; public MsgInfo(int id, String cont, String topicName, String categoryName) &#123; super(); this.id = id; this.cont = cont; this.topicName = topicName; this.categoryName = categoryName; &#125; public String getTopicName() &#123; return topicName; &#125; public void setTopicName(String topicName) &#123; this.topicName = topicName; &#125; public String getCategoryName() &#123; return categoryName; &#125; public void setCategoryName(String categoryName) &#123; this.categoryName = categoryName; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getCont() &#123; return cont; &#125; public void setCont(String cont) &#123; this.cont = cont; &#125; &#125; Topic.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.bjsxt.hibernate;import java.util.Date;import javax.persistence.Entity;import javax.persistence.FetchType;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.ManyToOne;@Entitypublic class Topic &#123; private int id; private String title; private Category category; //private Category category2; private Date createDate; public Date getCreateDate() &#123; return createDate; &#125; public void setCreateDate(Date createDate) &#123; this.createDate = createDate; &#125; @ManyToOne(fetch=FetchType.LAZY) public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; &#125; 执行建表语句： 然后我们去存一些数据：123456789101112131415161718192021222324252627282930313233343536373839@Testpublic void testSave() &#123; Session session = sf.openSession(); session.beginTransaction(); for(int i=0; i&lt;10; i++) &#123; Category c = new Category(); c.setName("c" + i); session.save(c); &#125; for(int i=0; i&lt;10; i++) &#123; Category c = new Category(); c.setId(1); Topic t = new Topic(); t.setCategory(c); t.setTitle("t" + i); t.setCreateDate(new Date()); session.save(t); &#125; for(int i=0; i&lt;10; i++) &#123; Topic t = new Topic(); t.setId(1); Msg m = new Msg(); m.setCont("m" + i); m.setTopic(t); session.save(m); &#125; session.getTransaction().commit(); session.close();&#125; 执行效果： 数据被成功插入！ 接下来我们就基于这样的数据做查询。 第一种，QL语言：12345678910111213@Testpublic void testHQL_01() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Category"); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 执行： 成功将Category中插入的十条记录都取出来了。 第二个查询：查询category中名字大于c5的名字：12345678910111213@Testpublic void testHQL_02() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Category c where c.name &gt; 'c5'"); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 执行： 第三个查询：将category的名字倒序输出：12345678910111213@Testpublic void testHQL_03() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Category c order by c.name desc"); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 执行： 第四个查询：这一次我们查询不重复的category，也是按照倒序排列：12345678910111213@Testpublic void testHQL_04() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select distinct c from Category c order by c.name desc"); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 注意输出的SQL语句，是通过id来区分两个记录是否重复： 看第五个查询：我们这一次查询id号大于2且小于8的category：123456789101112131415161718@Test public void testHQL_05() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Category c where c.id &gt; :min and c.id &lt; :max");// q.setParameter("min", 2);// q.setParameter("max", 8); q.setInteger("min", 2); q.setInteger("max", 8); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getId() + "-" + c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 其中:min是一个占位符，可以通过下面的setInteger来设置，也就是将占位符的参数设成了Integer类型。执行： 没问题！ 其实还可以用链式编程方式来写这一段代码：123456789101112131415161718192021 @Test public void testHQL_05() &#123; Session session = sf.openSession(); session.beginTransaction();/* Query q = session.createQuery("from Category c where c.id &gt; :min and c.id &lt; :max");// q.setParameter("min", 2);// q.setParameter("max", 8); q.setInteger("min", 2); q.setInteger("max", 8);*/ Query q = session.createQuery("from Category c where c.id &gt; :min and c.id &lt; :max") .setInteger("min", 2) .setInteger("max", 8); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getId() + "-" + c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 由于setInteger返回的是一个query对象，所以依然可以调用它的setInteger方法，这就是链式编程。 第六个查询，其实是第五个的替代写法：12345678910111213141516@Test public void testHQL_06() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Category c where c.id &gt; ? and c.id &lt; ?"); q.setParameter(0, 2) .setParameter(1, 8);// q.setParameter(1, 8); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getId() + "-" + c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 效果是一样的。 看第七个查询，就是分页：12345678910111213141516//分页@Testpublic void testHQL_07() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Category c order by c.name desc"); q.setMaxResults(4); q.setFirstResult(2); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getId() + "-" + c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 这个查询中，先将所有的category倒序排列，然后我们设定最大结果集是4，从第二条开始查询，也就是7： 第八个查询：这一次我们取出来的不是对象，而是具体的字段，他们存储在List列表的Object数组之中，然后用数组的形式将它们取出打印：12345678910111213@Testpublic void testHQL_08() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select c.id, c.name from Category c order by c.name desc"); List&lt;Object[]&gt; categories = (List&lt;Object[]&gt;)q.list(); for(Object[] o : categories) &#123; System.out.println(o[0] + "-" + o[1]); &#125; session.getTransaction().commit(); session.close(); &#125; 运行： 第九个查询：123456789101112131415//设定fetch type 为lazy后将不会有第二条sql语句@Testpublic void testHQL_09() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Topic t where t.category.id = 1"); List&lt;Topic&gt; topics = (List&lt;Topic&gt;)q.list(); for(Topic t : topics) &#123; System.out.println(t.getTitle()); //System.out.println(t.getCategory().getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 我们执行一下： 由于ManyToOne默认是Eager，所以hibernate在取出topic之后，会把级联的category也取出来，这就是第二个sql语句。 如果我们把ManyToOne改成Lazy（Topic.java）：1234@ManyToOne(fetch=FetchType.LAZY)public Category getCategory() &#123; return category;&#125; 再运行： 这次就不会把category取出来了，也就不执行第二次sql了。 如果将屏蔽的语句System.out.println(t.getCategory().getName());取消屏蔽，那么在lazy情况下也会执行第二条sql，因为用到了category，就回去取。 第十一个查询： 这一次我们多次导航，查询一个版块所有帖子（m.topic.category.id）： 1234567891011121314@Testpublic void testHQL_11() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Msg m where m.topic.category.id = 1"); for(Object o : q.list()) &#123; Msg m = (Msg)o; System.out.println(m.getCont()); &#125; session.getTransaction().commit(); session.close(); &#125; 运行： 由于有导航（一对多、多对一），所以hibernate自己就可以帮我们连接表。 第十二个查询：1234567891011121314151617//了解即可//VO Value Object//DTO data transfer object@Testpublic void testHQL_12() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select new com.bjsxt.hibernate.MsgInfo(m.id, m.cont, m.topic.title, m.topic.category.name) from Msg"); for(Object o : q.list()) &#123; MsgInfo m = (MsgInfo)o; System.out.println(m.getCont()); &#125; session.getTransaction().commit(); session.close(); &#125; 这一次我们将表中数据取出来，组成一个临时对象MsgInfo返回，这个对象就是DTO，是用来传输数据的。 第十三个查询：这一次我们将两张表通过join连接起来，由于已经设了导航，所以不需要再设置连接条件：12345678910111213141516//动手测试left right join//为什么不能直接写Category名，而必须写t.category//因为有可能存在多个成员变量（同一个类），需要指明用哪一个成员变量的连接条件来做连接@Testpublic void testHQL_13() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select t.title, c.name from Topic t join t.category c "); //join Category c for(Object o : q.list()) &#123; Object[] m = (Object[])o; System.out.println(m[0] + "-" + m[1]); &#125; session.getTransaction().commit(); session.close(); &#125; 第六十一课. Hibernate查询-HQL-EJBQL-QBC-QBE-3.12345678910111213141516//学习使用uniqueResult@Testpublic void testHQL_14() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Msg m where m = :MsgToSearch "); //不重要 Msg m = new Msg(); m.setId(1); q.setParameter("MsgToSearch", m); Msg mResult = (Msg)q.uniqueResult(); System.out.println(mResult.getCont()); session.getTransaction().commit(); session.close(); &#125; 这一次我们查询语句直接让一个对象等于一个参数，这个参数我们动态设置，通过setParameter来设置，然后两个对象通过hashcode和equals来进行比较。最终用uniqueResult来返回查到的结果。 第十五个查询： 这次我们使用聚合函数count(*)，来查询一共有多少Msg： 123456789101112@Testpublic void testHQL_15() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select count(*) from Msg m"); long count = (Long)q.uniqueResult(); System.out.println(count); session.getTransaction().commit(); session.close(); &#125; 第十六个查询：这次我们依然使用聚合函数，返回一个对象数组，然后依次将其拿出来打印： 123456789101112@Testpublic void testHQL_16() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select max(m.id), min(m.id), avg(m.id), sum(m.id) from Msg m"); Object[] o = (Object[])q.uniqueResult(); System.out.println(o[0] + "-" + o[1] + "-" + o[2] + "-" + o[3]); session.getTransaction().commit(); session.close(); &#125; 第十七、十八、十九个查询： 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Testpublic void testHQL_17() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Msg m where m.id between 3 and 5"); for(Object o : q.list()) &#123; Msg m = (Msg)o; System.out.println(m.getId() + "-" + m.getCont()); &#125; session.getTransaction().commit(); session.close(); &#125;@Testpublic void testHQL_18() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Msg m where m.id in (3,4, 5)"); for(Object o : q.list()) &#123; Msg m = (Msg)o; System.out.println(m.getId() + "-" + m.getCont()); &#125; session.getTransaction().commit(); session.close(); &#125;//is null 与 is not null@Testpublic void testHQL_19() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Msg m where m.cont is not null"); for(Object o : q.list()) &#123; Msg m = (Msg)o; System.out.println(m.getId() + "-" + m.getCont()); &#125; session.getTransaction().commit(); session.close(); &#125; 上面就是HQL的语法。 第六十二课. Hibernate查询-HQL-EJBQL-QBC-QBE-4 第二十个查询： 查询没有帖子的Topic：123456789101112131415//is empty and is not empty@Testpublic void testHQL_20() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Topic t where t.msgs is empty"); for(Object o : q.list()) &#123; Topic t = (Topic)o; System.out.println(t.getId() + "-" + t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125; 第二十一个查询： 查询名字中有零个或者多个5的Topic（%代表零个或者多个，_代表一个或者多个）： 1234567891011121314@Testpublic void testHQL_21() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Topic t where t.title like '%5'"); for(Object o : q.list()) &#123; Topic t = (Topic)o; System.out.println(t.getId() + "-" + t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125; 第二十三个查询： 1234567891011121314151617181920//不重要@Testpublic void testHQL_23() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select lower(t.title)," + "upper(t.title)," + "trim(t.title)," + "concat(t.title, '***')," + "length(t.title)" + " from Topic t "); for(Object o : q.list()) &#123; Object[] arr = (Object[])o; System.out.println(arr[0] + "-" + arr[1] + "-" + arr[2] + "-" + arr[3] + "-" + arr[4] + "-"); &#125; session.getTransaction().commit(); session.close(); &#125; 第二十四个查询：用到了数学的函数：1234567891011121314151617@Testpublic void testHQL_24() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select abs(t.id)," + "sqrt(t.id)," + "mod(t.id, 2)" + " from Topic t "); for(Object o : q.list()) &#123; Object[] arr = (Object[])o; System.out.println(arr[0] + "-" + arr[1] + "-" + arr[2] ); &#125; session.getTransaction().commit(); session.close(); &#125; 第二十五个查询： 我们设想一个场景，就是在集群环境下，多台服务器都围绕着一个数据库做操作，那么这时用服务器自己的时间就会不统一，最好的办法是使用数据库的时间： 1234567891011121314@Testpublic void testHQL_25() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select current_date, current_time, current_timestamp, t.id from Topic t"); for(Object o : q.list()) &#123; Object[] arr = (Object[])o; System.out.println(arr[0] + " | " + arr[1] + " | " + arr[2] + " | " + arr[3]); &#125; session.getTransaction().commit(); session.close(); &#125; 运行： 第二十六个查询： 1234567891011121314@Testpublic void testHQL_26() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Topic t where t.createDate &lt; :date"); q.setParameter("date", new Date()); for(Object o : q.list()) &#123; Topic t = (Topic)o; System.out.println(t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125; 第二十七个查询：使用group by： 123456789101112131415161718192021222324252627@Testpublic void testHQL_27() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select t.title, count(*) from Topic t group by t.title") ; for(Object o : q.list()) &#123; Object[] arr = (Object[])o; System.out.println(arr[0] + "|" + arr[1]); &#125; session.getTransaction().commit(); session.close(); &#125;@Testpublic void testHQL_28() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("select t.title, count(*) from Topic t group by t.title having count(*) &gt;= 1") ; for(Object o : q.list()) &#123; Object[] arr = (Object[])o; System.out.println(arr[0] + "|" + arr[1]); &#125; session.getTransaction().commit(); session.close(); &#125; 第二十九个查询：使用子查询： 12345678910111213@Testpublic void testHQL_29() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Topic t where t.id &lt; (select avg(t.id) from Topic t)") ; for(Object o : q.list()) &#123; Topic t = (Topic)o; System.out.println(t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125; 第三十个查询： 12345678910111213@Testpublic void testHQL_30() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.createQuery("from Topic t where t.id &lt; ALL (select t.id from Topic t where mod(t.id, 2)= 0) ") ; for(Object o : q.list()) &#123; Topic t = (Topic)o; System.out.println(t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125; &lt;All代表小于取出来所有值，也就是小于2、4、6、8等等所有取出来的值。没什么用 第三十一个查询： 12345678910111213141516 //用in 可以实现exists的功能 //但是exists执行效率高 @Test public void testHQL_31() &#123; Session session = sf.openSession(); session.beginTransaction();// t.id not in (1) Query q = session.createQuery("from Topic t where not exists (select m.id from Msg m where m.topic.id=t.id)") ;// Query q = session.createQuery("from Topic t where exists (select m.id from Msg m where m.topic.id=t.id)") ; for(Object o : q.list()) &#123; Topic t = (Topic)o; System.out.println(t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125; 第三十三个查询：用命名查询： 在Topic.java上加上：123456@Entity@NamedQueries( &#123; @NamedQuery(name="topic.selectCertainTopic", query="from Topic t where t.id = :id") &#125; ) 然后在测试代码中直接使用这一段已经命名的查询： 12345678910111213//不重要@Testpublic void testHQL_33() &#123; Session session = sf.openSession(); session.beginTransaction(); Query q = session.getNamedQuery("topic.selectCertainTopic"); q.setParameter("id", 5); Topic t = (Topic)q.uniqueResult(); System.out.println(t.getTitle()); session.getTransaction().commit(); session.close(); &#125; 第三十四个查询： 使用本地Sql: 1234567891011121314//Native（了解）@Testpublic void testHQL_34() &#123; Session session = sf.openSession(); session.beginTransaction(); SQLQuery q = session.createSQLQuery("select * from category limit 2,4").addEntity(Category.class); List&lt;Category&gt; categories = (List&lt;Category&gt;)q.list(); for(Category c : categories) &#123; System.out.println(c.getName()); &#125; session.getTransaction().commit(); session.close(); &#125; 将category表中取出的结果转化成Category对象。 以上就是HQL语句的所有例子，遇到不明白的就可以到上面查询。 第六十三课. Hibernate查询 HQL-EJBQL-QBC-QBE-5QBE是QBC的一个子集。 先来看QBC的测试代码：12345678910111213141516171819202122@Testpublic void testQBC() &#123; Session session = sf.openSession(); session.beginTransaction(); //criterion 标准/准则/约束 Criteria c = session.createCriteria(Topic.class) //from Topic .add(Restrictions.gt("id", 2)) //greater than = id &gt; 2 .add(Restrictions.lt("id", 8)) //little than = id &lt; 8 .add(Restrictions.like("title", "t_")) .createCriteria("category") .add(Restrictions.between("id", 3, 5)) //category.id &gt;= 3 and category.id &lt;=5 ; //DetachedCriterea for(Object o : c.list()) &#123; Topic t = (Topic)o; System.out.println(t.getId() + "-" + t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125; Criteria就是一个可以让查询语言更像面向对象语言的解决方案，那么上面一个测试代码生成的sql语句就是： 发现其实上面的语句是连接了两张表的。 Criteria是与具体的session关联的，DetachedCriterea可以先创建，创建好之后再与session连接，更具有灵活性。 下面来看QBE,也就是Query By Example（通过例子查询）: 12345678910111213141516171819202122232425//query by criteria query by example@Testpublic void testQBE() &#123; Session session = sf.openSession(); session.beginTransaction(); Topic tExample = new Topic(); tExample.setTitle("T_"); Example e = Example.create(tExample) .ignoreCase().enableLike(); Criteria c = session.createCriteria(Topic.class) .add(Restrictions.gt("id", 2)) .add(Restrictions.lt("id", 8)) .add(e) ; for(Object o : c.list()) &#123; Topic t = (Topic)o; System.out.println(t.getId() + "-" + t.getTitle()); &#125; session.getTransaction().commit(); session.close(); &#125;]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate笔记（六） 集合映射、继承映射、树状映射和作业设计]]></title>
    <url>%2F2017%2F12%2F21%2FHibernate6%2F</url>
    <content type="text"><![CDATA[本文主要介绍集合映射、继承映射、树状映射和作业设计。关系映射总结 什么样的关系，设计什么样的表，进行什么样的映射 CRUD,按照自然的理解即可（动手测试） 第五十三课. 集合映射(不太重要)以前我们使用Set来存储一组User，现在我们使用List来存储，因为很多时候我们存储的对象需要排序，那么List是支持排序的。 在Group.java中进行修改：12345678910111213private List&lt;User&gt; users = new ArrayList&lt;User&gt;();@OneToMany(mappedBy = "group", cascade = &#123;CascadeType.ALL&#125;)@OrderBy("name ASC")public List&lt;User&gt; getUsers() &#123; return users;&#125;public void setUsers(List&lt;User&gt; users) &#123; this.users = users;&#125; 发现只是将类型从Set改成了List，其他都没变。另外我们在getUsers这个方法前加上注解:@OrderBy(&quot;name ASC&quot;)这样就会按照User的name来升序排列。 已经验证过了List，我们再来验证Map。 修改User的存储方式，用Map来存储：12345678910private Map&lt;Integer , User&gt; users = new HashMap&lt;Integer, User&gt;();@OneToMany(mappedBy = "group", cascade = CascadeType.ALL)@MapKey(name = "id")public Map&lt;Integer, User&gt; getUsers() &#123; return users;&#125;public void setUsers(Map&lt;Integer, User&gt; users) &#123; this.users = users;&#125; 向数据库中手动插入一些数据： 测试程序： 123456789101112@Testpublic void testLoadGroup()&#123; Session s = sessionFactory.getCurrentSession(); s.beginTransaction(); Group g = (Group)s.load(Group.class, 1); for (Map.Entry&lt;Integer, User&gt; entry : g.getUsers().entrySet())&#123; System.out.println(entry.getValue().getName()); &#125; s.getTransaction().commit();&#125; 结果： 两个用户名被成功打印了出来！ 上面就是两种集合映射的方式，不是特别重要，了解即可。 第五十五课. 继承映射（不太重要）继承映射有三种方式：a) 一张总表SINGLE-TABLEb) 每个类分别一张表TABLE-PER-CLASSc) 每个子类一张表jOINED 我们先来看第一种方式，也就是Single-table：先设计一个Person类：1234567891011121314151617181920212223242526272829303132333435package com.bjsxt.hibernate;import javax.persistence.DiscriminatorColumn;import javax.persistence.DiscriminatorType;import javax.persistence.DiscriminatorValue;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Inheritance;import javax.persistence.InheritanceType;@Entity@Inheritance(strategy=InheritanceType.SINGLE_TABLE)@DiscriminatorColumn(name="discriminator", discriminatorType=DiscriminatorType.STRING)@DiscriminatorValue("person")public class Person &#123; private int id; private String name; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 再从Person上继承两个类：Teacher和Student，它们分别使用DiscriminatorValue注解来区分：Teacher.java：1234567891011121314151617181920package com.bjsxt.hibernate;import javax.persistence.DiscriminatorValue;import javax.persistence.Entity;@Entity@DiscriminatorValue("teacher")public class Teacher extends Person &#123; private String title; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; &#125; Student.java：1234567891011121314151617181920package com.bjsxt.hibernate;import javax.persistence.DiscriminatorValue;import javax.persistence.Entity;@Entity@DiscriminatorValue("student")public class Student extends Person &#123; private int score; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; &#125; 运行看效果： 发现不管是老师还是学生，它们都存储在Person这张表，并且通过一个discriminator字段来区分。 尝试去load一下：1234567891011121314@Testpublic void testLoad() &#123; testSave(); Session session = sessionFactory.openSession(); session.beginTransaction(); Student s = (Student)session.load(Student.class, 1); System.out.println(s.getScore()); Person p = (Person)session.load(Person.class, 2); System.out.println(p.getName()); session.getTransaction().commit(); session.close(); &#125; 执行： 发现你去load一个父类的Person对象，也可以打印出对应的信息。 接下来我们看第二种继承映射：每个类分别一张：TABLE-PER-CLASS 先设计Person类：1234567891011121314151617181920212223242526272829303132333435363738394041package com.bjsxt.hibernate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.Inheritance;import javax.persistence.InheritanceType;import javax.persistence.TableGenerator;@Entity@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)@TableGenerator( name="t_gen", table="t_gen_table", pkColumnName="t_pk", valueColumnName="t_value", pkColumnValue="person_pk", initialValue=1, allocationSize=1 )public class Person &#123; private int id; private String name; @Id @GeneratedValue(generator="t_gen", strategy=GenerationType.TABLE) public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 然后从Person继承两个类，就是Teacher和Student，只需要在类前加@Entity注释就可以了：Student.java：123456789101112131415161718package com.bjsxt.hibernate;import javax.persistence.Entity;@Entitypublic class Student extends Person &#123; private int score; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; &#125; Teacher.java：1234567891011121314151617package com.bjsxt.hibernate;import javax.persistence.Entity;@Entitypublic class Teacher extends Person &#123; private String title; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; &#125; 执行方法来存储一些Teacher和Student对象试试：12345678910111213141516@Testpublic void testSave() &#123; Student s = new Student(); s.setName("s1"); s.setScore(80); Teacher t = new Teacher(); t.setName("t1"); t.setTitle("中级"); Session session = sessionFactory.openSession(); session.beginTransaction(); session.save(s); session.save(t); session.getTransaction().commit(); session.close();&#125; 执行： 发现每一个类都生成了自己的表，插入的时候，Teacher的对象就插到Teacher表，Student对象就插到Student表。 再试试read：12345678910111213@Testpublic void testLoad() &#123; testSave(); Session session = sessionFactory.openSession(); session.beginTransaction(); Student s = (Student)session.load(Student.class, 1); System.out.println(s.getScore()); Person p = (Person)session.load(Person.class, 2); System.out.println(p.getName()); session.getTransaction().commit(); session.close(); &#125; 效果： 发现它的查找过程十分有趣，是把所有的表都union成一张总表，也就是回归到第一种方式，然后根据给出的查询条件进行查询。所以它的查询不是特别方便。 看第三种方式，也就是每个子类一张表，即jOINED： 这种方式就是创建一个主表，存放子类共同的字段；字表只存放与众不同的字段。Person.java：12345678910111213141516171819202122232425262728293031package com.bjsxt.hibernate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Inheritance;import javax.persistence.InheritanceType;@Entity@Inheritance(strategy=InheritanceType.JOINED)public class Person &#123; private int id; private String name; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Student.java：123456789101112131415161718package com.bjsxt.hibernate;import javax.persistence.Entity;@Entitypublic class Student extends Person &#123; private int score; public int getScore() &#123; return score; &#125; //Person p = Person(load(1)); public void setScore(int score) &#123; this.score = score; &#125; &#125; Teacher.java：123456789101112131415161718package com.bjsxt.hibernate;import javax.persistence.Entity;@Entitypublic class Teacher extends Person &#123; private String title; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; &#125; 运行一下测试代码：12345678910111213141516@Testpublic void testSave() &#123; Student s = new Student(); s.setName("s1"); s.setScore(80); Teacher t = new Teacher(); t.setName("t1"); t.setTitle("中级"); Session session = sessionFactory.openSession(); session.beginTransaction(); session.save(s); session.save(t); session.getTransaction().commit(); session.close();&#125; 运行： 发现字表的id参考主表的id。 插入的时候需要向两张表来插入：先插入到主表，然后插入到子表。 我们试一下读取对象：12345678910111213@Testpublic void testLoad() &#123; testSave(); Session session = sessionFactory.openSession(); session.beginTransaction(); Student s = (Student)session.load(Student.class, 1); System.out.println(s.getScore()); Person p = (Person)session.load(Person.class, 2); System.out.println(p.getName()); session.getTransaction().commit(); session.close(); &#125; 运行： 发现和第二种比较相似，是把所有表联合在一起，但是区别在于这一次我们用了case when。 第三种方式比较常用，第二种最不常用。总体来说，继承映射不太常用。 第五十六课. 树状映射需求：a) 在同—个类中使用One2Many和Many20ne 我们设计一个公司类Org，具体关系为： parent_id也就是一个Org的父亲Org。 所以模型设计如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.bjsxt.hibernate;import javax.persistence.*;import java.util.HashSet;import java.util.Set;@Entitypublic class Org &#123; private int id; private String name; private Set&lt;Org&gt; children = new HashSet&lt;Org&gt;(); private Org parent; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @OneToMany(cascade = CascadeType.ALL, mappedBy = "parent", fetch = FetchType.EAGER) public Set&lt;Org&gt; getChildren() &#123; return children; &#125; public void setChildren(Set&lt;Org&gt; children) &#123; this.children = children; &#125; @ManyToOne @JoinColumn(name = "parent_id") public Org getParent() &#123; return parent; &#125; public void setParent(Org parent) &#123; this.parent = parent; &#125;&#125; 也就是说，一个Org对应多个子Org，也就是和children的关系是OneToMany；而对应于父亲Org的关系是ManyToOne。这里要注意getParent方法上面的注解：@JoinColumn(name = “parent_id”)这个注解使得我们的Org生成了parent_id字段，这个字段参考的是其父Org的主键字段。另外还需要注意的是，我们在OneToMany那里设置的注解，是fetch = FetchType.EAGER所以当我们取出一个根Org的时候，会将所有子Org和级联的子Org都取出来。 写个测试程序测试一下，先插入一些数据，设置它们的关系：123456789101112131415161718192021222324252627282930@Testpublic void testSave() &#123; Org o = new Org(); o.setName("总公司"); Org o1 = new Org(); o1.setName("分公司1"); Org o2 = new Org(); o2.setName("分公司2"); Org o11 = new Org(); o11.setName("分公司1下部门1"); Org o12 = new Org(); o12.setName("分公司1下部门2"); o.getChildren().add(o1); o.getChildren().add(o2); o1.getChildren().add(o11); o2.getChildren().add(o12); o11.setParent(o1); o12.setParent(o1); o1.setParent(o); o2.setParent(o); Session session = sessionFactory.openSession(); session.beginTransaction(); session.save(o); session.getTransaction().commit(); session.close();&#125; 查询数据库： 成功插入！ 接下来我们树状打印，老规矩，递归树状打印：1234567891011121314151617181920212223@Testpublic void testLoad() &#123; testSave(); Session session = sessionFactory.openSession(); session.beginTransaction(); Org o = (Org)session.load(Org.class, 1); print(o, 0); session.getTransaction().commit(); session.close(); &#125;private void print(Org o, int level) &#123; String preStr = ""; for (int i = 0; i &lt; level; i++) preStr += "----"; System.out.println(preStr + o.getName()); for (Org child : o.getChildren())&#123; print(child, level + 1); &#125;&#125; 打印效果： 很成功！ 如果我们把fetch方式改成Lazy，又会是什么样的？ 这一次，是取到某个对象以后，才会从数据库来取。 第五十七课. 作业解答 Student-Course-Score-1 学生课程、分数的设计(重要)a) 使用联合主键@Embeddedldi. 实现 Serializable 接口b) 不使用联合主键 设计：a) 实体类（表）b) 导航（编程方便）c) 确定了编程方式 下面我们就来着手设计这个小项目：Student.java：1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.bjsxt.hibernate;import javax.persistence.*;import java.util.HashSet;import java.util.Set;@Entitypublic class Student &#123; private int id; private String name; private Set&lt;Course&gt; courses = new HashSet&lt;Course&gt;(); @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @ManyToMany @JoinTable(name = "score", joinColumns = @JoinColumn(name="student_id"), inverseJoinColumns = @JoinColumn(name = "course_id") ) public Set&lt;Course&gt; getCourses() &#123; return courses; &#125; public void setCourses(Set&lt;Course&gt; courses) &#123; this.courses = courses; &#125;&#125; Course.java：12345678910111213141516171819202122232425262728293031package com.bjsxt.hibernate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class Course &#123; private int id; private String name; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Score.java：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.bjsxt.hibernate;import javax.persistence.*;@Entity@Table(name = "score")public class Score &#123; private int id; private int score; private Student student; private Course course; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; @ManyToOne @JoinColumn(name = "student_id") public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125; @ManyToOne @JoinColumn(name = "course_id") public Course getCourse() &#123; return course; &#125; public void setCourse(Course course) &#123; this.course = course; &#125;&#125; 先来建表： 这里有点问题，就是创建score表的时候，把student_id设置为了auto_increment，我们应该删掉这个表，自己手动建： 将id设置为auto_increment测试存储对象： 12345678910111213141516171819@Testpublic void testSave()&#123; Student s = new Student(); s.setName("zhangsan"); Course c = new Course(); c.setName("java"); Score score = new Score(); score.setCourse(c); score.setStudent(s); Session session = sessionFactory.openSession(); session.beginTransaction(); session.save(s); session.save(c); session.save(score); session.getTransaction().commit(); session.close();&#125; 运行（注意要把@before里面的建表语句去掉）： 没问题。 我们load一下试试：1234567891011121314@Testpublic void testLoad()&#123; testSave(); Session session = sessionFactory.openSession(); session.beginTransaction(); Student s = (Student)session.load(Student.class, 3); for (Course c : s.getCourses())&#123; System.out.println(c.getName()); &#125; session.getTransaction().commit(); session.close();&#125; 运行： OK了！]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate笔记（五） 关联关系的CRUD]]></title>
    <url>%2F2017%2F12%2F21%2FHibernate5%2F</url>
    <content type="text"><![CDATA[本文主要介绍针对关联关系的CRUD。 第四十七课.关联关系的CRUD Cascade Fetch 1User.java：1234567891011121314151617181920212223242526272829303132333435363738package com.bjsxt.hibernate;import javax.persistence.*;@Entity@Table(name = "t_user")public class User &#123; private int id; private String name; private Group group; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @ManyToOne(cascade = &#123;CascadeType.ALL&#125;) public Group getGroup() &#123; return group; &#125; public void setGroup(Group group) &#123; this.group = group; &#125;&#125; Group.java：12345678910111213141516171819202122232425262728293031323334353637383940package com.bjsxt.hibernate;import javax.persistence.*;import java.util.HashSet;import java.util.Set;@Entity@Table(name = "t_group")public class Group &#123; private int id; private String name; private Set&lt;User&gt; users = new HashSet&lt;User&gt;(); @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @OneToMany(mappedBy = "group") public Set&lt;User&gt; getUsers() &#123; return users; &#125; public void setUsers(Set&lt;User&gt; users) &#123; this.users = users; &#125;&#125; HibernateORMappingTest.java：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.bjsxt.hibernate;import java.util.Date;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.AnnotationConfiguration;import org.hibernate.tool.hbm2ddl.SchemaExport;import org.junit.AfterClass;import org.junit.BeforeClass;import org.junit.Test;public class HibernateORMappingTest &#123; private static SessionFactory sessionFactory; @BeforeClass public static void beforeClass() &#123; new SchemaExport(new AnnotationConfiguration().configure()).create(false, true); sessionFactory = new AnnotationConfiguration().configure().buildSessionFactory(); &#125; @AfterClass public static void afterClass() &#123; sessionFactory.close(); &#125; @Test public void testSchemaExport() &#123; new SchemaExport(new AnnotationConfiguration().configure()).create(false, true); &#125; @Test public void testSaveUser()&#123; User u = new User(); u.setName("u1"); Group g = new Group(); g.setName("g1"); u.setGroup(g); Session s = sessionFactory.getCurrentSession(); s.beginTransaction();// s.save(g); s.save(u); s.getTransaction().commit(); &#125; public static void main(String[] args) &#123; beforeClass(); &#125;&#125; 运行： 看一下数据库： 发现我们没有执行s.save(g)这个操作，只是设置了g，然后存储了u，但是hibernate自动帮我们存储g，其实这就是因为我们设置了：@ManyToOne(cascade = {CascadeType.ALL})也就是级联，由于User和Group之间存在多对一的关系，所以每当我们存储一个User的时候，由于级联，对应的Group也会被自动存储。 CascadeType取值 ALL Cascade all operations所有情况 MERGE Cascade merge operation合并(merge=save+update) PERSIST Cascade persist operation存储 persist() REFRESH Cascade refresh operation刷新 REMOVE Cascade remove operation删除 cascade仅仅是帮我们省了编程的麻烦而已，不要把它的作用看的太大Cascade的属性是数组格式，指明做什么操作的时候关联对象是绑在一起的 第四十八课. 关联关系的CRUD Cascade Fetch 2上一节我们存储了User，Group会一并存储进数据库，那么现在我们存储Group，User会不会也一并存储呢？ 我们来做实验：在HibernateORMapping.java中加入：12345678910111213141516 @Test public void testSaveGroup()&#123; User u1 = new User(); u1.setName("u1"); User u2 = new User(); u2.setName("u2"); Group g = new Group(); g.setName("g1"); g.getUsers().add(u1); g.getUsers().add(u2); Session s = sessionFactory.getCurrentSession(); s.beginTransaction();// s.save(g); s.save(g); s.getTransaction().commit(); &#125; 现在两个User都是transient状态，然后我们创建一个Group，将这两个User加入Group，然后save这个Group，看结果： 发现只是将Group插入数据库，但是没有插入User。 究其原因，是因为在ManyToOne这一段是有设置Cascade级联，但是在OneToMany这一段并没有设置。我们重新设置：（Group.java）：123456@OneToMany(mappedBy = "group", cascade = &#123;CascadeType.ALL&#125;)public Set&lt;User&gt; getUsers() &#123; return users;&#125; 运行： 发现这一次把两个User也插入到数据库里面去了。我们看一下数据库： 很糟糕，两个User是被插入了，但是它们的group_id是空值。 这个原因是由于我们在设置User的时候，没有设置它们的group，重新来写：123456789101112131415161718 @Test public void testSaveGroup()&#123; User u1 = new User(); u1.setName("u1"); User u2 = new User(); u2.setName("u2"); Group g = new Group(); g.setName("g1"); g.getUsers().add(u1); g.getUsers().add(u2); u1.setGroup(g); u2.setGroup(g); Session s = sessionFactory.getCurrentSession(); s.beginTransaction();// s.save(g); s.save(g); s.getTransaction().commit(); &#125; 查看数据库： 没问题了！ 铁律：双向关系在程序中要设定双向关联 铁律：双向mappedBy 刚刚试了插入的级联，我们现在再测试一下，取一个对象的操作，看看能不能级联：12345678910@Testpublic void testGetUser()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction(); User u = (User)s.get(User.class, 1); s.getTransaction().commit();&#125; 运行： 发现将User和对应的Group都取了出来。 刚刚是在cascade设了级联的情况，现在把ManyToOne这一端的cascade删除了，再测试： OK，还是可以的。这说明ManyToOne默认情况下会把对应的One那一方取出来。 我们已经试过了多对一这一方的读取，再来试一下一对多的读取。就是说，如果我们读取一个Group，会将与它关联的User都取出来吗？测试代码：12345678910@Testpublic void testGetGroup()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction(); Group g = (Group) s.get(Group.class, 1); s.getTransaction().commit();&#125; 运行： 发现只是将id号为1的Group取了出来，并没有取User。 我们不是已经设置了Cascade了吗？注意：cascade只是负责CUD，R，也就是读取，和cascade没有关系。读取与另外一个参数有关系，就是fetch 我们查阅文档知道fetch返回值是一个Enum类型的，有两个选项：Eager和Lazy OneToMany这一端默认是Lazy，我们设置成Eager试一下：Group.java：1234567@OneToMany(mappedBy = "group", cascade = &#123;CascadeType.ALL&#125;, fetch = FetchType.EAGER)public Set&lt;User&gt; getUsers() &#123; return users;&#125; 并且在测试程序中，将获取到的Group对象中包括的User名字都打印出来：12345678910111213@Testpublic void testGetGroup()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction(); Group g = (Group) s.get(Group.class, 1); s.getTransaction().commit(); for (User u : g.getUsers())&#123; System.out.println(u.getName()); &#125;&#125; 运行： 发现Group中包括的User都被成功取出来了！ 第四十九课. 关联关系的CRUD Cascade Fetch 3刚刚试了OneToMany的fetch，那么ManyToOne的默认应该是Eager了，我们试着将它设置成Lazy，看看什么情况： 1234@ManyToOne(fetch = FetchType.LAZY)public Group getGroup() &#123; return group;&#125; 运行试一下： 果然，只取了User。那么什么时候会将Group取出来呢？我们修改测试程序：1234567891011@Testpublic void testGetUser()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction(); User u = (User)s.get(User.class, 1); System.out.println(u.getGroup().getName()); s.getTransaction().commit();&#125; 也就是当我们取出User之后，将User的Group取出来打印，运行看结果： 发现可以成功取出！ 但是如果我们将打印语句放在commit之后： 发现会报错，原因在于我们是Lazy的fetch，所以Commit之后，就没有Session了，因而取不出User。但为什么之前的OneToMany那一边就可以？因为那里已经设置了Eager的fetch，也就是说，不论有没有Session，都已经将User都取出来了，所以不需要再到数据库去取，从而也就不需要session了。 load和get效果一样。 我们再把ManyToOne后面的fetch去掉，也就是回到Eager，再重新测试，结果： 发现从数据库中取了两次User，这就告诉我们，在设计多对一和一对多的时候，不要两端同时Eager，其实默认的JPA的设计就很好，也就是ManyToOne是Eager，OneToMany是Lazy。（这个可以这么理解，如果我们写一个BBS，一个版块中有很多帖子，如果每一次我们每加载一个版块，如果采取Eager，那么就会把所有帖子都拿出来加载，这个肯定是不现实的）。 第五十课. 关联关系的CRUD Cascade Fetch 4我们把ManyToOne的cascade改成ALL：1234@ManyToOne(cascade = &#123;CascadeType.ALL&#125;)public Group getGroup() &#123; return group;&#125; 测试程序：1234567891011121314151617181920@Testpublic void testUpdateUser()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction(); User u = (User)s.get(User.class, 1); s.getTransaction().commit(); u.setName("user"); u.getGroup().setName("group"); Session s2 = sessionFactory.getCurrentSession(); s2.beginTransaction(); s2.update(u); s2.getTransaction().commit(); &#125; 运行之后结果： 发现不光给我们的User做了更新，还给Group做了更新。 但是我们如果用了其他的cascade参数，并不会都更新，比如我们设置：1234@ManyToOne(cascade = &#123;CascadeType.MERGE, CascadeType.PERSIST&#125;)public Group getGroup() &#123; return group;&#125; 运行后发现，只更新了User，并没有更新Group： 但如果测试程序中update(u)改成merge(u)，就可以。 再比如我们想测试persist的用法：1234567891011121314151617181920212223 @Test public void testUpdateUser()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction();// User u = (User)s.get(User.class, 1); s.getTransaction().commit(); User u = new User(); u.setName("user"); Group g = new Group(); g.setName("g2"); u.setGroup(g); Session s2 = sessionFactory.getCurrentSession(); s2.beginTransaction(); s2.persist(u); s2.getTransaction().commit(); &#125; 运行之后发现，是会将创建好的User和与其级联的Group一并插入到数据库的： 第五十一课. 关联关系的CRUD Cascade Fetch 5我们来测试删除User：1234567891011@Testpublic void testDeleteUser()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction(); User u = (User)s.load(User.class, 1); s.delete(u); s.getTransaction().commit();&#125; 执行后发现User表和Group表都被删除了。原因在于我们在ManyToOne和OneToMany两端都设置了CascadeType.ALL，也就是在删除时候也会执行级联操作，所以连带着，把两张表都删除了。 这显然不是我们想要的，如果我们只想把一个User删除，怎么做？修改代码：123456789101112@Testpublic void testDeleteUser()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction(); User u = (User)s.load(User.class, 1); u.setGroup(null); s.delete(u); s.getTransaction().commit();&#125; 也就是把这个User的Group设成null，这样就不存在级联关系了，这样再执行，就只会删除这一个User了。 或者我们可以使用HQL或者EJBQL也可以做到：12345678910111213 @Test public void testDeleteUser()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction();// User u = (User)s.load(User.class, 1);// u.setGroup(null);// s.delete(u); s.createQuery("delete from User u where u.id = 1").executeUpdate(); s.getTransaction().commit(); &#125; 这次再查看数据库： 没问题，顺利解决。 其实实际工作中，我们使用EJBQL或者HQL比较多。 第五十二课.关联关系的CRUD Cascade Fetch 6上一次我们删User，会连带着把Group删掉，最后就没有数据了。这一次我们删Group，看看怎么样？ 测试程序：123456789101112131415 @Test public void testDeleteGroup()&#123; testSaveGroup(); Session s = sessionFactory.getCurrentSession(); s.beginTransaction();// User u = (User)s.load(User.class, 1);// u.setGroup(null);// s.delete(u); Group g = (Group)s.load(Group.class, 1); s.delete(g);// s.createQuery("delete from User u where u.id = 1").executeUpdate(); s.getTransaction().commit(); &#125; 运行： 看数据库： 也就是说，把所有的表都删除了。 所以还是因为cascade的原因，如果只想删除group，把级联的user的id设置为null，我们还可以用HQL或者EJBQL来控制。 也就是说，如果想消除关联关系，先设定关系为null，再删除对应记录。如果不删记录，该记录变成垃圾数据]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate笔记（四） 关系映射]]></title>
    <url>%2F2017%2F12%2F21%2FHibernate4%2F</url>
    <content type="text"><![CDATA[本文主要介绍hibernate中的关系映射。 关系映射对象之间的关系 这里的关系映射指的是对象之间的关系，并不是指数据库的关系，本章解决的问题是当对象之间处于下列关系之一时，数据库表该如何映射，编程上该如何对待(红色为重点) 简化问题：a) 怎么写 Annotationb) 增删改査CRUD怎么写 —对一a) 单向（主键、外键）b) 双向（主键、外键）c) 中间表 —对多a) 一张主表，多张子表 组件映射a) @Embeddable@ Embedded 第三十五课. 一对一单向外键关联 annotation.丈夫和妻子的关系就是一个典型的一对一的关联关系。 Wife.java：123456789101112131415161718192021222324252627282930package com.bjsxt.hibernate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class Wife &#123; private int id; private String name; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Husband.java：12345678910111213141516171819202122232425262728293031323334353637383940package com.bjsxt.hibernate;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.OneToOne;@Entitypublic class Husband &#123; private int id; private String name; private Wife wife; @OneToOne public Wife getWife() &#123; return wife; &#125; public void setWife(Wife wife) &#123; this.wife = wife; &#125; @Id @GeneratedValue public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 上面的代码中，Husband类中加入了一个Wife的引用，并且在get方法之前加上注解@OneToOne，这样就会生成一对一的关系表。 另外我们需要在hibernate.cfg.xml中对这两个类进行配置：12&lt;mapping class="com.bjsxt.hibernate.Husband"/&gt;&lt;mapping class="com.bjsxt.hibernate.Wife"/&gt; HibernateORMappingTest.java： 123456789101112131415161718192021public class HibernateORMappingTest &#123; private static SessionFactory sessionFactory; // @BeforeClass public static void beforeClass() &#123; sessionFactory = new AnnotationConfiguration().configure().buildSessionFactory(); &#125;// @AfterClass public static void afterClass() &#123; sessionFactory.close(); &#125; @Test public void testSchemaExport() &#123; new SchemaExport(new AnnotationConfiguration().configure()).create(false, true); &#125; public static void main(String[] args) &#123; beforeClass(); &#125;&#125; 运行看控制台生成的建表语句： 发现在Husband内部生成了一个wife_id字段，并且添加了外键参考Wife的id字段。用PowerDesigner逆向工程导出为： 这个wife_id的外键名是hibernate帮我们自动生成的，如果想用自己名字，可以这么设置：12345@OneToOne@JoinColumn(name="wifeId")public Wife getWife() &#123; return wife;&#125; 这样就会生成名字叫wifeId的外键了。 第三十六课. 一对一单向外键关联 xml上面一节讲了注解方式构建一对一的单向外键关联，现在我们用xml方式来构建。这一次我们构建一个学生一卡通的类，让它和学生类产生一对一关联。 StuIdCard.java：1234567891011121314151617181920212223242526272829303132package com.bjsxt.hibernate;public class StuIdCard &#123; private int id; private String num; private Student student; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getNum() &#123; return num; &#125; public void setNum(String num) &#123; this.num = num; &#125; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125;&#125; Student.hbm.xml： 1234567891011121314151617181920&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.bjsxt.hibernate.Student" dynamic-update="true"&gt; &lt;id name="id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name"&gt;&lt;/property&gt; &lt;property name="age" /&gt; &lt;property name="sex" /&gt; &lt;property name="good" type="yes_no"&gt;&lt;/property&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; StuIdCard.hbm.xml： 123456789101112131415&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.bjsxt.hibernate.StuIdCard"&gt; &lt;id name="id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="num"&gt;&lt;/property&gt; &lt;many-to-one name="student" column="studentId" unique="true"&gt;&lt;/many-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 在hibernatecfg.xml中加入：12&lt;mapping resource="com/bjsxt/hibernate/Student.hbm.xml"/&gt;&lt;mapping resource="com/bjsxt/hibernate/StuIdCard.hbm.xml"/&gt; 运行一下： OK！ 第三十七课. 一对一双向外键关联上面我们实验了一对一的单向外键关联，这一节我们实验双向关联。 这一次在Wife类中加入Husband引用：private Husband husband;然后生成getter和setter，并且在getter上面添加一对一的注解：1234@OneToOnepublic Husband getHusband() &#123; return husband;&#125; 配置hibernate.cfg.xml：12&lt;mapping class="com.bjsxt.hibernate.Husband"/&gt;&lt;mapping class="com.bjsxt.hibernate.Wife"/&gt; 运行： 用PowerDesigner逆向工程生成图： 发现生成了两个外键，这显然不是我们想要的。 我们参考文档之后在Wife类中进行修改：1234@OneToOne(mappedBy = "wife")public Husband getHusband() &#123; return husband;&#125; 在原来基础上加了一个mappedBy，表明这个一对一关联是被Husband类的 wife属性(准确说是getWife方法)做的映射 再运行： 看到Wife中已经没有了Husband的引用。 xml方式怎么做？在Student类中添加StuIdCard的属性和getter、setter：123456789private StuIdCard stuIdCard;public StuIdCard getStuIdCard() &#123; return stuIdCard;&#125;public void setStuIdCard(StuIdCard stuIdCard) &#123; this.stuIdCard = stuIdCard;&#125; 在Student.hbm.xml中进行配置：&lt;one-to-one name=&quot;stuIdCard&quot; property-ref=&quot;student&quot;&gt;&lt;/one-to-one&gt;其中, property-ref 相当于mappedBy此方式生成的StuIdCard表中包含studentid字段作为fk外键, Student表中不生成额外的字段 运行一下： 逆向工程生成一张图来看看： OK！ 特别说明: 一对一单向外键关联与一对一双向外键关联在数据库的表的格式是一样的,区别在于java程序中. 双向外键关联可通过Hibernate在两个类间互相调用彼此,而单向外键关联只能单方向调用 第三十八课. 一对一单双向主键关联（不重要）单向主键关联：注解： Husband.java:12345@OneToOne@PrimaryKeyJoinColumnpublic Wife getWife() &#123; return wife;&#125; xml方式：StuIdCard.hbm.xml:123456789101112&lt;hibernate-mapping&gt; &lt;class name="com.bjsxt.hibernate.StuIdCard"&gt; &lt;id name="id"&gt; &lt;generator class="foreign"&gt; &lt;param name="property"&gt;student&lt;/param&gt; &lt;/generator&gt; &lt;/id&gt; &lt;property name="num"&gt;&lt;/property&gt; &lt;one-to-one name="student" constrained="true"&gt;&lt;/one-to-one&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 运行： 双向主键关联：注解(Wife.java)：12345@OneToOne@PrimaryKeyJoinColumnpublic Husband getHusband() &#123; return husband;&#125; xml形式(Student.hbm.xml)：12345678910111213141516&lt;hibernate-mapping&gt; &lt;class name="com.bjsxt.hibernate.Student" dynamic-update="true"&gt; &lt;id name="id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name"&gt;&lt;/property&gt; &lt;property name="age" /&gt; &lt;property name="sex" /&gt; &lt;property name="good" type="yes_no"&gt;&lt;/property&gt; &lt;one-to-one name="stuIdCard" property-ref="student"&gt;&lt;/one-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 记得在Student.java中加入：private StuIdCard stuIdCard; 也就是说，在Student.hbm.xml中&lt;one-to-one id 使用foreign class，在StuCardId.hbm.xml中&lt;one-to-one 使用property-ref 上面就是单双向的主键关联，不是特别重要，了解即可。 第三十九课. 联合主键关联WifePK.java:123456789101112131415161718192021222324252627package com.bjsxt.hibernate;import javax.persistence.GeneratedValue;import javax.persistence.Id;public class WifePK implements Serializable&#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Wife.java中加入：1234@Entity@IdClass(WifePK.class)public class Wife implements Serializable&#123; 运行一下： 发现在Husband类中自动生成了两个字段：wife_id和wife_name，这两个字段参考Wife类的联合主键字段。 如果想自己指定名字怎么办？进入Husband.java，像下面一样设置：12345678@OneToOne@JoinColumns(&#123; @JoinColumn(name = "wifeId", referencedColumnName = "id"), @JoinColumn(name = "wifeName", referencedColumnName = "name")&#125;)public Wife getWife() &#123; return wife;&#125; 这样就将主键两个字段名字改过来了，运行一下： OK！ 第四十课. 阶段总结一对一关联 一对一单向外键关联a) 项目名称：hibernate_0600_one2one_uni_fkb) Annotation: 在被约束表字段的get方法上加@0ne20ne @JoinColumn12345@OneToOne@JoinColumn(name="wifeid") //指定生成的数据库字段名public Wife getWife() &#123; return wife;&#125; c) xml: 在被约束表的xml配置文件中加]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate笔记（三） Hibernate核心开发接口介绍]]></title>
    <url>%2F2017%2F12%2F20%2FHibernate3%2F</url>
    <content type="text"><![CDATA[本文主要介绍Hibernate核心开发接口。 第二十六课. CoreAPI-Configuration-SessionFactory-GetCurrentSession-OpenSession我们做一个小实验，我们将hibernate.cfg.xml名字改成hibernate.xml，我们运行一下我们的测试程序，测试代码是(com.bjsxt.hibernate.HibernateCoreAPITest.java)：1234567891011121314151617181920212223242526272829303132333435363738394041public class HibernateCoreAPITest &#123; private static SessionFactory sessionFactory; @BeforeClass public static void beforeClass() &#123; sessionFactory = new AnnotationConfiguration().configure().buildSessionFactory(); &#125; @AfterClass public static void afterClass() &#123; sessionFactory.close(); &#125; @Test public void testTeacherSave() &#123; Teacher t = new Teacher(); t.setName("t1"); t.setTitle("middle"); t.setBirthDate(new Date()); //Session session = sessionFactory.openSession(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); session.save(t); Session session2 = sessionFactory.getCurrentSession(); System.out.println(session == session2); session.getTransaction().commit(); Session session3 = sessionFactory.getCurrentSession(); System.out.println(session == session3); &#125; 发现报错： 如果我们在beforeClass方法内对；配置进行修改：1234@BeforeClasspublic static void beforeClass() &#123; sessionFactory = new AnnotationConfiguration().configure("hibernate.xml").buildSessionFactory();&#125; 那么这个时候就会对修改过名字后的配置文件进行识别，程序可以正常运行。 结论：我们可以在configure方法中指定hibernate配置文件 我们看上面testTeacherSave()代码中关于Session的部分： SessionFactory是用来产生和管理Session的。通常情况下每个应用只需要一个SessionFactory，除非要访问多个数据库的情况。 我们需要关注两个方法，一个是openSession，另外一个是getCurrentSession，我们通过实验可以来阐述二者的区别： 第一个先做openSession的： 123456789101112131415161718192021 @Test public void testTeacherSave() &#123; Teacher t = new Teacher(); t.setName("t1"); t.setTitle("middle"); t.setBirthDate(new Date()); Session session = sessionFactory.openSession();// Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); session.save(t); session.getTransaction().commit();session.close(); Session session2 = sessionFactory.openSession(); System.out.println(session == session2); &#125; 最后显示结果是false，说明使用openSession方法产生的两个Session是不一样的。而且openSession每次使用结束后需要自己手动close。 再做第二个实验，关于getCurrentSession的：12345678910111213141516171819 @Test public void testTeacherSave() &#123; Teacher t = new Teacher(); t.setName("t1"); t.setTitle("middle"); t.setBirthDate(new Date());// Session session = sessionFactory.openSession(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); session.save(t); Session session2 = sessionFactory.getCurrentSession(); System.out.println(session == session2); &#125; 结果显示是true，说明使用getCurrentSession方法得到的两个Session是相同的。 我们再继续做实验:123456789101112131415161718192021222324252627@Test public void testTeacherSave() &#123; Teacher t = new Teacher(); t.setName("t1"); t.setTitle("middle"); t.setBirthDate(new Date());// Session session = sessionFactory.openSession(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); session.save(t); Session session2 = sessionFactory.getCurrentSession(); System.out.println(session == session2); session.getTransaction().commit(); Session session3 = sessionFactory.getCurrentSession(); System.out.println(session == session3); &#125; 发现经过commit之后，session和session3并不相同，即使是在getCurrentSession下得到的。 我们再来剖析一下getCurrentSession的用途，看这样一张架构图： 在添加一个用户的时候，会发生两个操作，一个是向数据库中加入一个用户记录，另外一个就是在日志中添加一个记录。这两个应该同时处于同一个事物之中，这时候如果用openSession就不太合适了，因为是不同的Session，为了保证两个操作在同一个Session中，我们应该使用getCurrentSession方法。 第二十七课. CoreAPI JTA简介我们在前面讲的，getCurrentsession建立Session会从上下文找，如果有，用旧的，如果没有，建新的，那么这个上下文是怎么配置的？ 上下文可以在hibernate.cfg.xml中进行配置：12&lt;!-- Enable Hibernate's automatic session context management --&gt;&lt;property name="current_session_context_class"&gt;thread&lt;/property&gt; current_session_context_class有四个选项可以配置：jta、thread、managed、custom.Class其中jta、thread常用，managed、custom.Class少用 thread是使用connection 单数据库连接管理事务 jta （全称java transaction api），是java分布式事务管理（多数据库访问）要理解jta，看下面的架构图：jta需要操作多个数据库，比如在订单系统中，当下了一个订单之后，向DB1存取产品信息，向DB2存取财务方面的信息。这两个信息一块从属于一个事物，如果这时候在使用单连接，是解决不了问题的。这时候就用到了jta。jta由中间件提供（jboss WebLogic等，tomcat不支持） 总结一下上面讲到的关于SessionFactory的知识点：SessoinFactorya) 用来产生和管理Sessionb) 通常情况下每个应用只需要一个SessionFactoryc) 除非要访问多个数据库的情况d) 关注两个方法即：openSession getCurrentsessioni. openSession每次都是新的，需要closeii. getCurrentsession从上下文找，如果有，用旧的，如果没有，建新的 用途：界定事务边界 事务提交自动close 上下文配置可参见xml文件中 &lt;property name=&quot;current_session_context_classs&quot;&gt;thread&lt;/property&gt; current_session_context_class (jta、thread常用 managed、custom.Class少用)a) thread 使用connection 单数据库连接管理事务b）jta （全称java transaction api）-java分布式事务管理（多数据库访问） jta由中间件提供（jboss WebLogic等，tomcat不支持） 第二十八课. CoreAPI对象三种状态openSession和getCurrenSession不能混用。由于Session是一个接口，但是openSession得到的Session和getCurrenSession得到的Session的具体实现是不一样的。 先写个小测试程序来测试一下：1234567891011121314151617 @Test public void testSaveWith3State() &#123; Teacher t = new Teacher(); t.setName("t1"); t.setTitle("middle"); t.setBirthDate(new Date()); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); session.save(t); System.out.println(t.getId()); session.getTransaction().commit();// System.out.println(t.getId()); &#125; 在这之前需要先drop掉我们的teacher表。 运行一下，看到打印出的id是1 hibernate有三种对象状态，它们之间的关系如下： 三种状态的区分关键在于a) 有没有IDb) ID在数据库中有没有c) 在内存中有没有（session缓存） 三种状态：a) transient：内存中一个对象，没ID,缓存中也没有b) persistent：内存中有，缓存中有，数据库有（ID)c) detached：内存有，缓存没有，数据库有，有ID 第二十九课. CoreAPI Delete写一个代码测试一下：12345678910111213141516171819@Testpublic void testDelete() &#123; Teacher t = new Teacher(); t.setName("t1"); t.setTitle("middle"); t.setBirthDate(new Date()); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); session.save(t); System.out.println(t.getId()); session.getTransaction().commit(); Session session2 = sessionFactory.getCurrentSession(); session2.beginTransaction(); session2.delete(t); session2.getTransaction().commit();&#125; 运行一下： 这个代码首先创建了一个Teacher对象，这时处于Transient状态，然后通过save方法存储这个对象，进入到Persistent状态。然后commit，就进入另外一个session，这时候用getCurrentSession函数获取到这个session，由于它有id，所以通过delete方法就可以将这个对象从数据库删除。 再做第二个实验：123456789101112@Testpublic void testDelete2() &#123; Teacher t = new Teacher(); t.setId(2); Session session2 = sessionFactory.getCurrentSession(); session2.beginTransaction(); session2.delete(t); session2.getTransaction().commit();&#125; 这个实验中，我们只创建了一个对象，这时进入了Transient状态，这时没有将对象存入数据库。这时候我们对其设置id号，然后delete这个对象，运行一下： 发现还是可以delete掉的。 第三十课. CoreAPI Get Load我们先学习怎么从数据库中取出一条数据并转化成一个对象：123456789public void testLoad() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.load(Teacher.class, 1); System.out.println(t.getName()); session.getTransaction().commit();&#125; 运行一下： 发现成功将id号为1的对象从数据库中取了出来并且将它的名字打印在了控台上面。 再看session的Get方法：123456789@Testpublic void testGet() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.get(Teacher.class, 1); System.out.println(t.getName()); session.getTransaction().commit();&#125; 运行一下： 发现session的get和load都可以取到一个数据库中的对象，并将这个对象的名字打印出来。 但实际上，这两个方法有着重要的区别：先看get方法，如果我们将打印名字的语句放在commit之后：123456789@Testpublic void testGet() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.get(Teacher.class, 1); session.getTransaction().commit(); System.out.println(t.getName());&#125; 运行一下： 发现没有任何问题。 但是同样的，我们再来试一下load方法：12345678910 @Testpublic void testLoad() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.load(Teacher.class, 1); session.getTransaction().commit(); System.out.println(t.getName());&#125; 运行一下： 发现会报错，这个错误叫做LazyInitializationException，而且说我们没有session。这个原因我们可以做个试验来讲明。 将testLoad修改，去掉那个打印名字的句子：123456789 @Testpublic void testLoad() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.load(Teacher.class, 1); session.getTransaction().commit();&#125; 运行一下： 发现没有生成任何sql语句。 我们同样的，去掉testGet中的打印名字语句：123456789 @Testpublic void testGet() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.get(Teacher.class, 1); session.getTransaction().commit();&#125; 运行一下： OK，这下我们就明白了，原来get方法只要生成一个对象，就会产生sql语句，但是load方法不是，它是在用到这个对象的时候，才开始生成sql语句。 如果我们load一个不存在的记录，比如id为5的对象，不会报错，因为这时候对象没有被调用，所以不会发出sql语句；但是get就不行了，只要创建这个对象，就会生成sql语句，所以它会到数据库查，一查没有这个记录，所以会报错。 所以get和load的区别如下： 不存在对应记录时表现不一样 load返回的是代理对象，等到真正用到对象的内容时才发出sql语句 get直接从数据库加载，不会延迟 第三十一课. CoreAPI Get Load 2还是关于刚刚的get和load的区别，其实load返回的是代理对象，get直接从数据库直接加载，我们可以做一个实验，就是打印它们的类型名： 12345678910111213141516171819202122 @Test public void testLoad() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.load(Teacher.class, 1); session.getTransaction().commit(); System.out.println(t.getClass());// System.out.println(t.getName()); &#125; @Test public void testGet() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.get(Teacher.class, 1); session.getTransaction().commit(); System.out.println(t.getClass());// System.out.println(t.getName()); &#125; 发现load运行结果： 是一个代理类型 而get运行结果： 就是直接从数据库拿出来的一个Teacher类型的对象。 第三十二课. CoreAPI Update update： 用来更新detached对象，更新完成后转为persistent状态 更新transient对象会报错 更新自己设定id的transient对象可以（数据库有对应记录） persistent状态的对象只要设定（如:t.setName…）不同字段就会发生更新 先看第一个测试例子：1234567891011121314151617@Testpublic void testUpdate1() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.get(Teacher.class, 1); session.getTransaction().commit(); t.setName("zhanglaoshi"); Session session2 = sessionFactory.getCurrentSession(); session2.beginTransaction(); session2.update(t); session2.getTransaction().commit();&#125; 运行一下： 这个例子中，先从数据库中取出来一个id为1的记录，然后通过setName方式改变这个对象的名字，再取出当前的session，执行update操作，发现结果是将这条数据进行修改重新插入到数据库中的。 再看下一个例子：12345678910111213@Testpublic void testUpdate2() &#123; Teacher t = new Teacher(); t.setName("zhanglaoshi"); Session session2 = sessionFactory.getCurrentSession(); session2.beginTransaction(); session2.update(t); session2.getTransaction().commit();&#125; 运行这个例子： 发现0条数据被更新，这是因为在测试代码中，我们没有指定新的Teacher对象t的id号，所以session不知道要去更新哪一条对象数据，所以会报错。 第三个例子代码：1234567891011121314@Testpublic void testUpdate3() &#123; Teacher t = new Teacher(); t.setId(1); t.setName("zhanglaoshi"); Session session2 = sessionFactory.getCurrentSession(); session2.beginTransaction(); session2.update(t); session2.getTransaction().commit();&#125; 执行一下： 发现这样的transient对象也可以被更新，因为这一次我们设置了对象id，而且在数据库中有这条记录，所以我们可以成功更新这一条对象。 看下一种更新方式：123456789public void testUpdate4() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.get(Teacher.class, 1); t.setName("zhangsan2"); session.getTransaction().commit();&#125; 运行一下： 这一次，我们从数据库中取出一个对象，然后修改这个对象，不执行update操作，只是commit，发现在控制台还是把整个对象中数据进行修改，然后插入到数据库中了。 我们再执行一次： 发现这一次除了取对象，就并没有数据进行修改操作，原因是因为数据在上一次修改之后，并没有再次修改，所以不会再执行一次插入操作。 这时候我们还是觉得麻烦，如果只想修改对象的一个字段，却要整个重新插入，麻烦，怎么可以只set一个字段？ 解决办法就是先在getTitle上面加一个Column注解： 1234@Column(updatable = false)public String getTitle() &#123; return title;&#125; 修改一下update4，要它修改的名字变一下，变成原来对象没有的：12345678910@Testpublic void testUpdate4() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.get(Teacher.class, 1); t.setName("zhangsan"); session.getTransaction().commit();&#125; 再执行： 发现set了所有字段，成功！ 这种方式虽然可以达到目的，但是不常用。 我们介绍下一种方法，先修改Student.hbm.xml：12345678910111213141516171819&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt; &lt;class name="com.bjsxt.hibernate.Student" dynamic-update="true"&gt; &lt;id name="id"&gt; &lt;generator class="native"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name"&gt;&lt;/property&gt; &lt;property name="age" /&gt; &lt;property name="sex" /&gt; &lt;property name="good" type="yes_no"&gt;&lt;/property&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 在class后面加上了dynamic-update=”true”这个选项。 查询一下数据库中表Student： 发现有一条数据，现在我们就修改这一条数据：12345678910@Testpublic void testUpdate5() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Student s = (Student) session.get(Student.class, 1); s.setName("zhangsan2"); session.getTransaction().commit();&#125; 运行一下： 发现这个操作之后，数据只set了要被修改的字段，很棒！ 如果去掉dynamic-update=”true”这个配置，修改例子中的名字，再执行： 发现又把所有字段都更新了。 再做一个关于跨session的实验：123456789101112131415161718@Testpublic void testUpdate5() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Student s = (Student) session.get(Student.class, 1); s.setName("zhangsan4"); session.getTransaction().commit(); s.setName("z4"); Session session2 = sessionFactory.getCurrentSession(); session2.beginTransaction(); session2.update(s); session2.getTransaction().commit();&#125; 我们运行一下： 如果我们再改成dynamic-update=”true”，第一个setName改一下，运行： 发现第一次我们运行的时候，由于设置了动态更新，所以把数据库中对象取出来以后，只是set要修改的字段，就结束。commit以后，session已经变成了一个新的session，这时候我们的对象没有在session中找到自己原来的对象，所以没有比对，不能直接set一个字段，所以就把所有字段再set一遍，插入数据库。 第六种update方式：1234567891011121314151617@Testpublic void testUpdate6() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Student s = (Student)session.get(Student.class, 1); s.setName("zhangsan6"); session.getTransaction().commit(); s.setName("z4"); Session session2 = sessionFactory.getCurrentSession(); session2.beginTransaction(); session2.merge(s); session2.getTransaction().commit();&#125; 跨session以后，我们使用merge方法，来更新要修改的字段。运行结果： 发现一个很好玩的事情，就是在我们进入新的session之后，要merge的时候，会先执行一个查询语句，其实这个查询语句是把我们要修改的对象load到了session中，然后和session中的对象进行比对，如果要修改的字段不同，那么set一个字段就可以。这种方式其实也特别麻烦，因为每次都要先load一下才能set字段。 第七种更新方式：1234567891011@Testpublic void testUpdate7() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Query q = session.createQuery("update Student s set s.name='z5' where s.id = 1"); q.executeUpdate(); session.getTransaction().commit();&#125; 执行一下： 发现只set了我们要修改的字段，而且不需要load。这种方式叫做HQL，是一种特别类似于JDBC中Statement语句的写法，用SQL语句来操作更新，推荐使用。 总结一下update： 用来更新detached对象，更新完成后转为persistent状态 更新transient对象会报错 更新自己设定id的transient对象可以（数据库有对应记录） persistent状态的对象只要设定（如:t.setName…）不同字段就会发生更新 更新部分更改的字段a) xml 设定 property 标签的 update 属性，annotation 设定@Column 的 updatable属性，不过这种方式很少用，因为不灵活b) 使用xml中的dynamic-update，JPA1.0 Annotation 没有对应的属性，hibernate 扩展？i. 同一个session可以，跨session不行，不过可以用merge()(不重要）c) 使用 HQL(EjBQL)(建议） 第三十三课. CoreAPI-saveOrUpdate-Clear-FlushsaveOrUpdate方法：我们先把Teacher类中的@Column(updatable = false)这一句去掉。编写测试函数：1234567891011121314151617181920212223@Testpublic void testSaveOrUpdate() &#123; Teacher t = new Teacher(); t.setName("t1"); t.setTitle("middle"); t.setBirthDate(new Date()); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); session.saveOrUpdate(t); session.getTransaction().commit(); t.setName("t2"); Session session2 = sessionFactory.getCurrentSession(); session2.beginTransaction(); session2.saveOrUpdate(t); session2.getTransaction().commit();&#125; 运行一下： 发现在新创一个对象以后，如果调用saveOrUpdate方法，那么会执行save操作；如果是已经有了这样一个对象，只是设置了它的某个字段，那么会执行update操作。 这个方法到此为止，我们看下一个方法。 这个方法叫clear方法，先来看一个例子：1234567891011121314@Testpublic void testClear() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.load(Teacher.class, 1); System.out.println(t.getName()); Teacher t2 = (Teacher)session.load(Teacher.class, 1); System.out.println(t2.getName()); session.getTransaction().commit();&#125; 运行一下： 发现第一次会从数据库中取一下这个对象，而第二次没有执行查询语句，原因是因为第一次已经将对象load导入缓存中了，第二次取的对象就是这个对象，所以先从缓冲中去取，而不是从数据库中取。 那么clear是做什么的？我们再做实验：12345678910111213141516@Testpublic void testClear() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.load(Teacher.class, 1); System.out.println(t.getName()); session.clear(); Teacher t2 = (Teacher)session.load(Teacher.class, 1); System.out.println(t2.getName()); session.getTransaction().commit();&#125; 运行： 发现执行了两次查询，这时候我们明白了，原来clear是用来清空缓存的。 12345678910111213141516@Testpublic void testFlush() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.load(Teacher.class, 1); t.setName("tttt"); t.setName("ttttt"); session.getTransaction().commit();&#125; 执行一下： 发现只是执行了一次update语句，这是因为我们对字段的两次修改都是在commit之前的。所以不管对这个字段修改了多少次，在执行commit之后，只会更新一次。 如果我们想生成多个update操作，怎么做呢？123456789101112131415161718@Testpublic void testFlush() &#123; Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); Teacher t = (Teacher)session.load(Teacher.class, 1); t.setName("tttt"); session.flush(); t.setName("ttttt"); session.getTransaction().commit();&#125; 执行一下： 发现再加入了一个flush语句之后，会执行两条update操作。所以flush的作用就是强制让缓存的内容和数据库中的内容做同步。 如果将flush改成clear，执行一下： 发现只执行一次查询操作，原因是由于将数据库中对象load到缓存之后，我们就用clear方法把缓存清空了，之后我们再一次setName，只是对一个Transient状态的对象进行操作，那么我们setName之后，不会和数据库打交道，不会立即执行sql语句。 第三十四课. CoreAPI SchemaExport and 总结先将hibernate.hbm.xml中&lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;这一句屏蔽掉。 写测试代码：1234@Testpublic void testSchemaExport() &#123; new SchemaExport(new AnnotationConfiguration().configure()).create(true, true);&#125; 运行： 发现每一个建表语句都打印了两次。这是由于log4j先打印了一次，然后我们的create语句中第一次参数又将建表的DDL打印了一次。如果改成false，就只会打印一次了。 这个例子的主要作用就在于帮我们建立一个表。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate笔记（二） ID生成策略]]></title>
    <url>%2F2017%2F12%2F15%2FHibernate2%2F</url>
    <content type="text"><![CDATA[本文主要介绍hibernate的Id生成策略。 第二十课. ID生成策略 XML 配置.之前我们对于不管是Teacher类还是Student类，都采用手动设置的方式来生成id，现在我们采用自动生成的方式来生成id号。在xml中它的配置就是Generate参数： 具体的参数配置如下： 下面我们将TeacherTest类复制过来，改名叫做HibernateIDTest，并且进行修改，屏蔽掉原先对于id的设置，在Student.hbm.xml中对id进行配置：1234567891011121314&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.bjsxt.hibernate.model"&gt; &lt;class name="Student" table="_Student"&gt; &lt;id name="id"&gt; &lt;generator class="uuid"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name="name"&gt;&lt;/property&gt; &lt;property name="age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 这样每插入一条数据都会形成一个独一无二的id号。我们运行一下： 上面那个id就是hibernate自动帮我们生成的。 如果我们将generate class的值改成native，那么hibernate就会帮我们从1开始，每次以递增1的方式来生成id。 第二十一课. ID生成策略XML配置-Annotatio配置generate class里面常用四个：native identity sequence uuid（跨平台 native uuid） 下面我们验证一下native跨平台：先查询一下_Student： 根据native规则，它是从1开始生成id的。之前我们的操作都是在MySql上进行的，下面我们不改代码，只改配置，看看在Oracle上能不能跑这个代码。我们先找到hibernate-distribution-3.3.2.GA-dist\hibernate-distribution-3.3.2.GA\project\etc这个文件夹，在这个文件夹下找到hibernate.properties文件进行参考，看到对Oracle的配置是： 基于这个参考，我们修改我们的hibernate.cfg.xml:12345&lt;property name="connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;&lt;property name="connection.url"&gt;jdbc:oracle:thin:@127.0.0.1:1521:orcl&lt;/property&gt;&lt;property name="connection.username"&gt;scott&lt;/property&gt;&lt;property name="connection.password"&gt;tiger&lt;/property&gt;&lt;property name="dialect"&gt;org.hibernate.dialect.Oracle10gDialect&lt;/property&gt; 注意的是上面需要引入oracle的classes12.jar包，而且版本得兼容 由于oracle中表名不能以下划线开头，所以我们需要修改Teacher.java，去掉一行：@Table(name = &quot;_Teacher&quot;) 我们执行一下，控台输出这样的话： 说明使用hibernate，在oracle中帮我们生成了sequence 这是使用xml方式生成的，那么如何使用注解方式呢？ 我们再回到Mysql，把配置改回去。 我们再Teacher类的getId方法上面加上一句注解：12345@Id@GeneratedValuepublic int getId() &#123; return id;&#125; 我们模仿TestTeacher.java在HibernateIDTestzhong 写一个测试代码：12345678910111213@Testpublic void testTeacherSave()&#123; Teacher t = new Teacher(); t.setName("t1"); t.setTitle("middle"); t.setBirthdate(new Date()); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); session.save(t); session.getTransaction().commit();&#125; 运行可以看到： 发现注解简单了很多。而且id生成以后，oracle是sequence，mysql是auto_increment 注解方式：@GeneratedValuea) 自定义IDb) AUTO(直接写 @GeneratedValue 相当如native)&nbsp;&nbsp;&nbsp;&nbsp;i. 默认：对 MySQL,使用auto_increment&nbsp;&nbsp;&nbsp;&nbsp;ii. 对 Oracle使用hibernate_sequence(名称固定）c) IDENTITY(@GeneratedValue(strategy=GenerationType.IDENTITY))d) SEQUENCE(@GeneratedValue(strategy=GenerationType.SEQUENCE))&nbsp;&nbsp;&nbsp;&nbsp;i. @SequenceGenerator(可自定义在数据库生成指定的sequence名)12@Id//在@GeneratedValue中增加 generator="teacherSEQ" 1234567@GeneratedValue(strategy=GenerationType.SEQUENCE,generator="teacherSEQ")//"teacherSEQ"为@SequenceGenerator的标识名//"teacherSEQ_DB"为指定到数据库生成的Sequence名@SequenceGenerator(name="teacherSEQ", sequenceName="teacherSEQ_DB") public int getId() &#123; return id;&#125; 第二十三课. ID生成策略 Annotation配置 Table Generatore) TABLE (可以忘记)&nbsp;&nbsp;&nbsp;&nbsp;i. @TableGenerator123456@TableGenerator(name="teacherID", table="teacherID_DB", pkColumnName="key_value", pkColumnValue="pk_value", valueColumnName="teacher", allocationSize=1) 配置Teacher.java： 运行时报错，发现原因是由于Teacher.java中的key和value在mysql中都是关键词，所以会报错，所以我们修改如下： 如果我们想跨平台，可以使用这种方式。 第二十四课. ID生成策略 联合主键 XMLXml方式: composite-idi. 将联合主键的属性提取出来,重新编写一个pojo类（原pojo类中的id，name要删除 并新加入属性“StudentPK”）1234 public class StudentPK implements Serializable &#123;private String id;private String name;… … ii. 新建pojo类必须实现 java.io.Serializable 序列化接口iii. 新pojo类要重写equals和hashCode方法123456789101112131415@Overridepublic boolean equals(Object o) &#123; if(o instanceof StudentPk) &#123; StudentPk pk = (StudentPk)o; if(this.id == pk.getId() &amp;&amp; this.name.equals(pk.getName())) &#123; return true; &#125; &#125; return false;&#125;@Overridepublic int hashCode() &#123; return this.name.hashCode();&#125; iv. 联合主键生成策略XML配置方法1234567891011 &lt;hibernate-mapping&gt; &lt;class name="com.bjsxt.pojo.Student" &gt; &lt;composite-id name="studentPK" class="com.bjsxt.pojo.StudentPK"&gt; &lt;key-property name="id"&gt;&lt;/key-property&gt; &lt;key-property name="name"&gt;&lt;/key-property&gt; &lt;/composite-id&gt; &lt;property name="age" /&gt; &lt;property name="sex" /&gt; &lt;property name="good" type="yes_no"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 第二十五课. ID生成策略 联合主键 AnnotationAnnotationi. 前三步与Xml方式前三步一样 都要建立新pojo类 都要实现Serializable接口 重写equals和hashCode方法.ii. 方法1在新类前写@Embeddable，在原pojo类的新属性“TercherPK”的get方法前写@ld，如下1234567891011121314 @ Embeddablepublic class TeacherPK implements Serializable &#123; private String id; private String name; … … @Entitypublic class Teacher &#123;private TeacherPK teacherPK ;@Idpublic TeacherPK getTeacherPK() &#123; return teacherPK;&#125;… … iii. 方法2：@EmbeddedlD(*) 新pojo类无需加注解，只需在原pojo类新属性“TercherPK”的get方法前写@EmbeddedlD即可iv. 方法3：@ld @IdClass(*) 新pojo类无需加注解，原pojo类的id，name属性保留不变，也无需新增“TercherPK”属性。 只在id，name的get方法前都加@Id，并在原pojo类前加“@IdClass(TeacherPK).class)”，如下1234567891011121314@Entity@IdClass(TeacherPK.class)public class Teacher &#123;private String id;private String name;@Idpublic String getId() &#123; return id;&#125;@Idpublic String getName() &#123; return name;&#125;... ... 上面的三种注解方式，第二种最常见，第三种也比较常用。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate笔记（一） Hibernate简介及基础配置]]></title>
    <url>%2F2017%2F12%2F15%2FHibernate1%2F</url>
    <content type="text"><![CDATA[本文主要介绍Hibernate的基本原理及基础配置。 Hibernate内容： HelloWorlda) xmlb) annotation Hibernate原理模拟 - 什么是 O/RMapping以及为什么要有O/RMapping 常见的O/R框架 Hibernate基础配置 Hibernate核心接口介绍 对象的三种状态 ID生成策略 关系映射 Hibernate查询(HQL) 在Struts基础上继续完善BBS2009 性能优化 补充话题 第一课. Hibernate初印象.S2SH整合以后的整体框架 Spring会将service注入到Action里面去，Spring还会将DAO注入到service里面。hibernate架构： 风格： 先脉络，后细节 先操作，后原理 重Annotation,轻xml配置文件a) JPAb) hibernate – extension Hibernate准备： 这是视频上给出的一个官网说明，原先我们是要看Matrix来看Hibernate Core、Annotations和EntityManager哪个版本对应哪个版本，然后挨个下载，不过在Hibernate3.5.x以后，就不要这么做了，只需要把整个包都下载下来，里面是已经搭配好的。但是当时视频出来的时候，3.5.X还处于beta版本，不稳定，所以视频里面下载的是Hibernate Core 3.3.2，查询矩阵表： 查到对应的Annotation是3.4.x,所以最后下载的是3.3.2 GA的Core和3.4.0 GA的Annotation。因为没有用到EntityManager，所以先不需要下载。hibernate下载地址：http://hibernate.org/orm/releases/现在已经到了5.2版本了。 最后我们需要把记录日志的包slf4jl.5.8也下载下来。 另外我们需要特别注意两个说明文档： hibernate zh_CN文档 hibernate annotation references 第二节. HelloWorld本节来创建一个Hibernate版本的HelloWorld。 先创建一个最简单的Java工程叫hibernate_0100_HelloWorld，然后在这个工程里面创建一个library叫做hibernate，向hibernate这个library里面添加jar包： 被圈中的都是我们要添加的jar包，然后我们看到添加的jar包中有一个slf4j-api-1.5.8，但其实那个只是相当于一个声明，具体的实现我们还需要添加下面的jar包： 这样的library才是完整的比较原始的hibernate资料包。 当然为了能和mysql数据库连接，我们还需要添加JAVA和数据库连接的jar包： 然后把两个都添加配置到工程里来： 在mysql中创建我们的数据库并创建表： 这样就创建了一个hibernate数据库，并且在里面创建了一个student表。 在src下创建配置文件hibernate.cfg.xml，内容直接将hibernate-distribution-3.3.2.GA/documentation/manual/zh-CN/html_single这个文档里的 Hibernate配置 粘贴过来进行修改就可以：1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- Database connection settings --&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="connection.url"&gt;jdbc:mysql://localhost/hibernate&lt;/property&gt; &lt;property name="connection.username"&gt;root&lt;/property&gt; &lt;property name="connection.password"&gt;09129421&lt;/property&gt; &lt;!-- JDBC connection pool (use the built-in) --&gt; &lt;!--&lt;property name="connection.pool_size"&gt;1&lt;/property&gt;--&gt; &lt;!-- SQL dialect --&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- Enable Hibernate's automatic session context management --&gt; &lt;!--&lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;--&gt; &lt;!-- Disable the second-level cache --&gt; &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt; &lt;!-- Echo all executed SQL to stdout --&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;!-- Drop and re-create the database schema on startup --&gt; &lt;!--&lt;property name="hbm2ddl.auto"&gt;update&lt;/property&gt;--&gt; &lt;mapping resource="com/bjsxt/hibernate/model/Student.hbm.xml"&gt;&lt;/mapping&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 现在有了Student类，也有了数据库，那怎么能把这二者关联起来呢？由于我们前面的数据库中id号没有设置为主键，所以我们删了重新创建一下表： 这样id就成了主键。 由于上面的配置文件中最后一句是&lt;mapping resource=&quot;com/bjsxt/hibernate/model/Student.hbm.xml&quot;/&gt;所以我们的配置文件就定义在model下，命名叫Student.hbm.xml：123456789101112&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping package="com.bjsxt.hibernate.model"&gt; &lt;class name="Student"&gt; &lt;id name="id"&gt;&lt;/id&gt; &lt;property name="name"&gt;&lt;/property&gt; &lt;property name="age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 这样就将我们的Student和数据库中的Student表关联起来，分别将id、name和age字段也关联起来了。 然后我们在src下做一个测试类，用来将Student里的数据通过Hibernate存储到mysql里面（）：1234567891011121314151617181920212223import com.bjsxt.hibernate.model.Student;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class StudentTest &#123; public static void main(String[] args) &#123; Student s = new Student(); s.setId(1); s.setName("s1"); s.setAge(1); Configuration cfg = new Configuration(); SessionFactory sf = cfg.configure().buildSessionFactory(); Session session = sf.openSession(); session.beginTransaction(); session.save(s); session.getTransaction().commit(); session.close(); sf.close(); &#125;&#125; 效果： 发现Sql被成功生成并显示在控制台。 查询数据库： 成功！ 查看文档： 发现HibernateUtil类是一系列辅助使用的方法集合，我们前面用到了buildFactory()方法，里面的getSessionFactory()是一个单例模式，所以我们调用的时候直接使用类.方法()的方式就可以了，而且之创建一个session工厂，因为我们没有必要每一次都创建一个新的。 第三课. Annotation版本的HelloWorld上一节我们使用传统的Hibernate的xml方法来创建一个HelloWorld项目，这次我们用更简单的Annotation方式来创建。 引入支持Annotation的jar包： 这样就支持Annotation语法了。 创建一个Teacher表： 创建一个Teacher类：12345678910111213141516171819202122232425262728293031323334353637package com.bjsxt.hibernate.model;import javax.persistence.Entity;import javax.persistence.Id;@Entitypublic class Teacher &#123; private int id; private String name; private String title; @Id public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125; 其中@Entity : 对实体注释。任何Hibernate映射对象都要有这个注释@Id: 声明此属性为主键。 接下来不需要去配置hbm.xml，而是直接去配置hibernate.cfg.xml，在原来代码基础上添加一句即可：12&lt;mapping resource="com/bjsxt/hibernate/model/Student.hbm.xml"/&gt;&lt;mapping class="com.bjsxt.hibernate.model.Teacher"/&gt; 这样就直接去Teacher这个model中，通过注解来找映射关系。 在src目录下创建一个TeacherTest测试类，注意里面的cfg，这次是通过AnnotationConfiguration()来创建的：1234567891011121314151617public class TeacherTest &#123; public static void main(String[] args) &#123; Teacher t = new Teacher(); t.setId(1); t.setName("t1"); t.setTitle("中级"); Configuration cfg = new AnnotationConfiguration(); SessionFactory sf = cfg.configure().buildSessionFactory(); Session session = sf.openSession(); session.beginTransaction(); session.save(t); session.getTransaction().commit(); session.close(); sf.close(); &#125;&#125; 我们来测试一下： 发现可以成功插入一条数据！ 第六课. Hibernate模拟实现What is and Why O/R Mapping JDBC操作数据库很繁琐 Sql语句编写并不是面向对象的 可以在对象和关系表之间建立关联来简化编程 O/R Mapping 简化编程 O/R Mapping跨越数据库平台 这节我们来，模拟一下Hibernate的具体实现过程，就是将我们的对model的操作翻译成sql语句。 创建一个表：create table _student(_id int primary key, _name varchar(20), _age int); Session.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import com.bjsxt.hibernate.model.Student;import java.lang.reflect.Method;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.util.HashMap;import java.util.Map;public class Session &#123; String tableName = "_Student"; Map&lt;String, String&gt; cfs = new HashMap&lt;String, String&gt;(); String[] methodNames; public Session()&#123; cfs.put("_id", "id"); cfs.put("_name", "name"); cfs.put("_age", "age"); methodNames = new String[cfs.size()]; &#125; public void save(Student s) throws Exception&#123; String sql = createSQL(); Class.forName("com.mysql.jdbc.Driver"); Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/hibernate", "root", "09129421"); PreparedStatement ps = conn.prepareStatement(sql); for (int i = 0; i &lt; methodNames.length; i++)&#123; Method m = s.getClass().getMethod(methodNames[i]); Class r = m.getReturnType(); if(r.getName().equals("java.lang.String"))&#123; String returnValue = (String)m.invoke(s); ps.setString(i + 1, returnValue); &#125; if(r.getName().equals("int"))&#123; Integer returnValue = (Integer)m.invoke(s); ps.setInt(i+1, returnValue); &#125; System.out.println(m.getName() + "|" + r.getName()); &#125; /*for (int i = 0; i &lt; cfs.size(); i++)&#123; ps.s &#125;*/ ps.executeUpdate(); ps.close(); conn.close(); &#125; private String createSQL() &#123; String str1 = ""; int index = 0; for (String s : cfs.keySet())&#123; String v = cfs.get(s); v = Character.toUpperCase(v.charAt(0)) + v.substring(1); methodNames[index] = "get" + v; str1 += s + ","; index++; &#125; str1 = str1.substring(0, str1.length() - 1); System.out.println(str1); String str2 = ""; for (int i = 0 ; i &lt; cfs.size(); i++)&#123; str2 += "?,"; &#125; str2 = str2.substring(0, str2.length() - 1); System.out.println(str2); String sql = "insert into " + tableName + "(" + str1 + ")" + " values (" + str2 + ")"; System.out.println(sql); return sql; &#125;&#125; 这里面主要涉及到了反射机制，在之前的博客有相关介绍。 在StudentTest.java里面使用这个Session：1234567891011121314import com.bjsxt.hibernate.model.Student;public class StudentTest&#123; public static void main(String[] args) throws Exception&#123; Student s = new Student(); s.setId(2); s.setName("s2"); s.setAge(2); Session session = new Session(); session.save(s); &#125;&#125; 运行一下： 没问题，和我们的hibernate运行效果是一致的，都将拼出来的sql语句显示在控制台上面。数据库中也成功插入了s数据： 其实Hibernate内部实现并不是使用反射的，这一段我们理解就可以了。 第八课. 常见OR框架简介 hibernate toplink jdo ibatis JPA（意愿一统天下） 第九课. Hibernate总结与提纲Hibernate基础配置 对应项目：Hibernate_0300_BasicConfiguration 介绍MSQL的图形化客户端 hibernate.cfg.xml: hbni2ddl.autoa) 先建表还是先建实体类 搭建日志环境并配置显示DDL语句a) slf4j与log4j的关系：slf4j像是一个大管家，可以管理许多的日志框架，log4j是其中之一b) 加入slf4j-log4j.jar,加入 log4j 的 jar 包,去掉 slf4-nop.jarc) 从hibernate/project/etc 目录 copy log4j.propertiesd) 査询hibernate文裆，日志部分，调整日志的输出策略 搭建jUnit环境a) 需要注意jUnit的Bug hibernate.cfg.xml：show_sql hibernate.cfg.xml：format_sql 12&lt;!-- 格式化显示输出sql --&gt;&lt;property name="format_sql"&gt;true&lt;/property&gt; 表名和类名不同,对表名进行配置a) Annotation: @Tableb) xml:自己査询 字段名和属性相同a) 不用写@column 与默认的@Basic效果一样b) Xml中不用写 column 字段名和属性名不同a) Annotation: @Columnb) xml:自己査询 不需要psersistence的字段(不用列)a) Annotation：@Transientb) xml不写 映射日期与时间类型，指定时间精度a) Annotation：@Temporal(参数) 参数有3种 只显示时间,只显示日期,时间日期都显示123//@Temporal(TemporalType.DATE) 只显示日期//@Temporal(TemporalType.TIME) 只显示时间//@Temporal(TemporalType.TIMESTAMP) 显示日期与时间 b) xml:指定 type1234&lt;class name="Teacher" table="Teacher" &gt; &lt;id name="id" column="id"&gt;&lt;/id&gt; &lt;property name="name" type="time" /&gt;&lt;/class&gt; 映射枚举类型( 比较少用)a) @Enumerated12@Enumerated(EnumType.ORDINAL) 枚举类型按位置数,如:0,1,2 ...存储 @Enumerated(EnumType.STRING) 枚举类型按设定值存储 b) xml:麻烦 字段映射的位置（field或者get方法）a) best practice：保持 field(变量定义) 和 get set 方法的一致 @Lob 课外：CLOBBLOB类型的数据存取 课外：Hibernate自定义数据类型 hibernate 类型 第十课. MySQL客户端介绍.下载一个破解版的MySQL图形化界面，我们这里推荐使用navicat for mysql，下载地址：http://www.jb51.net/database/552026.html#download 第十一课. hbm2ddlhibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构。如果不是此方面的需求建议set value=&quot;none&quot;。 create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 第十二课. 先建表还是先建类.先建表，后建类 第十三课. 搭建Log4J日志环境本节的主要目标是搭建日志环境并配置显示DDL语句 slf技术架构： 我们可以将slf转化成任意一种日志形式。 为了将slf转化成log4j我们需要在library中删除slf4j-nop的jar包，添加log4j的jar包和slf4j-log4j的jar包： 这样相当于就在slf4j和log4j之间加了一个转接器，这是一种适配器模式。 我们在hibernate.cfg.xml中加入下面的配置： create-drop 对表先删后创建，含义参考上一节内容。 我们再加入log4j.properties配置文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file hibernate.log ####log4j.appender.file=org.apache.log4j.FileAppender#log4j.appender.file.File=hibernate.log#log4j.appender.file.layout=org.apache.log4j.PatternLayout#log4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change 'info' to 'debug' ###log4j.rootLogger=warn, stdout#log4j.logger.org.hibernate=info#log4j.logger.org.hibernate=debug### log HQL query parser activity#log4j.logger.org.hibernate.hql.ast.AST=debug### log just the SQL#log4j.logger.org.hibernate.SQL=debug### log JDBC bind parameters ####log4j.logger.org.hibernate.type=info#log4j.logger.org.hibernate.type=debug### log schema export/update ###log4j.logger.org.hibernate.tool.hbm2ddl=debug### log HQL parse trees#log4j.logger.org.hibernate.hql=debug### log cache activity ####log4j.logger.org.hibernate.cache=debug### log transaction activity#log4j.logger.org.hibernate.transaction=debug### log JDBC resource acquisition#log4j.logger.org.hibernate.jdbc=debug### enable the following line if you want to track down connection ###### leakages when using DriverManagerConnectionProvider ####log4j.logger.org.hibernate.connection.DriverManagerConnectionProvider=trace 将其他显示配置都屏蔽掉，只显示hbm2ddl的日志信息。 我们运行程序，查看我们的控制台： 成功！ 第十四课. 搭建Junit日志环境.上一节中我们的日志还只是在运行main方法的情况下进行显示的，本节我们将搭建Junit日志环境。 我们下载junit-4.7.jar，并添加到项目中： 然后单独做成一个library，添加到项目中 这样就支持了junit。 我们模仿maven的做法，在src下创建一个test目录，在这个目录下创建一个和自己要测试文件一样的路径： 在这个文件下，把之前写的TeacherTest完全剪切过来，做一点小小修改，在main方法上加一个@Test： 这样就可以直接在testTeacherSave方法上做单元测试了。 第十五课. showsql_formatsql我们运行单元测试，发现控制台将日志完整的输出出来： 重点观察里面的sql语句，sql语句被正常显示出来，这是由于我们在hibernate.cfg.xml中对sql显示进行过设置：12&lt;!-- Echo all executed SQL to stdout --&gt;&lt;property name="show_sql"&gt;true&lt;/property&gt; 如果设置成false，就不会将最后得到的sql显示。 我们参考文档，还可以通过配置来讲sql显示得更加漂亮一些，就是格式化sql输出： 第十六课. hibernate基础配置类名与表名不一致，但是想把类映射到不同名的表中：123456@Entity@Table(name = "_Teacher")public class Teacher &#123; private int id; private String name; private String title; 这样我们执行后就可以在控制台看到： 说明_Teacher被成功创建并且Teacher也被映射过去。 如果不采用注解方式，使用xml也可以做(Student.hbm.xml)：1234567&lt;hibernate-mapping package="com.bjsxt.hibernate.model"&gt; &lt;class name="Student" table="_Student"&gt; &lt;id name="id"&gt;&lt;/id&gt; &lt;property name="name"&gt;&lt;/property&gt; &lt;property name="age"&gt;&lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 如果写类的时候，字段上面没有写注解，那么就相当于写了@Basic 如果属性名与字段名不一样，那么可以使用@Column注解的：1234@Column(name = "_name")public String getName() &#123; return name;&#125; 看一下数据库： 发现name属性被成功映射到_name字段了。 如果有些属性，我们不想让外界知道，也就是说，在建表的时候不建立对应字段，该怎么做？这里采用@Transient注解就可以了：123456789101112@Entity@Table(name = "_Teacher")public class Teacher &#123; private int id; private String name; private String title; private String yourWifeName; @Transient public String getYourWifeName() &#123; return yourWifeName; &#125; 我们运行，看看数据库： 还是三个字段，yourWifeName没有被加入进来。 日期类型：我们在Teacher类中加入下面的属性：private Date birthdate; 那么在生成数据库的时候们就会生成一个datetime类型的字段： 我们测试一下，在TeacherTest里加入一句：1234567@Testpublic void testTeacherSave() &#123; Teacher t = new Teacher(); t.setId(1); t.setName("t1"); t.setTitle("中级"); t.setBirthdate(new Date()); 运行后查看数据库： 没问题。 如果我们只想让birthdate显示为一个日期，而不是那么精确的时间，可以采用@Temporal(TemporalType.DATE)这样的注解：1234@Temporal(TemporalType.DATE)public Date getBirthdate() &#123; return birthdate;&#125; 运行一下： 发现birthdate只显示了一个日期。 对于枚举类型Enum，注解的处理方式非常简单：先创建一个名字叫ZhiCheng的枚举类：12345package com.bjsxt.hibernate.model;public enum ZhiCheng &#123; A, B, C&#125; 在Teacher.java中加入枚举类型变量：123456789101112public class Teacher &#123; private int id; private String name; private String title; private String yourWifeName; private Date birthdate; private ZhiCheng zhiCheng; @Enumerated(EnumType.STRING) public ZhiCheng getZhiCheng() &#123; return zhiCheng; &#125; 这样，在ZhiCheng和数据库进行映射的时候，会转化成varchar类型： 如果我们使用：@Enumerated(EnumType.ORDINAL)那么生成的表字段就是integer类型： 第十七课. Annotation字段映射位置字段注解应该放在什么位置？ 不应该放在字段上面，因为会破坏私有性，建议放在get方法上。 第十九课. JUnit_BeforeClass不报异常的bug处理如果我们在hibernate.cfg.xml中将表mapping class名字写错了，那么在junit中有时候beforeclass不报错，如果不报错，那么就在beforeclass注解的语句块中加入try catch语句来捕获异常，如果这样还不行，那就只能写main方法， 里面调用@beforeclass下的函数块了。]]></content>
      <categories>
        <category>Hibernate</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2笔记（五）拦截器、国际化]]></title>
    <url>%2F2017%2F12%2F09%2FStruts2-6%2F</url>
    <content type="text"><![CDATA[本文主要介绍Struts2中拦截器和I18N的基本用法。 第六十六课. 声明式异常处理 实现.先看CategoryService.java下的list方法：1234567891011121314151617181920212223public List&lt;Category&gt; list() throws SQLException &#123; Connection conn = DB.createConn(); String sql = "select * from _category_"; PreparedStatement ps = DB.prepare(conn, sql); List&lt;Category&gt; categories = new ArrayList&lt;Category&gt;(); try &#123; ResultSet rs = ps.executeQuery(); Category c = null; while(rs.next()) &#123; c = new Category(); c.setId(rs.getInt("id")); c.setName(rs.getString("name")); c.setDescription(rs.getString("description")); categories.add(c); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); throw(e); &#125; DB.close(ps); DB.close(conn); return categories;&#125; 我们捕获到SQLException异常以后直接将这个异常 throw(e);而且在方法体上也写上：public List&lt;Category&gt; list() throws SQLException 这样就将这个异常抛了出去。 其实我们的ActionSupprot也是这么做的： 被抛出的异常交由struts2来处理，它是怎么处理的？ 我们在struts.xml中加上这样的话：123456&lt;action name="*-*" class="com.bjsxt.bbs2009.action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt; &lt;result name="input"&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt; &lt;exception-mapping result="error" exception="java.sql.SQLException" /&gt; &lt;result name="error"&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; 这样一旦出错，就会交由struts处理，并且显示error.jsp页面这样我们就会将编码出现异常的时候，显示一个错误提示页面了： 可以在debug中显示错误： 但是我们之前的异常映射只能映射到一种异常，但是我们的异常种类很多啊，那么怎么才能把所有异常都处理呢？ 我们只需要配置一个全局的包，用来存放错误映射和结果：1234567891011&lt;package name="bbs2009_default" extends="struts-default"&gt; &lt;global-results&gt; &lt;result name="error"&gt;/error.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;global-exception-mappings&gt; &lt;exception-mapping result="error" exception="java.lang.Exception"&gt;&lt;/exception-mapping&gt; &lt;/global-exception-mappings&gt;&lt;/package&gt; 然后在我们自己的包中继承这个包就可以使用这个包的错误处理了：1&lt;package name="admin" namespace="/admin" extends="bbs2009_default" &gt; 试一下： 是可以的！ 第六十八课. 声明式异常处理 原理看一下关于异常处理的拦截器配置： 看一下defaultStack的配置： 可以发现其中包括了一大堆拦截器的配置。第一个拦截器就是exception，我们来看一下它的代码： 看到了这个拦截器使用的类，再看一下这个类的源码： 这个类继承了AbstractInterceptor的抽象类，它又实现了Interceptor接口，这个接口中核心的拦截函数是intercept()，所以我们只需要看ExceptionMappingInterceptor中的intercept()：123456789101112131415161718192021public String intercept(ActionInvocation invocation) throws Exception &#123; String result; try &#123; result = invocation.invoke(); &#125; catch (Exception var6) &#123; if (this.isLogEnabled()) &#123; this.handleLogging(var6); &#125; List&lt;ExceptionMappingConfig&gt; exceptionMappings = invocation.getProxy().getConfig().getExceptionMappings(); String mappedResult = this.findResultFromExceptions(exceptionMappings, var6); if (mappedResult == null) &#123; throw var6; &#125; result = mappedResult; this.publishException(invocation, new ExceptionHolder(var6)); &#125; return result;&#125; 其中：result = invocation.invoke();这句话已经就调用了Action了 1List&lt;ExceptionMappingConfig&gt; exceptionMappings = invocation.getProxy().getConfig().getExceptionMappings(); 这句找到一系列映射，找到映射后：1String mappedResult = this.findResultFromExceptions(exceptionMappings, var6); 然后将映射结果赋值给result：result = mappedResult;最后执行：this.publishException(invocation, new ExceptionHolder(var6)); publishException代码：123protected void publishException(ActionInvocation invocation, ExceptionHolder exceptionHolder) &#123; invocation.getStack().push(exceptionHolder);&#125; 将exceptionHolder压到栈里。 第六十八课. DefaultActionRef_Bug看我们以前写的一段代码（struts.xml）：12345678&lt;package name="front" namespace="/" extends="struts-default" &gt; &lt;default-action-ref name="Category_list" /&gt; &lt;action name="t" class="com.bjsxt.bbs2009.action.CategoryAction" method="list"&gt; &lt;result&gt;/index.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 上面代码有一句：&lt;default-action-ref name=&quot;Category_list&quot; /&gt; 这一句配置了一个默认的action，但是我们试图去使用默认的action访问的时候，发现只会直接返回result结果，不会执行class里的Action对象方法。我们认为这是一个bug。 怎么去解决这个bug呢？ 直接去web.xml中进行修改：123&lt;welcome-file-list&gt; &lt;welcome-file&gt;index &lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 将原先的index.jsp改成了index 然后修改struts.xml： 12345678&lt;package name="front" namespace="/" extends="struts-default" &gt; &lt;default-action-ref name="Category_list" /&gt; &lt;action name="index" class="com.bjsxt.bbs2009.action.CategoryAction" method="list"&gt; &lt;result&gt;/index.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第六十九课. Struts2 I18N原理创建一个名字叫struts2_3100_I18N_Test的Java空项目 在src下创建两个配置文件：12345app_en_US.properties：welcome.msg=hello,sirapp_zh_CN.properties：welcome.msg=HUANYIN 创建一个Test.java：123456789import java.util.Locale;import java.util.ResourceBundle;public class Test &#123; public static void main(String[] args) &#123; ResourceBundle res = ResourceBundle.getBundle("app", Locale.CHINA); System.out.println(res.getString("welcome.msg")); &#125;&#125; getBundle中第一个参数找到开头是app的配置文件，有两个；然后由于地区是：Locale.CHINA所以选择app_zh_CN.properties来进行显示，显示的字符串是welcome.msg，也就是HUANYIN： 但是如果把中文配置文件换成汉字，再进行测试，发现显示出现了乱码 解决办法：在Dos下切换到我们工程的src文件夹下，然后执行jdk下native2ascii命令：&quot;c:\Program Files\Java\jdk1.8.0_111\bin\native2ascii&quot; app_zh_CN_temp.properties app_zh_CN.properties 这样就帮我们在src下生成了一个将文字转化为UTF-8形式的ascii编码的app_zh_CN.properties再测试： 这样就可以了 其实idea中有一个更加简单的方法，不需要每一次去命令行做转换。具体配置就是：更改系统配置：File-&gt;Settings–&gt;Editor–&gt;File Encodings，选中“Transparent native-to-ascii conversion”。这样我们直接在配置文件里写中文就可以了。 第七十课. Action级别I18N问题由于在struts.xml中有这样一段配置：1234&lt;action name="*-*" class="com.bjsxt.bbs2009.action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt; &lt;result name="input"&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt;&lt;/action&gt; 那么我们在输入Login-input这样的action以后，就会去执行LoginAction的input方法。 LoginAction的代码：1234567891011121314151617181920212223242526272829303132333435package com.bjsxt.bbs2009.action;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport &#123; private String username; private String password; public String login() throws Exception &#123; return "success"; &#125; public String input() &#123; return "input"; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 这个类中有一个input方法，返回一个input，struts2在接收到这样的一个返回值后，会执行/admin/Login-input.jsp这个页面，代码是：12345&lt;form action="admin/Login-login" method="post"&gt; 用户名: &lt;input name="username" /&gt; 密码: &lt;input name="password" type="password" /&gt; &lt;input type="submit" value="登录" /&gt; &lt;/form&gt; 显示效果： 输入用户名和密码之后，表格提交到/admin/Login-login.jsp页面，这个页面的代码是：123&lt;body&gt;欢迎你&lt;s:property value="username"/&gt;&lt;/body&gt; 从值栈中获取到了用户名并显示在前端页面上： 但是我们还想国际化，下面就来做国际化的工作。 Struts的资源文件分为三个级别：Action-Package-App级 创建中英文资源配置文件： 123456789LoginAction_en_US.properties内容：login.username=username:login.password=password:login.login=loginLoginAction_zh_CN.properties内容：login.username=用户名:login.password=密码:login.login=登录 在Login-input.jsp中引入标签：12345678&lt;%@taglib uri="/struts-tags" prefix="s" %&gt;form也进行修改：&lt;form action="admin/Login-login" method="post"&gt; &lt;s:property value="getText('login.username')"/&gt; &lt;input name="username" /&gt; &lt;s:property value="getText('login.password')"/&gt;&lt;input name="password" type="password" /&gt; &lt;input type="submit" value="&lt;s:property value="getText('login.login')"/&gt;" /&gt; &lt;/form&gt; 这样我们设置浏览器的语言，就会自动帮我们将中文翻译成英文了。 上面这种方式是Action级别的国际化，只有一个Action可以被国际化。 包级别的不常用，命名是：package_en_US.properties 我们最常用的还是第三种方式，就是App级别的：123456789bbs2009_en_US.properties：login.username=username:login.password=password:login.login=loginbbs2009_zh_CN.properties：login.username=用户名:login.password=密码:login.login=登录 然后在我们的struts.xml中添加这样的句子：&lt;constant name=&quot;struts.custom.i18n.resources&quot; value=&quot;bbs2009&quot;&gt;&lt;/constant&gt;这样配好前缀名之后，就会帮我们找到想要的资源包了。 下面想一个问题，就是如何让欢迎语句和我们传入的用户名进行组合，并国际化显示呢？ 1234567891011bbs2009_en_US.properties:login.username=username:login.password=password:login.login=loginwelcome.msg=welcome:&#123;0&#125;bbs2009_zh_CN.properties:login.username=用户名:login.password=密码:login.login=登录welcome.msg=欢迎你&#123;0&#125; 其中{0}是一个占位符，用来存放我们输入的用户名。 对Login-login.jsp进行修改： 123456&lt;body&gt; &lt;%--欢迎你&lt;s:property value="username"/&gt;--%&gt;&lt;s:text name="welcome.msg"&gt; &lt;s:param value="username"&gt;&lt;/s:param&gt;&lt;/s:text&gt; &lt;/body&gt; 显示语句是welcome.msg，对于占位符，设置它的值是username 这样再试一次，就可以成功显示国际化的页面了： 第七十三课. I18N 4 动态语言切换发现将页面语言从中文转换到英文非常简单，只需要在链接后面追加一个参数：http://127.0.0.1:8888/admin/Login-input?request_locale=en_US这样就可以了： 而且整个session都变成了英文。 有了这个思路，我们就可以在代码中来动态切换语言了。 在action文件夹下，添加LangAction.java：123456789101112package com.bjsxt.bbs2009.action;import com.opensymphony.xwork2.ActionSupport;public class LangAction extends ActionSupport &#123; @Override public String execute() throws Exception &#123; return super.execute(); &#125;&#125; 然后在struts.xml中添加针对这个Action的package：123&lt;action name="lang" class="com.bjsxt.bbs2009.action.LangAction"&gt; &lt;result&gt;/admin/Login-input.jsp&lt;/result&gt;&lt;/action&gt; 在Login-input.jsp中添加两个链接：12&lt;a href="admin/lang?request_locale=en_US"&gt;en&lt;/a&gt;&lt;a href="admin/lang?request_locale=zh_CN"&gt;cn&lt;/a&gt; 这样就会在执行lang这个action的时候，在链接后面追加上request_locale=en_US或是request_locale=zh_CN 这样就可以支持在页面上动态切换中英文了： 总结：I18N： I18N原理a) ResourceBundle和Locale的概念b) 资源文件c) native2ascii Struts的资源文件a) Action-Package-App级b) 一般只用APPi. struts.xml custom.i18nc) 动态语言切换i. request_locale=en_US 第七十五课. Struts2 源码解析 第七十六课. 拦截器原理模拟Main.java： 12345public class Main &#123; public static void main(String[] args) &#123; new ActionInvocation().invoke(); &#125;&#125; ActionInvocation.java: 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.List;public class ActionInvocation &#123; List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;(); int index = -1; Action a = new Action(); public ActionInvocation()&#123; this.interceptors.add(new FirstInterceptor()); this.interceptors.add(new SecondInterceptor()); &#125; public void invoke() &#123; index++; if (index &gt;= this.interceptors.size())&#123; a.execute(); &#125; else&#123; this.interceptors.get(index).intercept(this); &#125; &#125;&#125; Interceptor.java: 123public interface Interceptor &#123; public void intercept(ActionInvocation invocation);&#125; FirstInterceptor.java: 123456789public class FirstInterceptor implements Interceptor &#123; @Override public void intercept(ActionInvocation invocation) &#123; System.out.println(1); invocation.invoke(); System.out.println(-1); &#125;&#125; SecondInterceptor.java: 123456789public class SecondInterceptor implements Interceptor &#123; @Override public void intercept(ActionInvocation invocation) &#123; System.out.println(2); invocation.invoke(); System.out.println(-2); &#125;&#125; Action.java: 12345public class Action &#123; public void execute()&#123; System.out.println("execute!"); &#125;&#125; 运行结果： 这样就模拟了一个拦截器的过程。 第七十七课. 自定义拦截器.定义一个自己的拦截器(MyInterceptor.java)：12345678910111213141516171819202122232425262728package com.bjsxt.interceptor;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.Interceptor;public class MyInterceptor implements Interceptor &#123; @Override public void destroy() &#123; &#125; @Override public void init() &#123; &#125; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; long start = System.currentTimeMillis(); String r = invocation.invoke(); long end = System.currentTimeMillis(); System.out.println("action time = " + (end - start)); return r; &#125;&#125; 配置struts.xml文件：1234567891011121314151617&lt;struts&gt; &lt;constant name="struts.devMode" value="true"&gt;&lt;/constant&gt; &lt;package name="test" namespace="/" extends="struts-default"&gt; &lt;interceptors&gt; &lt;interceptor name="my" class="com.bjsxt.interceptor.MyInterceptor"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt; &lt;action name="test" class="com.bjsxt.action.TestAction"&gt; &lt;result&gt;/test.jsp&lt;/result&gt; &lt;interceptor-ref name="my"&gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 这样就加入了我们的拦截器，运行一下，就会将我们程序运行的时间显示在控台上。 第七十八课. 使用token拦截器控制重复提交.一旦有人在表单提交了一个数据，如果页面反应比较慢，用户就会不停地刷新，那么这个时候就会将已经提交的数据反复提交，就在数据库插入了多条重复数据，这样是不正确的。 struts2 token 使用说明使用token标签的时候，Struts2会建立一个GUID（全局唯一的字符串）放在session中，并且会成为一个hidden放在form中。token拦截器会判断客户端form提交的token和session中保存的session是否equals。如果equals则执行Action。否则拦截器直接返回invaid.token结果，Action对应的方法也不会执行 1.首先我们在jsp页面上导入struts标签库 &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt;2.在表单中添加标签123456&lt;form action="user/login" method="get"&gt; 用户名：&lt;input name="username"&gt;&lt;br&gt; 密码：&lt;input name="password"&gt;&lt;br&gt; &lt;s:token&gt;&lt;/s:token&gt; &lt;input type="submit" value="登录"&gt; &lt;/form&gt; 3.添加了的表单在服务器返回之后会被添加一个隐藏域用于存储token这个令牌 123456&lt;form action="" method="post"&gt; 用户ID：&lt;input name="user.id"&gt; 姓名：&lt;input name="user.name"&gt; &lt;input type="hidden" name="struts.token.name" value="token" /&gt;&lt;input type="hidden" name="token" value="11R5FX3JFC3QB2QUQ0M717U2A2RUCI66" /&gt; &lt;script type="text/javascript"&gt; 4.在struts.xml中配置token的拦截1234567&lt;action name="login" class="com.xiangzi.action.UserAction"&gt; &lt;result name="success"&gt;/ok.jsp&lt;/result&gt; &lt;interceptor-ref name="defaultStack" &gt;&lt;/interceptor-ref&gt; &lt;interceptor-ref name="token" &gt;&lt;/interceptor-ref&gt; &lt;result name="invalid.token"&gt;/error.jsp&lt;/result&gt;&lt;/action&gt; 注意：1.这里需要些两个拦截器，默认的defaultStack要在上面，token在下面，为了能是所有拦截器有效2.这个 映射的action.class是需要继承ActionSupport这个类的，不然struts识别不了3.要在这个 中配置一个 name=”incalid.token” 的result结果，作为拦截之后的跳转 这样我们反复提交的时候就会返回错误界面： 第八十课. 类型转换 类型转换a) 默认转换 i. 日期处理b) 写自己的转换器：第一种：12345678910111213141516171819public class MyPointConverter extends DefaultTypeConverter&#123; @Override public Object convertValue(Object value, Class toType) &#123; if(toType == Point.class) &#123; Point p = new Point(); String[] strs = (String[])value; String[] xy = strs[0].split(","); p.x = Integer.parseInt(xy[0]); p.y = Integer.parseInt(xy[1]); return p; &#125; if(toType == String.class) &#123; return value.toString(); &#125; return super.convertValue(value, toType); &#125; &#125; 第二种：123456789101112131415161718192021222324public class MyPointConverter extends StrutsTypeConverter&#123; @Override public Object convertFromString(Map context, String[] values, Class toClass) &#123; Point p = new Point(); String[] strs = (String[])values; String[] xy = strs[0].split(","); p.x = Integer.parseInt(xy[0]); p.y = Integer.parseInt(xy[1]); return p; &#125; @Override public String convertToString(Map context, Object o) &#123; // TODO Auto-generated method stub return o.toString(); &#125; &#125; c) 三种注册方式： i. 局部：XXXAction-conversion.properties p（属性名称） = converter ii. 全局：xwork-conversion.properties com.xxx.XXX（类名）= converteriii. Annotationd) 如果遇到非常麻烦的映射转换 i. request.setAttribute(); ii. session test.jsp里面这么写：123456789101112&lt;body&gt; name:&lt;s:property value="name"/&gt;&lt;br/&gt; age:&lt;s:property value="age"/&gt;&lt;br/&gt; date:&lt;s:property value="d"/&gt;&lt;br/&gt; &lt;s:date name="d" format="yyyy/MM/dd HH:mm:ss"/&gt;&lt;br/&gt; &lt;s:property value="interests"/&gt;&lt;br/&gt; &lt;s:property value="users"/&gt;&lt;br/&gt; &lt;s:property value="p"/&gt;&lt;br/&gt; &lt;s:property value="ps"/&gt;&lt;br/&gt; points:&lt;s:property value="points"/&gt;&lt;br/&gt; &lt;/body&gt; TestAction里面这么写：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class TestAction extends ActionSupport &#123; private String name; private int age; private Date d; Set&lt;String&gt; interests; Map&lt;String, String&gt; users; Point p; List&lt;Point&gt; ps; Map&lt;String, Point&gt; points; @Override public String execute() throws Exception &#123; return super.execute(); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Date getD() &#123; return d; &#125; public void setD(Date d) &#123; this.d = d; &#125; public Set&lt;String&gt; getInterests() &#123; return interests; &#125; public void setInterests(Set&lt;String&gt; interests) &#123; this.interests = interests; &#125; public Map&lt;String, String&gt; getUsers() &#123; return users; &#125; public void setUsers(Map&lt;String, String&gt; users) &#123; this.users = users; &#125; public Point getP() &#123; return p; &#125; public void setP(Point p) &#123; this.p = p; &#125; public List&lt;Point&gt; getPs() &#123; return ps; &#125; public void setPs(List&lt;Point&gt; ps) &#123; this.ps = ps; &#125; public Map&lt;String, Point&gt; getPoints() &#123; return points; &#125; public void setPoints(Map&lt;String, Point&gt; points) &#123; this.points = points; &#125; &#125; 链接这么写： 第八十四课. 总结 Actiona) namespace（掌握）b) path（掌握）c) DMI（掌握）d) wildcard（掌握）e)接收参数（掌握前两种）f)访问request等（掌握Map IOC方式）g)简单数据验证（掌握addFieldError和&lt;s:fieldError） Resulta)结果类型（掌握四种，重点两种）b)全局结果（掌握）c)动态结果（了解） OGNL表达式（精通）a) # % $ Struts标签a)掌握常用的 声明式异常处理（了解） I18N（了解） CRUD的过程（最重要是设计与规划）（精通） Interceptor的原理（掌握） 类型转换（掌握默认，了解自定义）]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 447.Number of Boomerangs]]></title>
    <url>%2F2017%2F12%2F07%2Fleetcode447%2F</url>
    <content type="text"><![CDATA[题目大意：给定平面上的n个两两不同的点，一个“回飞镖”是指一组点(i, j, k)满足i到j的距离=i到k的距离（考虑顺序） 计算回飞镖的个数。你可以假设n最多是500，并且点坐标范围在 [-10000, 10000] 之内。解题思路：枚举点i(x1, y1)，计算点i到各点j(x2, y2)的距离，并分类计数 利用排列组合知识，从每一类距离中挑选2个点的排列数 A(n, 2) = n * (n - 1) 将上述结果累加即为最终答案 代码：123456789101112131415161718192021class Solution &#123; public int numberOfBoomerangs(int[][] points) &#123; int distance = 0; int res = 0; for(int i = 0; i &lt; points.length; i++)&#123; HashMap&lt;Integer, Integer&gt; hm = new HashMap(); for(int j = 0; j &lt; points.length; j++)&#123; if(i == j) continue; distance = (points[i][0]-points[j][0]) * (points[i][0]-points[j][0]) + (points[i][1]-points[j][1]) * (points[i][1]-points[j][1]); hm.put(distance, hm.getOrDefault(distance , 0) + 1); &#125; for(int val : hm.values()) res += val * (val-1); hm.clear(); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2笔记（五）Struts2版本BBS搭建全过程]]></title>
    <url>%2F2017%2F12%2F07%2FStruts2-5%2F</url>
    <content type="text"><![CDATA[本文主要介绍利用Struts2来搭建一个bbs的全过程。 第五十四课.设计约定（编码规定） a) 原则：简单就是美 b) 库名：项目名 c) 表的命名：_Model名 d) 字段：保持和属性名一致（尽量不要起名和数据库命名冲突） e) 用层来划分包 com.bjsxt.bbs.action model(bean) service DTO f) Action XXXXAction(Action以Action命名结尾) g) *_* h) / i) /admin j) package “action” adminAction 第五十五课.项目开发顺序-以BBS2009的名义 建立界面原型 建立Struts.xmla) 确定namespaceb）确定packagec） 确定Action 的名称 空的方法d） 确定 Resulte） 讲界面原型页面进行 修改 匹配现有设置f） 测试 建立数据库（或者实体类） 建立Model层 建立Service层（后面讲了Hibernate后再完善）a) 此时可以使用Junit进行单元测试了 着手开发 我们先搭建一个界面原形，直接到一个自己看起来还不错的网站上扒代码，做成我们的前端和后台管理页面，效果是这样的： 前台页面： 后台管理页面： 第五十六课. BBS2009 初步了解ExtJS我们先了解一下ext框架。创建一个项目ext3.0，直接把ext3.0的包整个粘过来： 访问网址： 发现在这个页面下，可以直接去学习ext的API文档。 我们将ext包引入我们的博客，用来给我们的网站提供前端支持。 比如我们在index.html中来显示一个alert，就可以直接用ext中的API：123456&lt;script type="text/javascript"&gt; Ext.onReady( function() &#123; Ext.Msg.alert('ext','welcome you!'); var addPanel = function(btn, event) &#123; var n; n = tabPanel.getComponent(btn.id); 访问一下： 发现可以调用我们ext框架的API 我们来研究一下界面整体布局： 在index.html中定义一个accordion变量，它是一个Ext.Panel，用来装载五个item： 12345678var accordion = new Ext.Panel( &#123; region : 'west', margins : '5 0 5 5', split : true, width : 210, layout : 'accordion', items : [ item1, item2, item3, item4, item5 ]&#125;); item1:123456789101112131415161718192021222324252627var item1 = new Ext.Panel( &#123; title : 'Category管理', //html : '&amp;lt;empty panel&amp;gt;', cls : 'empty', items : [ new Ext.Button(&#123; id : 'Category_list', text : 'Category列表', width : '100%', listeners : &#123; click : addPanel &#125; &#125;), new Ext.Button(&#123; id : 'test', text : 'Test', width : '100%', listeners : &#123; click : addPanel &#125; &#125;) ]&#125;); 它也是一个Ext.Panel，用来装载两个item 剩下几个item都是相似的。 整体布局：1234var viewport = new Ext.Viewport( &#123; layout : 'border', items : [ accordion, tabPanel ]&#125;); 左边是accordion，右边是tabPable:12345678910111213var tabPanel = new Ext.TabPanel( &#123; region : 'center', enableTabScroll : true, deferredRender : false, activeTab : 0, items : [ &#123; title : 'index', //html : 'aaaaaa' autoLoad : 'Category_add.jsp' &#125; ]&#125;); 其中autoLoad是一个自动加载过程，所以我们可以看到Category_add.jsp被自动加载了进来： activeTab : 0是激活第一个tab 添加一个panel的方法：12345678910111213141516var addPanel = function(btn, event) &#123; var n; n = tabPanel.getComponent(btn.id); if(n) &#123; tabPanel.setActiveTab(n); return; &#125; n = tabPanel.add( &#123; id : btn.id, title : btn.id, html : '&lt;iframe width=100% height=100% src=' + btn.id + ' /&gt;', //autoLoad : '', closable : 'true' &#125;); tabPanel.setActiveTab(n);&#125; 如果没有与点击的按钮id相同的tab，那么就新生成并且激活一个tab，如果有了，就不创建新的了。 html : &#39;&lt;iframe width=100% height=100% src=&#39; + btn.id + &#39; /&gt;&#39;这一句，是将tab的页面里写了一个iframe，这个iframe里面可以映射我们想要的页面。 第五十七课. 建立项目框架1前面我们已经把界面设计好了，下面我就建立struts.xml文件 前台的package： 1234567&lt;package name="front" namespace="/" extends="struts-default" &gt; &lt;default-action-ref name="Category_list" /&gt; &lt;action name="Category_list" class="com.bjsxt.bbs2009.action.CategoryAction" method="list"&gt; &lt;result&gt;/index.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 这个包的名字叫front，命名空间是在/下面，继承默认配置包，Action名字叫Category_list，并且设置为默认的Action，在没有url追加的情况下默认执行这个Action。Action类我们先添加一个list方法：12345678910111213141516package com.bjsxt.bbs2009.action;import java.util.List;import com.bjsxt.bbs2009.model.Category;import com.opensymphony.xwork2.ActionSupport;public class CategoryAction extends ActionSupport &#123; private List&lt;Category&gt; categories; public String list() &#123; return SUCCESS; &#125; &#125;&#125; 这样我们访问http://localhost:8888的时候，就会返回index.jsp这个页面了。 我们尝试访问http://localhost:8888/admin/Category_list发现也会访问成功比如再前面追加一些前缀： 也可以访问成功说明一个结论：一个namespace中如果没有对应的Category_list的时候，它会去父亲的namespace中找。 我们在struts.xml中加入如下配置：1234567&lt;package name="admin" namespace="/admin" extends="struts-default" &gt; &lt;action name="Category_list" class="com.bjsxt.bbs2009.action.CategoryAction" method="list"&gt; &lt;result&gt;/admin/Category_list.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 在这个package里，我们定义了自己的命名空间和action名字，所以访问结果如下： 可以看到我们自己写的Category_list可以被顺利访问到了。 有了这么一次实验的成功，我们可以使用通配符来完成其他action的跳转，修改上面的package（由于文件命名中带下划线的有些bug，所以改成用-）：1234567&lt;package name="admin" namespace="/admin" extends="struts-default" &gt; &lt;action name="*-*" class="com.bjsxt.bbs2009.action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 我们将文件名字也做相应修改： 访问一下： 成功！ 我们来完善我们的Category-list.jsp，使这个jsp中包括跳转到添加目录、更新目录和删除目录的界面上去： 123456 &lt;body&gt;Category_list&lt;a href="admin/Category-add"&gt;添加Category&lt;/a&gt;&lt;a href="admin/Category-update"&gt;更新Category&lt;/a&gt;&lt;a href="admin/Category-delete"&gt;删除Category&lt;/a&gt; &lt;/body&gt; 完善Action（比如执行admin/Category-addInput时候，由于struts.xml是：1234&lt;action name="*-*" class="com.bjsxt.bbs2009.action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt;&lt;/action&gt; 所以method是add，但是我们之前的CategoryAction中没有add方法，所以我们完善我们的CategoryAction类：12345678910111213141516public class CategoryAction extends ActionSupport &#123; private List&lt;Category&gt; categories; public String list() &#123; return SUCCESS; &#125; public String add() &#123; return SUCCESS; &#125; public String update() &#123; return SUCCESS; &#125; public String delete() &#123; return SUCCESS; &#125;&#125; 重新部署tomcat，再来运行一下这个链接： 可以顺利跳转过去。 但是我们的目标，是在点击“添加Catgegory”按钮之后，跳转到admin/Category-update-input.jsp里面，所以这个我们还需要考虑完善。 第五十八课. 建立项目框架2为了解决上面的问题，我们在我们的Action类中添加两个方法：123456public String addInput() &#123; return INPUT;&#125;public String updateInput() &#123; return INPUT;&#125; 两个返回值都是INPUT，然后我们在我们的struts.xml中进行配置：1234&lt;action name="*-*" class="com.bjsxt.bbs2009.action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt; &lt;result name="input"&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt;&lt;/action&gt; 可以看到这一次的struts.xml中加入了针对INPUT返回值的result，比如我们访问“添加目录”，就会访问http://localhost:8888/admin/Category-addInput，然后就会执行Action的addInput方法，返回input以后，我们会显示Category-addInput.jsp，所以我们可以将之前的添加输入文件改名叫Category-addInput.jsp: 我们来看一下效果： 成功！ 为了使add之后显示一个提示添加成功的页面，我们这么写：1234567&lt;body&gt;&lt;form action="admin/Category-add" method="post"&gt; name:&lt;input name="category.name" /&gt; description:&lt;textarea name="category.description"&gt;&lt;/textarea&gt; &lt;input type="submit" value="add" /&gt; &lt;/form&gt;&lt;/body&gt; 最后form执行post请求后，跳转到Category-add这个Action。 这样我们的项目框架就搭好了。 再来回顾一下整体流程： 建立界面原型 建立Struts.xmla) 确定namespaceb）确定packagec） 确定Action 的名称 空的方法d） 确定 Resulte） 讲界面原型页面进行修改，匹配现有设置f） 测试 第五十九课. 建立数据库首先我们来创建我们的数据库和表：12345create database bbs2009;use bbs2009;create table _category(id int primary key auto_increment, name varchar(50), description varchar(200)); 这样就创建好了我们的数据库了 我们为了便于后续开发人员创建数据库，可以将这个做成一个sql文件，放在项目的sql文件夹下。 第六十课. 建立Model与Service层1.先建立Model： 定义Category：1234567891011121314151617181920212223242526272829303132package com.bjsxt.bbs2009.model;public class Category &#123; private int id; private String name; private String description; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getDescription() &#123; return description; &#125; public void setDescription(String description) &#123; this.description = description; &#125;&#125; 这样我们的model就建立好了。 接下来建立我们的service，先搭好service的框架： 代码：12345678910111213141516171819202122232425262728package com.bjsxt.bbs2009.service;import com.bjsxt.bbs2009.model.Category;import java.util.List;public class CategoryService &#123; public void add(Category c) &#123; &#125; public List&lt;Category&gt; list()&#123; return null; &#125; public void delete(Category c)&#123; deleteById(c.getId()); &#125; public void deleteById(int id)&#123; &#125; public void update(Category c)&#123; &#125;&#125; 再创建连接数据库需要的类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.bjsxt.bbs2009.util;import java.sql.*;public class DB &#123; public static Connection createConn() &#123; Connection conn = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost/bbs2009", "root", "09129421"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static PreparedStatement prepare(Connection conn, String sql)&#123; PreparedStatement ps = null; try &#123; ps = conn.prepareStatement(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return ps; &#125; public static void close(Connection conn)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(Statement stmt)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(ResultSet rs)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 第六十二课. 建立Model与Service层2.上面建立了数据库，建立了使用数据库的各种接口，并且搭好了service的框架，下面我们就要来使用这些接口来完善service：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.bjsxt.bbs2009.service;import com.bjsxt.bbs2009.model.Category;import com.bjsxt.bbs2009.util.DB;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class CategoryService &#123; public void add(Category c) &#123; Connection conn = DB.createConn(); String sql = "insert into _category values (null, ?, ?)"; PreparedStatement ps = DB.prepare(conn, sql); try &#123; ps.setString(1, c.getName()); ps.setString(2, c.getDescription()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DB.close(ps); DB.close(conn); &#125; public List&lt;Category&gt; list()&#123; Connection conn = DB.createConn(); String sql = "select * from _category"; PreparedStatement ps = DB.prepare(conn, sql); List&lt;Category&gt; categories = new ArrayList&lt;Category&gt;(); try&#123; ResultSet rs = ps.executeQuery(); Category c = null; while(rs.next())&#123; c = new Category(); c.setName(rs.getString("name")); c.setDescription(rs.getString("description")); categories.add(c); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DB.close(ps); DB.close(conn); return categories; &#125; public void delete(Category c)&#123; deleteById(c.getId()); &#125; public void deleteById(int id)&#123; Connection conn = DB.createConn(); String sql = "delete from _category where id = ?"; PreparedStatement ps = DB.prepare(conn, sql); try&#123; ps.setInt(1, id); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DB.close(ps); DB.close(conn); &#125; public void update(Category c)&#123; Connection conn = DB.createConn(); String sql = "update _category set name = ?, description = ? where id = ?"; PreparedStatement ps = DB.prepare(conn, sql); try &#123; ps.setString(1, c.getName()); ps.setString(2, c.getDescription()); ps.setInt(3, c.getId()); ps.executeUpdate(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DB.close(ps); DB.close(conn); &#125;&#125; 通过util.DB中的接口，我们实现了service中对于目录的增删改查。 第六十三课. 实现页面与Action 1.这一节中，我们将Action和Service联系起来，使得我们在前台进行增删改查的操作时，可以直接影响到数据库。 修改CategoryAction.java:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.bjsxt.bbs2009.action;import java.util.List;import com.bjsxt.bbs2009.model.Category;import com.bjsxt.bbs2009.service.CategoryService;import com.opensymphony.xwork2.ActionSupport;public class CategoryAction extends ActionSupport &#123; private List&lt;Category&gt; categories; private CategoryService categoryService = new CategoryService(); public List&lt;Category&gt; getCategories() &#123; return categories; &#125; public void setCategories(List&lt;Category&gt; categories) &#123; this.categories = categories; &#125; public CategoryService getCategoryService() &#123; return categoryService; &#125; public void setCategoryService(CategoryService categoryService) &#123; this.categoryService = categoryService; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; private Category category; private int id; public String list() &#123; categories = categoryService.list(); return SUCCESS; &#125; public String add() &#123; categoryService.add(category); return SUCCESS; &#125; public String update() &#123; categoryService.update(category); return SUCCESS; &#125; public String delete() &#123; categoryService.deleteById(id); return SUCCESS; &#125; public String addInput() &#123; return INPUT; &#125; public String updateInput() &#123; return INPUT; &#125;&#125; 在struts加入index的action：12345678910&lt;package name="admin" namespace="/admin" extends="struts-default" &gt; &lt;action name="index"&gt; &lt;result&gt;/admin/index.html&lt;/result&gt; &lt;/action&gt; &lt;action name="*-*" class="com.bjsxt.bbs2009.action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt; &lt;result name="input"&gt;/admin/&#123;1&#125;-&#123;2&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 修改index.html文件，因为原来的index.html中category按钮映射到的id是：Category_list，现在我们将其改成符合我们的id：Category-list： 123456789101112131415161718192021222324252627var item1 = new Ext.Panel( &#123; title : 'Category管理', //html : '&amp;lt;empty panel&amp;gt;', cls : 'empty', items : [ new Ext.Button(&#123; id : 'Category-list', text : 'Category列表', width : '100%', listeners : &#123; click : addPanel &#125; &#125;), new Ext.Button(&#123; id : 'test', text : 'Test', width : '100%', listeners : &#123; click : addPanel &#125; &#125;) ]&#125;); 现在我们就将前端和后台数据库联系起来了，来实验一下： 页面显示添加成功。现在我们来看数据库里的数据，是否添加成功： 成功！ 第六十四课. 实现页面与Action 2.为了让Category列表可以顺利将数据库已经插入的数据展示在前台页面，我们在Category-list.jsp中增加代码：12345678910111213 &lt;body&gt;Category_list&lt;a href="admin/Category-addInput"&gt;添加Category&lt;/a&gt;&lt;a href="admin/Category-updateInput"&gt;更新Category&lt;/a&gt;&lt;a href="admin/Category-delete"&gt;删除Category&lt;/a&gt; &lt;hr/&gt; &lt;s:iterator value="categories" var="c"&gt; &lt;s:property value="#c.name"/&gt; | &lt;s:property value="#c.description"/&gt; | &lt;/s:iterator&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;/body&gt;&lt;/html&gt; 这样，我们就将数据库中的数据进行遍历并且予以展示了。 增加一组数据，看一下效果： 然后我们来增加删除的操作：Category-list.jsp：123456789101112131415&lt;body&gt;Category_list&lt;a href="admin/Category-addInput"&gt;添加Category&lt;/a&gt;&lt;a href="admin/Category-updateInput"&gt;更新Category&lt;/a&gt;&lt;a href="admin/Category-delete"&gt;删除Category&lt;/a&gt;&lt;hr/&gt;&lt;s:iterator value="categories" var="c"&gt; &lt;s:property value="#c.name"/&gt; | &lt;s:property value="#c.description"/&gt; | &lt;a href="admin/Category-delete?id=&lt;s:property value="#c.id"/&gt;"&gt;删除Category&lt;/a&gt; &lt;br/&gt;&lt;/s:iterator&gt;&lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 在CategoryService.java中，在list()方法里增加一条设置id的语句：12345678910111213141516171819202122public List&lt;Category&gt; list()&#123; Connection conn = DB.createConn(); String sql = "select * from _category"; PreparedStatement ps = DB.prepare(conn, sql); List&lt;Category&gt; categories = new ArrayList&lt;Category&gt;(); try&#123; ResultSet rs = ps.executeQuery(); Category c = null; while(rs.next())&#123; c = new Category(); c.setId(rs.getInt("id")); c.setName(rs.getString("name")); c.setDescription(rs.getString("description")); categories.add(c); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DB.close(ps); DB.close(conn); return categories;&#125; 这样我们就实现了对列表的删除操作： 点第二个： 查看列表: 成功了。 现在有了增、查、删，我们最后需要完成的是对数据的改操作： 先在Category-list.jsp中加入对修改的支持：1234567&lt;s:iterator value="categories" var="c"&gt; &lt;s:property value="#c.name"/&gt; | &lt;s:property value="#c.description"/&gt; | &lt;a href="admin/Category-delete?id=&lt;s:property value="#c.id"/&gt;"&gt;删除Category&lt;/a&gt; | &lt;a href="admin/Category-updateInput?id=&lt;s:property value="#c.id"/&gt;"&gt;更新Category&lt;/a&gt; &lt;br/&gt;&lt;/s:iterator&gt; 在CategoryService.java中加入，从而创建了一个可以传到前台的内容：12345678910111213141516171819202122public Category loadById(int id)&#123; Connection conn = DB.createConn(); String sql = "select * from _category where id = ?"; PreparedStatement ps = DB.prepare(conn, sql); Category c = null; try&#123; ps.setInt(1, id); ResultSet rs = ps.executeQuery(); if(rs.next())&#123; c = new Category(); c.setId(rs.getInt("id")); c.setName(rs.getString("name")); c.setDescription(rs.getString("description")); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; DB.close(ps); DB.close(conn); return c;&#125; 修改CategoryAction.java，添加了updateInput方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.bjsxt.bbs2009.action;import java.util.List;import com.bjsxt.bbs2009.model.Category;import com.bjsxt.bbs2009.service.CategoryService;import com.opensymphony.xwork2.ActionSupport;public class CategoryAction extends ActionSupport &#123; private List&lt;Category&gt; categories; private CategoryService categoryService = new CategoryService(); public List&lt;Category&gt; getCategories() &#123; return categories; &#125; public void setCategories(List&lt;Category&gt; categories) &#123; this.categories = categories; &#125; public CategoryService getCategoryService() &#123; return categoryService; &#125; public void setCategoryService(CategoryService categoryService) &#123; this.categoryService = categoryService; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; private Category category; private int id; public String list() &#123; categories = categoryService.list(); return SUCCESS; &#125; public String add() &#123; categoryService.add(category); return SUCCESS; &#125; public String update() &#123; categoryService.update(category); return SUCCESS; &#125; public String delete() &#123; categoryService.deleteById(id); return SUCCESS; &#125; public String addInput() &#123; return INPUT; &#125; public String updateInput() &#123; this.category = this.categoryService.loadById(id); return INPUT; &#125;&#125; struts收到input的返回值，所以直接转到Category-updateInput.jsp文件，这时候要修改的category就已经准备好了。 编写Category-updateInput.jsp：123456789&lt;body&gt;&lt;form action="admin/Category-update" method="post"&gt; &lt;input type="hidden" name="category.id" value="&lt;s:property value="category.id"/&gt;" /&gt; name:&lt;input name="category.name" value="&lt;s:property value="category.name"/&gt;" /&gt; description:&lt;textarea name="category.description"&gt;&lt;s:property value="category.description"/&gt;&lt;/textarea&gt; &lt;input type="submit" value="update" /&gt; &lt;/form&gt;&lt;/body&gt; 上面修改部分不包括id，所以id放在hidden的input里面。提交以后执行admin/Category-update，所以在struts.xml中就会匹配到CategoryAction中的update方法，执行数据库的update操作，这样就把一条数据修改了。 来看一下效果： 修改，把a a改成a b： 提交以后效果： 修改成功！ 第六十五课. 总结项目开发顺序-以BBS2009的名义 建立界面原型 建立Struts.xmla) 确定namespaceb）确定packagec） 确定Action 的名称 空的方法d） 确定 Resulte） 讲界面原型页面进行 修改 匹配现有设置f） 测试 建立数据库（或者实体类） 建立Model层 建立Service层（后面讲了Hibernate后再完善）a) 此时可以使用Junit进行单元测试了 着手开发]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2笔记（四） 标签]]></title>
    <url>%2F2017%2F12%2F07%2FStruts2-4%2F</url>
    <content type="text"><![CDATA[本文主要介绍Struts2中标签的基本用法。 Struts-Tags1.通用标签 a) property b) set i.默认为 action scope,会将值放入 request 和 ActionContext中 ii. page、request、session、application c) bean d) include（对中文文件支持有问题，不建议使用，如需包含，改用jsp包含） e) param f) debug2.控制标签 a) if else if else b) iterator i. collections map enumeration iterator array c) subset3.UI标签 a) theme i. simple xthml(默认)css_html ajax4.AJAX标签 a)补充5.$#%的区别 a) $用户 i18n 和 struts 配置文件 b) #取得 ActionContext 的值 c) %将原本的文本属性解析为ognl，对于本来就是ognl的属性不起作用 i. 参考&lt;s:property 和 &lt;s:include 第四十四课. Struts标签1 property先看效果： 我们先通过index.jsp来访问action：1234&lt;body&gt; 访问属性 &lt;a href="&lt;%=contextPath %&gt;/tags.action?username=u&amp;password=p"&gt;tags&lt;/a&gt;&lt;/body&gt; 然后访问struts.xml文件，找到tags.actionstruts.xml:123456789101112131415&lt;struts&gt; &lt;!--&lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt;--&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;!--&lt;constant name="struts.ognl.allowStaticMethodAccess" value="true"&gt;&lt;/constant&gt;--&gt; &lt;constant name="struts.ui.theme" value="simple" /&gt; &lt;package name="tags" extends="struts-default"&gt; &lt;action name="tags" class="com.bjsxt.struts2.tags.TagsAction"&gt; &lt;result&gt;/tags.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 则会执行com.bjsxt.struts2.tags.TagsAction这个类的对象：1234567891011121314151617181920212223242526272829303132333435package com.bjsxt.struts2.tags;import com.opensymphony.xwork2.ActionSupport;public class TagsAction extends ActionSupport &#123; private String password; private String username; public TagsAction() &#123; &#125; public String execute() &#123; this.addFieldError("fielderror.test", "wrong!"); return SUCCESS; &#125; public String getPassword() &#123; return password; &#125; public String getUsername() &#123; return username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; &#125; Action对象通过execute方法返回一个SUCCESS, struts.xml接收了这样的一个返回值后，执行result，返回tags.jsp，我们接下来就逐行分析这个jsp里的标签。 tags.jsp里的代码：123456&lt;li&gt;property: &lt;s:property value="username"/&gt; &lt;/li&gt; &lt;li&gt;property 取值为字符串: &lt;s:property value="'username'"/&gt; &lt;/li&gt; &lt;li&gt;property 设定默认值: &lt;s:property value="admin" default="管理员"/&gt; &lt;/li&gt; &lt;li&gt;property 设定HTML: &lt;s:property value="'&lt;hr/&gt;'" escape="false"/&gt; &lt;/li&gt; &lt;li&gt;&lt;s:debug&gt;&lt;/s:debug&gt;&lt;/li&gt; &lt;hr /&gt; 第一句：&lt;li&gt;property: &lt;s:property value=&quot;username&quot;/&gt; &lt;/li&gt;直接从值栈中取出来username的值，也就是u 第二句：&lt;li&gt;property 取值为字符串: &lt;s:property value=&quot;&#39;username&#39;&quot;/&gt; &lt;/li&gt;由于username外面加了单引号，所以它只单纯的表示一个字符串，并不会去取username的值 第三句：&lt;li&gt;property 设定默认值: &lt;s:property value=&quot;admin&quot; default=&quot;管理员&quot;/&gt; &lt;/li&gt;由于值栈中没有admin这个属性，所以就直接用default，也就是默认值来进行显示，所以最后显示的是“管理员” 第四句：&lt;li&gt;property 设定HTML: &lt;s:property value=&quot;&#39;&lt;hr/&gt;&#39;&quot; escape=&quot;false&quot;/&gt; &lt;/li&gt;本来默认escape的值是true，也就是对前面的HTML元素不做解析，只当做单纯的字符串，所以最后显示的是&lt;hr/&gt;但是如果设置escape=&quot;false&quot;，那么就会将&lt;hr/&gt;看作是HTML元素，最后在页面上显示的是一条横线。 第四十五课. Struts标签 2 set效果： 第一句：&lt;li&gt;set 设定adminName值（默认为request 和 ActionContext）: &lt;s:set var=&quot;adminName&quot; value=&quot;username&quot; /&gt;&lt;/li&gt; 设定一个变量adminName，让它的值等于username 第二句：&lt;li&gt;set 从request取值: &lt;s:property value=&quot;#request.adminName&quot; /&gt;&lt;/li&gt; 从request中取出adminName，发现可以取出来 第三句：&lt;li&gt;set 从ActionContext取值: &lt;s:property value=&quot;#adminName&quot; /&gt;&lt;/li&gt; 直接从Stack Context中去取adminName，也是可以取出来的。说明在设置这个变量的时候，会同时放入到request和Stack Context中 接下来研究scope：第一句：&lt;li&gt;set 设定范围: &lt;s:set name=&quot;adminPassword&quot; value=&quot;password&quot; scope=&quot;page&quot;/&gt;&lt;/li&gt;将scope设置为page，那么当前页面都可以访问到adminPassword 我们尝试在第二句中进行访问：&lt;li&gt;set 从相应范围取值: &lt;%=pageContext.getAttribute(&quot;adminPassword&quot;) %&gt;&lt;/li&gt;我们运行后发现是可以成功运行的。将上面两句屏蔽掉（为了取消干扰）第三句：123&lt;li&gt;set 设定var，范围为ActionContext: &lt;s:set var="adminPassword" value="password" scope="session"/&gt;&lt;/li&gt;&lt;li&gt;set 使用#取值: &lt;s:property value="#adminPassword"/&gt; &lt;/li&gt;&lt;li&gt;set 从相应范围取值: &lt;s:property value="#session.adminPassword"/&gt; &lt;/li&gt; 显示效果： 发现使用#不能去除值，但是使用#session.adminPassword可以。我们debug看一下： 发现通过设置scope=”session”，可以在ActionContext中访问到session并取出来adminPassword。 第四十六课. Struts标签 3 bean 1代码：123456789101112131415161718&lt;li&gt;bean 定义bean,并使用param来设定新的属性值: &lt;s:bean name="com.bjsxt.struts2.tags.Dog" &gt; &lt;%--&lt;s:param name="name" value="'pp'"&gt;&lt;/s:param&gt;--%&gt; &lt;%--&lt;s:property value="name"/&gt;--%&gt; &lt;/s:bean&gt; &lt;/li&gt; &lt;li&gt;bean 查看debug情况: &lt;s:bean name="com.bjsxt.struts2.tags.Dog" var="myDog"&gt; &lt;%--&lt;s:param name="name" value="'oudy'"&gt;&lt;/s:param&gt;--%&gt; &lt;/s:bean&gt; 拿出值： &lt;s:property value="#myDog.name"/&gt; &lt;/li&gt; 先看效果： debug，发现在ActionContext中有myDog这个变量，里面值是null： 修改：12345678&lt;li&gt;bean 查看debug情况: &lt;s:bean name="com.bjsxt.struts2.tags.Dog" var="myDog"&gt; &lt;s:param name="name" value="'oudy'"&gt;&lt;/s:param&gt; &lt;/s:bean&gt; 拿出值： &lt;s:property value="#myDog.name"/&gt; &lt;/li&gt; 注意name的value内容要加单引号，因为如果不加会当成ognl表达式，加了以后就当做字符串，这时候我们再debug，发现myDog有了oudy： 修改代码：1234567891011121314151617&lt;li&gt;bean 定义bean,并使用param来设定新的属性值: &lt;s:bean name="com.bjsxt.struts2.tags.Dog" &gt; &lt;s:param name="name" value="'pp'"&gt;&lt;/s:param&gt; &lt;s:property value="name"/&gt; &lt;/s:bean&gt; &lt;/li&gt;&lt;li&gt;bean 查看debug情况: &lt;s:bean name="com.bjsxt.struts2.tags.Dog" var="myDog"&gt; &lt;s:param name="name" value="'oudy'"&gt;&lt;/s:param&gt; &lt;/s:bean&gt; 拿出值： &lt;s:property value="#myDog.name"/&gt; &lt;/li&gt; 运行： 第一个通过param方式给bean中的name赋值为pp，在紧接着的下一行就可以取到这个bean的name，但是没有向ActionContext中存储。一旦s:bean执行结束，后面的代码就不能访问到这个name了。第二个通过在s:bean中用var定义一个myDog变量，然后在这个bean中用param定义name，取值为oudy，这一次由于使用了var，所以可以在bean结束后，通过#myDog.name取到name值。 总结一下bean：有两个属性：name和varname: 设置被实例化bean的完整类名var: 设置用于访问ActionContext中值的名称 第四十八课. Struts标签 5 include标签中的include已经不太使用了，了解就行，最多还是用的jsp中的两种包含方式：动态包含：&lt;jsp:include静态包含：&lt;@include 代码：123456789101112&lt;li&gt;include _include1.html 包含静态英文文件 &lt;s:include value="/_include1.html"&gt;&lt;/s:include&gt; &lt;/li&gt; &lt;li&gt;include _include2.html 包含静态中文文件 &lt;s:include value="/_include2.html"&gt;&lt;/s:include&gt; &lt;/li&gt; &lt;li&gt;include _include1.html 包含静态英文文件，说明%用法 &lt;s:set var="incPage" value="%&#123;'/_include1.html'&#125;" /&gt; &lt;s:include value="%&#123;#incPage&#125;"&gt;&lt;/s:include&gt; &lt;/li&gt; 运行来看一下效果： 发现中文文件没有显示出来。 第三句：12&lt;s:set var="incPage" value="%&#123;'/_include1.html'&#125;" /&gt;&lt;s:include value="%&#123;#incPage&#125;"&gt;&lt;/s:include&gt; 设置变量incPage，值是/_include1.html我们让#incPage不被当成字符串，而是做成ognl表达式，可以在外面套一个%{}所以%{}的作用就是将内部的字符串转换成ognl表达式 总结：$#%的区别 a) $用户 i18n 和 struts 配置文件 b) #取得 ActionContext 的值 c) %将原本的文本属性解析为ognl，对于本来就是ognl的属性不起作用 i. 参考&lt;s:property 和 &lt;s:include 第五十课. Struts标签 7 if代码：123456789&lt;li&gt;if elseif else: age = &lt;s:property value="#parameters.age[0]" /&gt; &lt;br /&gt; &lt;s:set var="age" value="#parameters.age[0]" /&gt; &lt;s:if test="#age &lt; 0"&gt;wrong age!&lt;/s:if&gt; &lt;s:elseif test="#parameters.age[0] &lt; 20"&gt;too young!&lt;/s:elseif&gt; &lt;s:else&gt;yeah!&lt;/s:else&gt;&lt;br /&gt; &lt;s:if test="#parameters.aaa == null"&gt;null&lt;/s:if&gt; &lt;/li&gt; 运行效果： debug一下： 显示不是特别直观，所以我们可以直接把age直接输出出来看结果。修改代码：12&lt;li&gt;if elseif else: age = &lt;s:property value="#parameters.age" /&gt; &lt;br /&gt; 运行结果： 发现两个传入的参数都显示出来。 看下面的判断代码：1234&lt;s:set var="age" value="#parameters.age[0]" /&gt;&lt;s:if test="#age &lt; 0"&gt;wrong age!&lt;/s:if&gt; &lt;s:elseif test="#parameters.age[0] &lt; 20"&gt;too young!&lt;/s:elseif&gt; &lt;s:else&gt;yeah!&lt;/s:else&gt;&lt;br /&gt; set一个var，名字叫age，使它的值是parameters.age[0]这样下面第一个if就可以用这个变量，而且这个变量存在于ActionContext里面，为了使用ActionContext里面的变量，要使用# 判断逻辑非常简单，我们传入第一个值是9，所以符合第二个判断语句，显示too young。 如果我们把第一个if不小心写成了#parameters.age，那么会直接输出yeah，因为它取的是在ActionContext里面整个数组所表示的字符串转换成的数字。 另外看代码：&lt;s:if test=&quot;#parameters.aaa == null&quot;&gt;null&lt;/s:if&gt; 由于parameters中没有aaa这个参数，所以符合判断条件，直接输出null 第五十一课. Struts标签 8 iterator效果： 第一句：12345&lt;li&gt;遍历集合：&lt;br /&gt; &lt;s:iterator value="&#123;1, 2, 3&#125;" &gt; &lt;s:property/&gt; | &lt;/s:iterator&gt; &lt;/li&gt; 集合中一共三个元素，我们使用&lt;/s:iterator&gt;，就可以依次遍历数组中的元素了。 第二句：12345&lt;li&gt;自定义变量：&lt;br /&gt; &lt;s:iterator value="&#123;'aaa', 'bbb', 'ccc'&#125;" var="x"&gt; &lt;s:property value="#x.toUpperCase()"/&gt; | &lt;/s:iterator&gt; &lt;/li&gt; 将集合中遍历到的元素存入x变量中，取这个变量的时候只需要前面加#就可以从ActionContext；中拿出来了。 第三句：12345678910111213&lt;li&gt;使用status:&lt;br /&gt;&lt;s:iterator value="&#123;'aaa', 'bbb', 'ccc'&#125;" status="status"&gt; &lt;s:property/&gt; | 遍历过的元素总数：&lt;s:property value="#status.count"/&gt; | 遍历过的元素索引：&lt;s:property value="#status.index"/&gt; | 当前是偶数？：&lt;s:property value="#status.even"/&gt; | 当前是奇数？：&lt;s:property value="#status.odd"/&gt; | 是第一个元素吗？：&lt;s:property value="#status.first"/&gt; | 是最后一个元素吗？：&lt;s:property value="#status.last"/&gt; &lt;br /&gt;&lt;/s:iterator&gt;&lt;/li&gt; status存着迭代器的一些状态，看代码理解，非常简单 第四句：12345&lt;li&gt;&lt;s:iterator value="#&#123;1:'a', 2:'b', 3:'c'&#125;" &gt; &lt;s:property value="key"/&gt; | &lt;s:property value="value"/&gt; &lt;br /&gt;&lt;/s:iterator&gt;&lt;/li&gt; 存取一个Map，大括号前面必须加一个#取key：&lt;s:property value=&quot;key&quot;/&gt;取value：&lt;s:property value=&quot;value&quot;/&gt; 第五句：12345&lt;li&gt; &lt;s:iterator value="#&#123;1:'a', 2:'b', 3:'c'&#125;" var="x"&gt; &lt;s:property value="#x.key"/&gt; | &lt;s:property value="#x.value"/&gt; &lt;br /&gt; &lt;/s:iterator&gt; &lt;/li&gt; 上面这个代码用x存取了一个entrySet，所以直接用#x.key就可以取key 遍历总结：iterator可以遍历的内容：collections map enumeration iterator array subset求的是子集合 第五十二课. Struts标签 9 uiUI标签特别多，但是用的不是特别多，因为比较繁杂，而且和js结合不是特别好 一共有四个theme： simple xthml(默认) css_html ajax 部署第一个project（Struts2_2100_Theme_1）: struts.xml:123456789101112131415&lt;struts&gt; &lt;!--&lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt;--&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;!--&lt;constant name="struts.ognl.allowStaticMethodAccess" value="true"&gt;&lt;/constant&gt;--&gt; &lt;constant name="struts.ui.theme" value="simple" /&gt; &lt;package name="theme" extends="struts-default"&gt; &lt;action name="theme" class="com.bjsxt.struts2.theme.ThemeAction"&gt; &lt;result&gt;/theme.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 运行效果： 查看网页源代码： 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="GB18030" ?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=GB18030" /&gt;&lt;title&gt;theme学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;在struts.xml中控制theme，默认为xhtml，可以设置为：simple/css_html/ajax &lt;ol&gt; &lt;li&gt; &lt;form id="theme" name="theme" action="/theme.action" method="post"&gt; &lt;div class="formFieldError"&gt; &lt;ul class="errorMessage"&gt; &lt;li&gt;&lt;span&gt;wrong!&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input type="text" name="aaa" value="" id="theme_aaa"/&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 如果把主题换成&lt;constant name=&quot;struts.ui.theme&quot; value=&quot;css_xhtml&quot; /&gt;再查看网页源代码：12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="GB18030" ?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=GB18030" /&gt;&lt;title&gt;theme学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt;在struts.xml中控制theme，默认为xhtml，可以设置为：simple/css_html/ajax &lt;ol&gt; &lt;li&gt; &lt;form id="theme" name="theme" action="/theme.action" method="post"&gt; &lt;div class="formFieldError"&gt; &lt;ul class="errorMessage"&gt; &lt;li&gt;&lt;span&gt;wrong!&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id="wwgrp_theme_aaa" class="wwgrp"&gt;&lt;div id="wwctrl_theme_aaa" class="wwctrl"&gt;&lt;input type="text" name="aaa" value="" id="theme_aaa"/&gt;&lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 发现在form外面包了一层div，只要换一个theme，里面的html写法之类的东西就会跟着变，其实很麻烦，我们自己改也不好改 看一下theme.jsp：12345678910111213&lt;body&gt;在struts.xml中控制theme，默认为xhtml，可以设置为：simple/css_html/ajax &lt;ol&gt; &lt;li&gt; &lt;s:form &gt; &lt;div class="formFieldError"&gt; &lt;s:fielderror /&gt; &lt;/div&gt; &lt;s:textfield name='aaa'&gt;&lt;/s:textfield&gt; &lt;/s:form&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/body&gt; 发现外面显示的页面有一个默认的错误信息，就是wrong，但是这个字符串在显示的时候，前面总有一个小圆圈，无法去掉，我们之前的文章里介绍过一个方法，就是到Value Stack里面取这个变量，对其加上我们想要的样式。 为了解决上面那个问题，我们看下一个小项目（Struts2_2100_Theme_2） 效果： 可以看到这个问题解决了。 在theme.jsp中加入css样式：1234567891011121314151617181920&lt;style type="text/css"&gt;.formFieldError &#123;font-family: verdana, arial, helvetica, sans-serif;font-size: 12px;color: #FF3300;vertical-align: bottom;&#125;.formFieldError ul &#123; /*list-style-type: none*/ margin: 0px; padding: 3px; vertical-align: middle;&#125;.formFieldError ul li&#123; list-style-type: none &#125;&lt;/style&gt; 我们看页面源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="GB18030" ?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=GB18030" /&gt;&lt;title&gt;theme学习&lt;/title&gt;&lt;style type="text/css"&gt;.formFieldError &#123;font-family: verdana, arial, helvetica, sans-serif;font-size: 12px;color: #FF3300;vertical-align: bottom;&#125;.formFieldError ul &#123; /*list-style-type: none*/ margin: 0px; padding: 3px; vertical-align: middle;&#125;.formFieldError ul li&#123; list-style-type: none &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;用CSS控制显示 &lt;ol&gt; &lt;li&gt; &lt;form id="theme" name="theme" action="/theme.action" method="post"&gt; &lt;div class="formFieldError"&gt; &lt;ul class="errorMessage"&gt; &lt;li&gt;&lt;span&gt;wrong!&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;input type="text" name="aaa" value="" id="theme_aaa"/&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/body&gt;&lt;/html&gt; 发现用了那个theme之后，struts自动帮我们生成了名字叫formFieldError的div和名字叫errorMessage的ul，我们对这两个class添加css就可以实现我们想要的样式，很麻烦。原因在于我们只要想要去控制struts的样式时，必须还得去自己了解它们生成的class，所以很麻烦。 我们看第三个工程（Struts2_2100_Theme_3），这个工程使用的方法也是struts所提倡的：先看效果： 发现前面的小圆点成功去掉，这个是怎么做到的？ 我们struts关于simple样式中filederror的配置在文件struts2-core-2.1.6.jar!\template\simple\fielderror.ftl中，所以struts提倡我们，如果想要修改样式，就去覆盖原来的文件。 所以我们在src下创建文件： 把原来的这个文件粘过来，并且在复制基础上进行修改：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;#if fieldErrors??&gt;&lt;#t/&gt;&lt;#assign eKeys = fieldErrors.keySet()&gt;&lt;#t/&gt;&lt;#assign eKeysSize = eKeys.size()&gt;&lt;#t/&gt;&lt;#assign doneStartUlTag=false&gt;&lt;#t/&gt;&lt;#assign doneEndUlTag=false&gt;&lt;#t/&gt;&lt;#assign haveMatchedErrorField=false&gt;&lt;#t/&gt;&lt;#if (fieldErrorFieldNames?size &gt; 0) &gt;&lt;#t/&gt; &lt;#list fieldErrorFieldNames as fieldErrorFieldName&gt;&lt;#t/&gt; &lt;#list eKeys as eKey&gt;&lt;#t/&gt; &lt;#if (eKey = fieldErrorFieldName)&gt;&lt;#t/&gt; &lt;#assign haveMatchedErrorField=true&gt;&lt;#t/&gt; &lt;#assign eValue = fieldErrors[fieldErrorFieldName]&gt;&lt;#t/&gt; &lt;#if (haveMatchedErrorField &amp;&amp; (!doneStartUlTag))&gt;&lt;#t/&gt; &lt;ul&lt;#rt/&gt;&lt;#if parameters.cssClass??&gt; class="$&#123;parameters.cssClass?html&#125;"&lt;#rt/&gt;&lt;#else&gt; class="errorMessage"&lt;#rt/&gt;&lt;/#if&gt;&lt;#if parameters.cssStyle??&gt; style="$&#123;parameters.cssStyle?html&#125;"&lt;#rt/&gt;&lt;/#if&gt;&gt; &lt;#assign doneStartUlTag=true&gt;&lt;#t/&gt; &lt;/#if&gt;&lt;#t/&gt; &lt;#list eValue as eEachValue&gt;&lt;#t/&gt; &lt;li&gt;&lt;span&gt;$&#123;eEachValue&#125;&lt;/span&gt;&lt;/li&gt; &lt;/#list&gt;&lt;#t/&gt; &lt;/#if&gt;&lt;#t/&gt; &lt;/#list&gt;&lt;#t/&gt; &lt;/#list&gt;&lt;#t/&gt; &lt;#if (haveMatchedErrorField &amp;&amp; (!doneEndUlTag))&gt;&lt;#t/&gt; &lt;/ul&gt; &lt;#assign doneEndUlTag=true&gt;&lt;#t/&gt; &lt;/#if&gt;&lt;#t/&gt;&lt;#else&gt;&lt;#t/&gt; &lt;#if (eKeysSize &gt; 0)&gt;&lt;#t/&gt; &lt;#list eKeys as eKey&gt;&lt;#t/&gt; &lt;#assign eValue = fieldErrors[eKey]&gt;&lt;#t/&gt; &lt;#list eValue as eEachValue&gt;&lt;#t/&gt; &lt;span&gt;$&#123;eEachValue&#125;&lt;/span&gt; &lt;/#list&gt;&lt;#t/&gt; &lt;/#list&gt;&lt;#t/&gt; &lt;/#if&gt;&lt;#t/&gt;&lt;/#if&gt;&lt;#t/&gt;&lt;/#if&gt;&lt;#t/&gt; 这样我们就实现了我们的目的。但是这里有一个前提，如果我们想要去修改一个样式，必须要懂freemarker语言。 最后看第四个工程（Struts2_2100_Theme_3）：效果： 不再覆盖一个配置文件，而是创建一个自己的主题： 我们这里就是直接把simple主题完全复制过来，修改然后改名字，在struts.xml中配置成我们自己的主题：&lt;constant name=&quot;struts.ui.theme&quot; value=&quot;mytheme&quot; /&gt;这样就ok了。 第四种用法也是struts推荐的方式，但是也需要熟悉freemarker语言。所以特别繁琐。 只有fielderror最麻烦，simple会使用其默认样式，就是前面有圆点。所以我们如果不涉及fielderror，就用simple主题就可以了，基本上都是不带样式的。 总结一下theme： css（覆盖struts2原来的css） 覆盖单个文件 定义自己的theme 实战a) 把所有主题定义为simpleb) fielderror特殊处理c) 自己控制其他标签的展现]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 421.Maximum XOR of Two Numbers in an Array]]></title>
    <url>%2F2017%2F12%2F07%2Fleetcode421%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/思路：利用XOR的性质，a^b = c, 则有 a^c = b，且 b^c = a;所以每次从高位开始，到某一位为止，所能获得的最大的数。设置变量mask用来表示能形成的值，每一次将mask和其他的num相与得到的值加入set，表示在当前这一位上，数组里有这么多prefix。 假定在某一位上的任意两数xor能得到的最大值是tmp,那么他一定满足a(xor)b = tmp,其中set.contains(a) &amp;&amp; set.contains(b). 所以，我们只需要判断b(xor)tmp的结果是不是在当前这一位下的set内，就可以知道这个tmp能不能又这个set中的任意两个数组成。 代码12345678910111213141516171819202122232425class Solution &#123; public int findMaximumXOR(int[] nums) &#123; int length = nums.length; int max = 0; int mask = 0; for(int i = 31; i &gt;= 0; i--)&#123; mask = mask|(1&lt;&lt;i); HashSet&lt;Integer&gt; hs = new HashSet(); for(int j = 0; j &lt; length; j++) hs.add(nums[j] &amp; mask); int tmp = max | (1&lt;&lt;i); Iterator it = hs.iterator(); while(it.hasNext())&#123; int x = (int)it.next(); if(hs.contains(x^tmp))&#123; max = tmp; break; &#125; &#125; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2笔记（三） OGNL]]></title>
    <url>%2F2017%2F12%2F04%2FStruts2-3%2F</url>
    <content type="text"><![CDATA[本文主要介绍Struts2中ognl表达式的基本用法。 第三十六课. OGNL_1先看一下效果： index.jsp:1234&lt;body&gt; 访问属性 &lt;a href="&lt;%=contextPath %&gt;/ognl.action?username=u&amp;password=p"&gt;ognl&lt;/a&gt;&lt;/body&gt; 我们首先去struts.xml中进行匹配：12345678&lt;struts&gt; &lt;constant name="struts.enable.DynamicMethodInvocation" value="false" /&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;constant name="struts.ognl.allowStaticMethodAccess" value="true"&gt;&lt;/constant&gt; &lt;include file="/com/bjsxt/struts2/ognl/ognl.xml"/&gt; &lt;/struts&gt; 发现这次并没有去package中进行搜索匹配，而是直接include了一个ognl.xml文件。查看这个文件：12345678910111213&lt;struts&gt; &lt;package name="ognl" extends="struts-default"&gt; &lt;action name="ognl" class="com.bjsxt.struts2.ognl.OgnlAction"&gt; &lt;result&gt;/ognl.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="test" class="com.bjsxt.struts2.ognl.TestAction"&gt; &lt;result type="chain"&gt;ognl&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 发现这个文件有一个package，正好匹配我们url里的package名，然后下面有一个名字叫OgnlAction的Action，我们看这个Action类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class OgnlAction extends ActionSupport &#123;// private Cat cat;// private Map&lt;String, Dog&gt; dogMap = new HashMap&lt;String, Dog&gt;();//// private Set&lt;Dog&gt; dogs = new HashSet&lt;Dog&gt;(); private String password;// private User user; private String username; private List&lt;User&gt; users = new ArrayList&lt;User&gt;(); public OgnlAction() &#123;// users.add(new User(1));// users.add(new User(2));// users.add(new User(3));//// dogs.add(new Dog("dog1"));// dogs.add(new Dog("dog2"));// dogs.add(new Dog("dog3"));//// dogMap.put("dog100", new Dog("dog100"));// dogMap.put("dog101", new Dog("dog101"));// dogMap.put("dog102", new Dog("dog102")); &#125; public String execute() &#123; return SUCCESS; &#125;//// public Cat getCat() &#123;// return cat;// &#125;//// public Map&lt;String, Dog&gt; getDogMap() &#123;// return dogMap;// &#125;//// public Set&lt;Dog&gt; getDogs() &#123;// return dogs;// &#125;// public String getPassword() &#123; return password; &#125;//// public User getUser() &#123;// return user;// &#125; public String getUsername() &#123; return username; &#125;// public List&lt;User&gt; getUsers() &#123;// return users;// &#125; public String m() &#123; return "hello"; &#125;// public void setCat(Cat cat) &#123;// this.cat = cat;// &#125; // public void setDogMap(Map&lt;String, Dog&gt; dogMap) &#123;// this.dogMap = dogMap;// &#125;// public void setDogs(Set&lt;Dog&gt; dogs) &#123;// this.dogs = dogs;// &#125; public void setPassword(String password) &#123; this.password = password; &#125;// public void setUser(User user) &#123;// this.user = user;// &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setUsers(List&lt;User&gt; users) &#123; this.users = users; &#125;&#125; 发现里面有两个属性：password与username，然后里面有getter和setter，通过execute方法返回SUCCESS，然后执行result，返回ognl.jsp：1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;ol&gt; &lt;li&gt;访问值栈中的action的普通属性: username = &lt;s:property value="username"&gt;&lt;/s:property&gt; &lt;/li&gt; &lt;li&gt;访问值栈中对象的普通属性(get set方法)：&lt;s:property value="user.age"&gt;&lt;/s:property&gt; | &lt;s:property value="user['age']"&gt;&lt;/s:property&gt; | &lt;s:property value="user[\"age\"]"&gt;&lt;/s:property&gt; | wrong: &lt;%--&lt;s:property value="user[age]"&gt;&lt;/s:property&gt;--%&gt;&lt;/li&gt; &lt;%--&lt;li&gt;访问值栈中对象的普通属性(get set方法): &lt;s:property value="cat.friend.name"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问值栈中对象的普通方法：&lt;s:property value="password.length()"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问值栈中对象的普通方法：&lt;s:property value="cat.miaomiao()" &gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问值栈中action的普通方法：&lt;s:property value="m()" &gt;&lt;/s:property&gt;&lt;/li&gt; &lt;hr /&gt; &lt;li&gt;访问静态方法：&lt;s:property value="@com.bjsxt.struts2.ognl.S@s()"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问静态属性：&lt;s:property value="@com.bjsxt.struts2.ognl.S@STR"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问Math类的静态方法：&lt;s:property value="@@max(2,3)" &gt;&lt;/s:property&gt;&lt;/li&gt; &lt;hr /&gt; &lt;li&gt;访问普通类的构造方法：&lt;s:property value="new com.bjsxt.struts2.ognl.User(8)"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;hr /&gt; &lt;li&gt;访问List:&lt;s:property value="users"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问List中某个元素:&lt;s:property value="users[1]"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问List中元素某个属性的集合:&lt;s:property value="users.&#123;age&#125;"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问List中元素某个属性的集合中的特定值:&lt;s:property value="users.&#123;age&#125;[0]"&gt;&lt;/s:property&gt; | &lt;s:property value="users[0].age"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问Set:&lt;s:property value="dogs"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问Set中某个元素:&lt;s:property value="dogs[1]"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问Map:&lt;s:property value="dogMap"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问Map中某个元素:&lt;s:property value="dogMap.dog101"&gt;&lt;/s:property&gt; | &lt;s:property value="dogMap['dog101']"&gt;&lt;/s:property&gt; | &lt;s:property value="dogMap[\"dog101\"]"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问Map中所有的key:&lt;s:property value="dogMap.keys"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问Map中所有的value:&lt;s:property value="dogMap.values"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;访问容器的大小：&lt;s:property value="dogMap.size()"&gt;&lt;/s:property&gt; | &lt;s:property value="users.size"&gt;&lt;/s:property&gt; &lt;/li&gt; &lt;hr /&gt; &lt;li&gt;投影(过滤)：&lt;s:property value="users.&#123;?#this.age==1&#125;[0]"&gt;&lt;/s:property&gt;&lt;/li&gt; &lt;li&gt;投影：&lt;s:property value="users.&#123;^#this.age&gt;1&#125;.&#123;age&#125;"/&gt;&lt;/li&gt; &lt;li&gt;投影：&lt;s:property value="users.&#123;$#this.age&gt;1&#125;.&#123;age&#125;"/&gt;&lt;/li&gt; &lt;li&gt;投影：&lt;s:property value="users.&#123;$#this.age&gt;1&#125;.&#123;age&#125; == null"/&gt;&lt;/li&gt; &lt;hr /&gt; &lt;li&gt;[]:&lt;s:property value="[0].username"&gt;&lt;/s:property&gt;&lt;/li&gt;--%&gt; &lt;/ol&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt; 查看debug里面的值栈： 发现可以拿到username和password。其实就是通过username = &lt;s:property value=&quot;username&quot;/&gt;，里面的s:property是标签，value=”username”中的”username”就是ognl表达式。 再做第二个试验：在OgnlAction.java中定义一个private User user; 打开关于user的getter和setter：1234567public User getUser() &#123; return user;&#125;public void setUser(User user) &#123; this.user = user;&#125; User.java：12345678910111213141516171819202122232425262728package com.bjsxt.struts2.ognl;public class User &#123; private int age = 8; public User() &#123; &#125; public User(int age) &#123; super(); this.age = age; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "user" + age; &#125;&#125; 执行效果： 发现user的值是null，我们在url后面传入user.age再来试验一把： 发现这一次user有了值，并且通过ognl表达式可以打印出user.age。 所以得出一个结论：user.xxx只有传，才会构造。 做第二个实验：如果我们自己手动构造user，也是可以的：比如我们在OgnlAction.java中修改：private User user = new User();再次访问没有user.age的url： 发现也是可以有user的。 做第三个实验：在OgnlAction.java中将1private User user = new User(); 改成1private User user; 然后在User.java中去掉123public User() &#123; &#125; 运行http://localhost:8888/ognl.action?username=u&amp;password=p发现值栈中没有user: 所以得出结论，想要初始化domain model，可以自己new，也可以传参数值，但是这时候需要保持参数为空的构造方法 第三十七课. OGNL_2在ognl.jsp中取消对一句话的注释：&lt;li&gt;访问值栈中对象的普通属性(get set方法): &lt;s:property value=&quot;cat.friend.name&quot;/&gt;&lt;/li&gt; 在OgnlAction.java中添加对cat的getter和setter：123456789private Cat cat;public Cat getCat() &#123; return cat;&#125;public void setCat(Cat cat) &#123; this.cat = cat;&#125; Cat.java：123456789101112131415161718package com.bjsxt.struts2.ognl;public class Cat &#123; private Dog friend; public Dog getFriend() &#123; return friend; &#125; public void setFriend(Dog friend) &#123; this.friend = friend; &#125; public String miaomiao() &#123; return "miaomiao"; &#125;&#125; Cat类中有一个Dog的好朋友。Dog.java：12345678910111213141516171819202122232425262728package com.bjsxt.struts2.ognl;public class Dog &#123; private String name; public Dog() &#123; &#125; public Dog(String name) &#123; super(); this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "dog: " + name; &#125;&#125; 类之间的关系： OgnlAction有一个Cat，Cat有一个Dog，它们之间都是聚合关系。 OGNL：Object Graph Navigation Language 运行一下： 发现cat内部是一个null值，说明没有创建一个domain model，只需要传值就可以创建了： 第三十九课. OGNL_4打开ognl.jsp中被注释的一句话：&lt;li&gt;访问值栈中对象的普通方法：&lt;s:property value=&quot;password.length()&quot;/&gt;&lt;/li&gt; 运行： password是值栈中的一个对象，发现可以直接在ognl表达式中运行值栈中对象的普通方法。 再做一个类似的实验，打开我们的cat的miaomiao方法：&lt;li&gt;访问值栈中对象的普通方法：&lt;s:property value=&quot;cat.miaomiao()&quot; /&gt;&lt;/li&gt; 运行： 再做下一个实验，在ognl.jsp中打开：&lt;li&gt;访问值栈中action的普通方法：&lt;s:property value=&quot;m()&quot; /&gt;&lt;/li&gt;调用值栈中action的普通方法，运行： 做下一个实验，访问静态方法、静态属性（ognl.jsp）：123&lt;li&gt;&lt;访问静态方法：&lt;s:property value="@com.bjsxt.struts2.ognl.S@s()"/&gt;&lt;/li&gt;&lt;li&gt;访问静态属性：&lt;s:property value="@com.bjsxt.struts2.ognl.S@STR"/&gt;&lt;/li&gt;&lt;li&gt;访问Math类的静态方法：&lt;s:property value="@@max(2,3)" /&gt;&lt;/li&gt; 第一个@后面跟的是类名，第二个@后面跟的是静态方法名，S.java的代码：123456789package com.bjsxt.struts2.ognl;public class S &#123; public static String STR = "STATIC STRING"; public static String s() &#123; return "static method"; &#125;&#125; S中包括静态方法和静态函数。 运行看一下： 发现静态属性是被访问到了，但是静态方法却没有被访问到。这里是有一个小配置的，要在struts.xml中添加语句：&lt;constant name=&quot;struts.ognl.allowStaticMethodAccess&quot; value=&quot;true&quot;&gt;&lt;/constant&gt;这样就运行静态方法的访问了： 两个@，也就是@@，只能访问一个类的属性方法，那就是Math类 第四十课. OGNL_5打开ognl.jsp中的一行注释：1&lt;li&gt;访问普通类的构造方法：&lt;s:property value="new com.bjsxt.struts2.ognl.User(8)"/&gt;&lt;/li&gt; 调用了User的构造方法，并传入一个参数8，运行： 成功访问了普通类的构造方法。 我们下面做关于访问集合属性的实验：1234567891011&lt;li&gt;访问List:&lt;s:property value="users"/&gt;&lt;/li&gt;&lt;li&gt;访问List中某个元素:&lt;s:property value="users[1]"/&gt;&lt;/li&gt;&lt;li&gt;访问List中元素某个属性的集合:&lt;s:property value="users.&#123;age&#125;"/&gt;&lt;/li&gt;&lt;li&gt;访问List中元素某个属性的集合中的特定值:&lt;s:property value="users.&#123;age&#125;[0]"/&gt; | &lt;s:property value="users[0].age"/&gt;&lt;/li&gt;&lt;li&gt;访问Set:&lt;s:property value="dogs"/&gt;&lt;/li&gt;&lt;li&gt;访问Set中某个元素:&lt;s:property value="dogs[1]"/&gt;&lt;/li&gt;&lt;li&gt;访问Map:&lt;s:property value="dogMap"/&gt;&lt;/li&gt;&lt;li&gt;访问Map中某个元素:&lt;s:property value="dogMap.dog101"/&gt; | &lt;s:property value="dogMap['dog101']"/&gt; | &lt;s:property value="dogMap[\"dog101\"]"/&gt;&lt;/li&gt;&lt;li&gt;访问Map中所有的key:&lt;s:property value="dogMap.keys"/&gt;&lt;/li&gt;&lt;li&gt;访问Map中所有的value:&lt;s:property value="dogMap.values"/&gt;&lt;/li&gt;&lt;li&gt;访问容器的大小：&lt;s:property value="dogMap.size()"/&gt; | &lt;s:property value="users.size"/&gt; &lt;/li&gt; 在OgnlAction.java中，添加下面语句：12345678910111213141516171819202122232425262728293031323334353637383940414243private List&lt;User&gt; users = new ArrayList&lt;User&gt;();private Set&lt;Dog&gt; dogs = new HashSet&lt;Dog&gt;();private Map&lt;String, Dog&gt; dogMap = new HashMap&lt;String, Dog&gt;();public OgnlAction() &#123; users.add(new User(1)); users.add(new User(2)); users.add(new User(3)); dogs.add(new Dog("dog1")); dogs.add(new Dog("dog2")); dogs.add(new Dog("dog3")); dogMap.put("dog100", new Dog("dog100")); dogMap.put("dog101", new Dog("dog101")); dogMap.put("dog102", new Dog("dog102"));&#125;public void setDogMap(Map&lt;String, Dog&gt; dogMap) &#123; this.dogMap = dogMap;&#125;public void setDogs(Set&lt;Dog&gt; dogs) &#123; this.dogs = dogs;&#125;public Map&lt;String, Dog&gt; getDogMap() &#123; return dogMap;&#125;public Set&lt;Dog&gt; getDogs() &#123; return dogs;&#125;public List&lt;User&gt; getUsers() &#123; return users;&#125;public void setUser(User user) &#123; this.user = user;&#125; 运行效果： 上面注意第16，由于Set无序，所以不能通过&lt;s:property value=&quot;dogs[1]&quot;/&gt;来取Set的一个值 其他的ognl表达式，自己看上面代码，记住就可以了。 第四十一课. OGNL_6.在ognl.jsp中添加如下代码：1234&lt;li&gt;投影(过滤)：&lt;s:property value="users.&#123;?#this.age==1&#125;[0]"/&gt;&lt;/li&gt;&lt;li&gt;投影：&lt;s:property value="users.&#123;^#this.age&gt;1&#125;.&#123;age&#125;"/&gt;&lt;/li&gt;&lt;li&gt;投影：&lt;s:property value="users.&#123;$#this.age&gt;1&#125;.&#123;age&#125;"/&gt;&lt;/li&gt;&lt;li&gt;投影：&lt;s:property value="users.&#123;$#this.age&gt;1&#125;.&#123;age&#125; == null"/&gt;&lt;/li&gt; 运行看结果： 投影这有三种：?#^#$# 第一句：&lt;li&gt;投影(过滤)：&lt;s:property value=&quot;users.{?#this.age==1}[0]&quot;/&gt;&lt;/li&gt; users是一个List，在这个List里面取所有age=1的对象，得到一个对象集合，在这个集合中只去取第一个元素。 第二句：&lt;li&gt;投影：&lt;s:property value=&quot;users.{^#this.age&gt;1}.{age}&quot;/&gt;&lt;/li&gt;users中age&gt;1的集合中，开头的一个元素，返回它的age。 第三句：&lt;li&gt;投影：&lt;s:property value=&quot;users.{$#this.age&gt;1}.{age}&quot;/&gt;&lt;/li&gt;users中age&gt;1的集合中，结尾的一个元素，返回它的age。 第四句：&lt;li&gt;投影：&lt;s:property value=&quot;users.{$#this.age&gt;1}.{age} == null&quot;/&gt;&lt;/li&gt;users中age&gt;1的集合中，结尾的一个元素，看看它的age是不是为空。我们这里不为空，所以返回false。 第四十二课. OGNL_7在ognl.jsp中添加：&lt;li&gt;[]:&lt;s:property value=&quot;[0] &quot;/&gt;&lt;/li&gt; 运行： 发现中括号里面加一个数值，访问的就是值栈中的一个Object。我们由于是[0]，所以访问的是值栈中从上往下数的第一个对象到栈底的所有Object，就是OgnlAction和DefaultTextProvider 如果我们修改上面的句子：&lt;li&gt;[]:&lt;s:property value=&quot;[0].username&quot;/&gt;&lt;/li&gt; 运行： 发现访问到了Action的username，如果有很多Action，那么就按顺序往下找，直到找到某一个Action中有username属性。那什么时候会有两个Action？ 第四十三课. OGNL_8什么时候有两个Action呢？我们在我们的ognl.xml中配置两个Action： 12345678910&lt;package name="ognl" extends="struts-default"&gt; &lt;action name="ognl" class="com.bjsxt.struts2.ognl.OgnlAction"&gt; &lt;result&gt;/ognl.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="test" class="com.bjsxt.struts2.ognl.TestAction"&gt; &lt;result type="chain"&gt;ognl&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; TestAction.java： 123456789101112package com.bjsxt.struts2.ognl;import com.opensymphony.xwork2.ActionSupport;public class TestAction extends ActionSupport &#123; @Override public String execute() throws Exception &#123; return super.execute(); &#125;&#125; 执行test.action： 发现值栈中压入两个Action，一个TestAction，一个OgnlAction。]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 646.Maximum Length of Pair Chain]]></title>
    <url>%2F2017%2F12%2F04%2Fleetcode646%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/maximum-length-of-pair-chain/description/ 解法一：使用贪心法来解决这个问题，只能按照数组第二个元素进行排序。比方(8,9)(10,11)(1,100)按照数组第一个元素排序:(1,100),(8,9),(10,11)。不能通过比较[i][end] 和 [i+1][begin] 来增加链。而如果按照数组第二个元素排序： (8,9) ，(10,11)， (1,100)，那么则可以通过比较 [i][end] 和 [i+1][begin] 来增加 关于排序：Arrays.sort(pairs, (a,b) -&gt; a[1] - b[1]);Java Lambda 表达式（又名闭包(Closure)匿名函数) 笔记 代码：123456789101112131415161718class Solution &#123; public int findLongestChain(int[][] pairs) &#123; Arrays.sort(pairs, (a,b)-&gt;(a[1]-b[1])); int sum = 0; int length = pairs.length; int i = 0; while(i &lt; length)&#123; int current_end = pairs[i][1]; sum++; while(i &lt; length &amp;&amp; pairs[i][0] &lt;= current_end) i++; &#125; return sum; &#125;&#125; 解法二：无论是按照数组的第一个元素排序，还是按照数组的第二个元素排序，这个问题都能转化为用DP解决。以下是用DP解决的。dp[i]储存的是从i结束的链表长度最大值。首先初始化每个dp[i]为1。然后对于每个dp[i]，找在 i 前面的索引 0~j，如果存在可以链接在i 前面的数组，且加完后大于dp[i]之前的值，那么则在dp[j]的基础上+1. 代码：12345678910111213141516171819public class Solution &#123; public int findLongestChain(int[][] pairs) &#123; Arrays.sort(pairs, (a, b) -&gt; (a[0] - b[0])); int i, j, max = 0, n = pairs.length; int dp[] = new int[n]; for (i = 0; i &lt; n; i++) dp[i] = 1; for (i = 1; i &lt; n; i++) for (j = 0; j &lt; i; j++) if (pairs[i][0] &gt; pairs[j][1] &amp;&amp; dp[i] &lt; dp[j] + 1) dp[i] = dp[j] + 1; for (i = 0; i &lt; n; i++) if (max &lt; dp[i]) max = dp[i]; return max; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 13.Roman to Integer]]></title>
    <url>%2F2017%2F12%2F04%2Fleetcode13%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/roman-to-integer/description/ Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. 解法一： 依次遍历每一个字符，如果下一个字符代表的数字比当前数字大，那么就将结果减去当前数字；如果小就加上。1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int romanToInt(String s) &#123; int[] nums = new int[s.length()]; for(int i = 0; i &lt; s.length(); i++)&#123; switch(s.charAt(i))&#123; case 'M': nums[i]=1000; break; case 'D': nums[i]=500; break; case 'C': nums[i]=100; break; case 'L': nums[i]=50; break; case 'X' : nums[i]=10; break; case 'V': nums[i]=5; break; case 'I': nums[i]=1; break; &#125; &#125; int res = 0; for(int i = 0; i &lt; nums.length-1; i++) if(nums[i] &lt; nums[i+1]) res -= nums[i]; else res += nums[i]; res += nums[nums.length-1]; return res; &#125;&#125; 解法二： 比上一个解法更加高效，由于是在4000范围之内将罗马数字转换成十进制，所以将各种组合情况（只有两个罗马数字的组合）枚举出来，并且按照从大到小放置在数组中。我们做的，只需要利用String类的indexOf函数来查看是否有遍历到的数组字符串作为前缀的，如果有，就把这个前缀的十进制加到结果里，然后字符串将前缀删掉，继续之前的操作，一直到字符串删完为止。 123456789101112131415class Solution &#123; public int romanToInt(String s) &#123; int ans = 0; int[] aArray = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String[] rArray = &#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; for(int i = 0; i &lt; rArray.length; i++)&#123; while(s.indexOf(rArray[i] )== 0)&#123; ans += aArray[i]; s = s.substring(rArray[i].length()); &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2笔记（二） Result]]></title>
    <url>%2F2017%2F12%2F02%2FStruts2-2%2F</url>
    <content type="text"><![CDATA[本文主要介绍Struts2中Result的基本用法。 第二十七课. 结果类型 result_type1先看效果： 看代码（struts.xml）:123456789101112131415161718192021&lt;struts&gt; &lt;constant name="struts.devMode" value="true" &gt;&lt;/constant&gt; &lt;package name="resultTypes" namespace="/r" extends="struts-default"&gt; &lt;action name="r1"&gt; &lt;result type="dispatcher"&gt;/r1.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="r2"&gt; &lt;result type="redirect"&gt;/r2.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="r3"&gt; &lt;result type="chain"&gt;r1&lt;/result&gt; &lt;/action&gt; &lt;action name="r4"&gt; &lt;result type="redirectAction"&gt;r2&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 之前我们没有指定result的type，默认就是dispatcher，就是运用服务器跳转到一个结果页面，原理就是用jsp的forward，forward到一个html或jsp或其他文件。 chain的意思是forward到一个action，而dispatcher只能是jsp或htmlredirect也只能跳转到一个视图，不能跳转到一个action 如果想客户端跳转到一个action，就用redirectAction用的比较多的就是前四种，其中dispatcher和redirect用的最多 httpheader就是发送一个http的头信息stream就是下载velocity和freemarker是特别相似的模板框架，不过干不过freemarker，已经几乎被淘汰xslt是修饰的xml语言paintext是可以将页面源码显示出来（一般我们都显示出来的是经过解析后的html文件）tiles可以将页面分成几块，每块内容动态指定。 除了前四种，其他知道就行了。 先看第一种，dispatcher： 发现url访问的是服务端的action，也就是说，dispatcher完成的是服务端跳转，过程如下： 而redirect完成的是客户端跳转，所以访问后显示的url是重定向后的jsp： 客户端跳转如下图所示： 对于chain，访问同一个包的action时，不要在前面加/如果访问其他包的Action，例如p2的action，那么可以写成p2/r1 运行效果： 看到r3访问同包中r1的action，r1的action帮我们在服务端dispatcher到了r1.jsp，所以最后链接显示的是r3的action，但是实际显示的是r1的jsp 再实验第四个，也就是redirectAction： 发现显示的是r2.jsp,而且链接也跳到了r2.jsp，这是因为我们利用redirectAction，想访问r2的Action，而r2的action进行了客户端跳转，所以最后给我们客户端返回的是r2.jsp。 第二十九课. result type 常见问题.当我们使用chain的result type时，如何能跳转到其他package下的action ? 通过加参数就可以解决~123456&lt;action name="login" class="..."&gt; &lt;result type="chain"&gt; &lt;param name="actionName"&gt;dashboard&lt;/param&gt; &lt;param name="namespace"&gt;/secure&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; 第三十课. Global Results 全局结果集先把project部署好，运行看效果： index.jsp代码：12345678910&lt;body&gt;Result类型&lt;ol&gt; &lt;li&gt;&lt;a href="user/user?type=1"&gt;返回success&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="user/user?type=2"&gt;返回error&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="user/user?type=3"&gt;返回global result&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="admin/admin"&gt;admin,继承user包&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt; &lt;/body&gt; 来看我们的UserAction.java:1234567891011121314151617181920212223242526272829package com.bjsxt.struts2.user.action;import com.opensymphony.xwork2.ActionSupport;public class UserAction extends ActionSupport &#123; private int type; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; @Override public String execute() throws Exception &#123; if(type == 1) return "success"; else if (type == 2) return "error"; else return "mainpage"; &#125;&#125; 依次点击三个链接，效果如下： 发现当传入type=1时，返回seccess，传入type=2时，返回error，传入type=3时，返回mainpage，它们都是result名字，我们再看struts.xml对这些result的配置：12345678910111213141516171819202122232425&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="user" namespace="/user" extends="struts-default"&gt; &lt;global-results&gt; &lt;result name="mainpage"&gt;/main.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;action name="index"&gt; &lt;result&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="user" class="com.bjsxt.struts2.user.action.UserAction"&gt; &lt;result&gt;/user_success.jsp&lt;/result&gt; &lt;result name="error"&gt;/user_error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;package name="admin" namespace="/admin" extends="user"&gt; &lt;action name="admin" class="com.bjsxt.struts2.user.action.AdminAction"&gt; &lt;result&gt;/admin.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 发现这次有好几组action，每一个action里面配置了一组result，我们发现，result中有名字叫success和error的，但是唯独没有叫mainpage，再往上看才发现，mainpage配置在了一个global-results中，global-results实际相当于所有在同一个package中的action的共同result配置，每一个在这个package中的action都可以进行访问，也就是一个全局结果集。 我们考虑第二种情况，如果现在下面的名字叫admin的package中的action想要访问mainpage，但是由于不在user包中，应该怎么办？其实我们上面的代码已经给出了答案，就是admin的package中，加了一个extends的配置，设置为extends=”user”，也就是从user包中继承配置，这样就有了mainpage这样的result结果集。 在AdminAction.java中返回mainpage： 123456789101112package com.bjsxt.struts2.user.action;import com.opensymphony.xwork2.ActionSupport;public class AdminAction extends ActionSupport &#123; @Override public String execute() throws Exception &#123; return "mainpage"; &#125;&#125; 结果就会映射到我们的main.jsp： 这是一种设计思想，就是可以在struts.xml中定义一个公用的package，然后每一个package都可以对这个公用包进行extends。 如果没有想继承的，就可以设置extends=&quot;struts-default&quot;，这个就是默认配置。 struts-default的详细代码在struts2-core-2.1.6.jar!\struts-default.xml中可以查看，可以说，struts很复杂，但是它的复杂使我们使用起来更加简单。 第三十一课. 动态结果集 dynamic result.运行起来看结果： 发现传入一个type=1就可以返回一个success的jsp页面。怎么做到的呢？我们先来看struts.xml：12345678910&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="user" namespace="/user" extends="struts-default"&gt; &lt;action name="user" class="com.bjsxt.struts2.user.action.UserAction"&gt; &lt;result&gt;$&#123;r&#125;&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 当接收到链接中的user包时，开始匹配，匹配到了我们的user包，然后执行UserAction这个Action：123456789101112131415161718192021222324252627282930313233package com.bjsxt.struts2.user.action;import com.opensymphony.xwork2.ActionSupport;public class UserAction extends ActionSupport &#123; private int type; private String r; public String getR() &#123; return r; &#125; public void setR(String r) &#123; this.r = r; &#125; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; @Override public String execute() throws Exception &#123; if(type == 1) r="/user_success.jsp"; else if (type == 2) r="/user_error.jsp"; return "success"; &#125;&#125; 发现type=1被直接传入了UserAction里面，然后执行execute()方法，因为type=1，所以r=”/user_success.jsp”，这时r被存入值栈。我们查看值栈： 发现r=”/user_success.jsp”已经被放入值栈，这时候我们执行result，${r}用于从值栈中取出r的值，也就是/user_success.jsp，这样我们的页面就显示为/user_success.jsp。这就是动态结果集。 第三十二课. 带参数的结果集先部署、运行，看效果： 发现从值栈中取不出数值，但是从actioncontext却可以。来看代码： 先看index.jsp：1234567&lt;body&gt;向结果传参数&lt;ol&gt; &lt;li&gt;&lt;a href="user/user?type=1"&gt;传参数&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt; &lt;/body&gt; 发现执行名字叫user的Action，传入参数type=1，再看struts.xml：12345678910&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="user" namespace="/user" extends="struts-default"&gt; &lt;action name="user" class="com.bjsxt.struts2.user.action.UserAction"&gt; &lt;result type="redirect"&gt;/user_success.jsp?t=$&#123;type&#125;&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;/struts&gt; 找到user的package和user的Action，执行UserAction对象。查看UserAction.java的代码：123456789101112131415161718192021package com.bjsxt.struts2.user.action;import com.opensymphony.xwork2.ActionSupport;public class UserAction extends ActionSupport &#123; private int type; public int getType() &#123; return type; &#125; public void setType(int type) &#123; this.type = type; &#125; @Override public String execute() throws Exception &#123; return "success"; &#125;&#125; 发现UserAction里面有一个type属性，URL里面的type=1就被传入而&lt;result type=&quot;redirect&quot;&gt;/user_success.jsp?t=${type}&lt;/result&gt;一句重定向，将type从值栈中取出，作为参数t发给服务端，因而这是一个新的request，所以要开辟一个新的值栈。 然后看我们的user_success.jsp文件：123456&lt;body&gt; User Success! from valuestack: &lt;s:property value="t"/&gt;&lt;br/&gt; from actioncontext: &lt;s:property value="#parameters.t"/&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt; 发现第一个是直接从值栈中去取t的值，由于已经重定向，所以最初的t的值并没有存入值栈，这时候我们就可以通过第二种方式来拿这个值，就是通过发请求时附加参数的方式，最后通过#parameters.t的方式就可以取到了。 完整的过程如下图所示： 第三十三课. 结果集总结Result 常用四种类型a) dispatcher（默认）b) redirectc) chaind) redirectAction 全局结果集a) global-results | extends 动态结果（了解）a) 在action中保存一个属性，存储具体的过程location 传递参数a) 客户端跳转才需要传递b) ${}表达式（不是EL）]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2笔记（一） Action]]></title>
    <url>%2F2017%2F12%2F02%2FStruts2-1%2F</url>
    <content type="text"><![CDATA[本文主要介绍Struts2中Action的基本用法。 第一课. Struts2简介及学习方法简介.目录：Action 简单数据校验 Result常用配置文件OGNL&amp;ValueStackTags——————Project类型转换、上传和下载、interceptor、防止重复提交MVC思想深入剖析源码解读其他话题 校验框架、I18N、Ajax、FreeMarker、异常处理 Webwork和Struts1合并，形成Struts2 第二课. Struts2_HelloWorld_1.创建一个java web工程，起名叫做Struts2_0100_Introduction 从https://struts.apache.org/download.cgi下载我们需要的struts2，解压，可以看到解压后的目录结构如下： 我们从apps下找到blankXXX.war这个压缩包（貌似struts2.5已经没有了，所以只拿教程中的struts2.1.6来练习）我们先把struts2-blank-2.1.6.war进行解压： 1、将WEB-INF/classes下的struts.xml粘到我们创建的工程的src目录下： 2、再将WEB-INF/lib下被圈中的jar包导入我们创建工程的module下： 3、将struts2下的WEB-INF/web.xml中的过滤器部分粘到我们工程的web.xml中： 其中&lt;url-pattern&gt;/*&lt;/url-pattern&gt; 不要写/*.do或者 /*.action，约定俗成用/* 访问http://localhost:8888/Struts2_0100_Introduction/hello.action时，就会自动执行到hello.jsp文件上去。（注意：访问localhost:8888出错的原因是由于没有编写index.jsp文件） 第六课. Struts2_HelloWorld_5.第一件事情是把struts.xml文件里面的devMode设置为”true”，按照正常流程来讲，devMode开启之后，再修改文件就会自动在tomcat中reload，但是这个在我的idea中没有生效 我们查看org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter源码： 然后我们在src下创建一个T.class：import org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter; public class T { StrutsPrepareAndExecuteFilter f;} 第八课. Struts2_HelloWorld_7_1struts2的执行流程: 当用户在浏览器中敲入要访问的地址http://localhost:8888/Struts2_0100_Introduction/helle.action的时候，浏览器会将这个请求发送给tomcat然后tomcat判断应该交给哪个WebApplication来处理，然后会读取它下面的web.xml配置发现有配置：1234567891011&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 它会过滤所有的请求然后就交给filter类org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter处理执行调用doFilter()方法，然后再方法中会读取struts-xml文件，根据用户请求的地址找到相应的namespace、 action、 result、然后将相应的页面jsp返回给浏览器 整个流程图如下： 这个过程其实就是在client到要获取的jsp过程中加了一层用来处理，这样就实现了把请求和视图分开. 第十课. Struts2_Namespace命名空间.Action内容：Action入门 struts作用 Namespace定义自己的Action路径设置调用Action的自定义方法通配符接收用户输入（3种方式）乱码问题解决简单数据校验action中访问web元素包含模块配置文件默认action namespace决定了action的访问路径，默认为””，可以接收所有路径的action（比如为了执行index.action，可以访问http://localhost:8888/Struts2_0100_Introduction/index.action也可以是http://localhost:8888/Struts2_0100_Introduction/hafsfhkjds/index.action等等）namespace可以写为/，或者/xxx，或者/xxx/yyy，对应的action访问路径为/index.action，/xxx/index.action，或者/xxx/yyy/index.actionnamespace最好也用模块来进行命名 代码讲解：在struts.xml文件中：123456&lt;constant name="struts.devMode" value="true" /&gt;&lt;package name="front" extends="struts-default" namespace="/front"&gt; &lt;action name="index"&gt; &lt;result&gt;/Namespace.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; package相当于java的package，用于区分不同包下相同的命名，避免重名extends现在就这么写，等讲完配置文件的配置就懂了namespace写的是什么，你想要访问action的时候就得在前面带上这个namespace，namespace必须以/开头。例如：http://localhost:8888/Struts2_0200_Namespace/front/indexpackage中的namespace和name一般用于模块管理，比如开发一个用户模块，就可以将name=”user”并且namespace=”user”下面的result的name=”success”，由于success是默认值，所以可以不写。 第十一课. Struts2_Action访问效果: 重点代码：12345&lt;package name="front" extends="struts-default" namespace="/"&gt; &lt;action name="index" class="com.bjsxt.struts2.front.action.IndexAction1"&gt; &lt;result name="success"&gt;/ActionIntroduction.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 看到这个里面的action标签多了一个class。完整的交互过程： 可以看到上面执行action时遇到一个class的时候，就create一个Action对象IndexAction，然后执行这个action的execute方法，最后方法返回一个success，这样就去执行result里的jsp。注意：(1)struts1 与struts2的一个重要区别：在struts1中进行多次访问的时候用到的是同一个Action对象。而struts2则是每一次访问都会创建一个Action对象，所以struts2不会有线程安全问题的发生(2)标签如果没有指定name属性默认返回值为success(3)标签中的class值如果没有配置相应的类，它会调用struts默认的一个处理类的execute()方法.(4)实现struts的处理类的时候不要自己随便写类然后定义execute()方法，也不要实现Action类而要从ActionSupport类继承，可以直接使用它为我们定义好的方法. 所以最后上面的繁琐过程就简化为了：123&lt;action name=”index”&gt; &lt;result&gt;/ActionIntroduction.jsp&lt;/result&gt;&lt;/action&gt; 三种实现Action的方法：第一种：12345public class IndexAction1 &#123; public String execute() &#123; return "success"; &#125;&#125; 第二种：123456public class IndexAction2 implements Action &#123; @Override public String execute() &#123; return "success"; &#125;&#125; 第三种：1234567public class IndexAction3 extends ActionSupport &#123; @Override public String execute() &#123; return "success"; &#125;&#125; 我们平时开发，只用第三种继承方法，因为里面封装了特别多的方法，其他两种忘了就可以了。 第十二课. 路径问题(1)struts2中的路径问题是根据action的路径而不是jsp路径来确定，所以尽量不要使用相对路径。虽然可以用redirect方式解决，但redirect方式并非必要。解决办法非常简单，统一使用绝对路径。（在jsp中用request.getContextRoot方式来拿到webapp的路径）或者使用myeclipse经常用的，指定basePath(2)request.getContextPath()得到项目的名字,一般用来解决路径问题 如果项目为根目录,则得到一个””,即空的字条串。 request.getscheme()返回的协议名称.默认是http request.getServerName()就是获取你的网站的域名，如果是在本地的话就是localhostrequest.getServerPort()获取服务的端口号 举例（path.jsp）：1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="GB18030" ?&gt;&lt;%@ page language="java" contentType="text/html; charset=GB18030" pageEncoding="GB18030"%&gt; &lt;%@taglib uri="/struts-tags" prefix="s" %&gt; &lt;%String path = request.getContextPath(); System.out.println("path: " + path);String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; System.out.println("basepath: " + basePath);%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;base href="&lt;%=basePath%&gt;" /&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=GB18030" /&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;struts2中的路径问题是根据action的路径而不是jsp路径来确定，所以尽量不要使用相对路径。&lt;br /&gt;&lt;a href="index.jsp"&gt;index.jsp&lt;/a&gt;&lt;br /&gt;虽然可以用redirect方式解决，但redirect方式并非必要。&lt;br /&gt;解决办法非常简单，统一使用绝对路径。（在jsp中用request.getContextRoot方式来拿到webapp的路径）&lt;br /&gt;或者使用myeclipse经常用的，指定basePath&lt;/body&gt;&lt;/html&gt; 一种写绝对路径的方法，是计算出basePath以后，将单个改成：&lt;a href=&quot;&lt;%=basePath %&gt;&quot;index.jsp&quot;&gt;index.jsp&lt;/a&gt; 另外一种就是直接设置所有的链接的前缀：&lt;base href=&quot;&lt;%=basePath%&gt;&quot; /&gt;就是我们上面代码写的那样。 这样再写相对路径，都是基于这个basePath来进行叠加的。 第十三课. ActionMethod_DMI动态方法调用.部署好project运行，运行结果是： 方式1： 方式2: struts代码如下：123456789101112&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="user" extends="struts-default" namespace="/user"&gt; &lt;action name="userAdd" class="com.bjsxt.struts2.user.action.UserAction" method="add"&gt; &lt;result&gt;/user_add_success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="user" class="com.bjsxt.struts2.user.action.UserAction"&gt; &lt;result&gt;/user_add_success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 方式1中有一个class是com.bjsxt.struts2.user.action.UserAction，method是add方法，所以直接回去UserAction中调用add方法：package com.bjsxt.struts2.user.action; 123456789import com.opensymphony.xwork2.ActionSupport;public class UserAction extends ActionSupport &#123; public String add() &#123; return SUCCESS; &#125; &#125; 返回值是SUCCESS，而result没有name，所以直接算默认值是SUCCESS，这样就返回/user_add_success.jsp的结果并进行显示。 如果另外有一个方法delete，那么久需要创建一个新的Action对象，如果还有其他方法也需要创建其他的Action对象，所以很繁琐，不建议使用（忘了就可以了）。 第二种方式直接将action命名为user，并且没有method，这样返回的结果是http://localhost:8888/user/user!addadd是user的一个方法，这种就叫做动态调用 第十四课. ActionWildcard通配符配置.看页面效果： 我们点击添加学生的链接以后，直接匹配到了actions包下的Studentadd的action 看我们的struts.xml：12345678910111213&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="actions" extends="struts-default" namespace="/actions"&gt; &lt;action name="Student*" class="com.bjsxt.struts2.action.StudentAction" method="&#123;1&#125;"&gt; &lt;result&gt;/Student&#123;1&#125;_success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="*_*" class="com.bjsxt.struts2.action.&#123;1&#125;Action" method="&#123;2&#125;"&gt; &lt;result&gt;/&#123;1&#125;_&#123;2&#125;_success.jsp&lt;/result&gt; &lt;!-- &#123;0&#125;_success.jsp --&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在index.jsp页面中点击添加学生按钮，就会点击这样的链接：&lt;a href=&quot;&lt;%=context %&gt;/actions/Studentadd&quot;&gt;添加学生&lt;/a&gt;这个链接其实就是：localhost:8888/actions/Studentadd它在struts.xml中首先匹配到了name=”actions”的package，然后在这个包下面匹配到了action name=”Student“ 然后就被add代替，后面的method也被占位符*所表示的add所取代，就会到StudentAction类中去执行add方法，返回结果是SUCCESS,于是就执行result，将Studentadd_success.jsp的结果返回回来。 第十五课. 用Action的属性接收参数.定义UserAction的类，里面定义两个属性name和age，然后定义它们的getter和setter，再定义add()方法 12345678910111213141516171819202122232425262728293031package com.bjsxt.struts2.user.action;import com.opensymphony.xwork2.ActionSupport;public class UserAction extends ActionSupport &#123; private String name; private int age; public String add() &#123; System.out.println("name=" + name); System.out.println("age=" + age); return SUCCESS; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 然后在index.jsp中定义&lt;a href=&quot;user/user!add?name=a&amp;age=8&quot;&gt;添加用户&lt;/a&gt; 这样会在struts中搜索到匹配的Action对象，并用这个对象的add方法处理参数 第十六课. 用DomainModel接收参数.运行效果： 新project中定义了三个类:UserAction、UserDTO、User： 其中UserAction就是匹配struts.xml中的action进行处理的action，代码如下：123456789101112131415161718192021222324package com.bjsxt.struts2.user.action;import com.bjsxt.struts2.user.model.User;import com.opensymphony.xwork2.ActionSupport;public class UserAction extends ActionSupport &#123; private User user; //private UserDTO userDTO; public String add() &#123; System.out.println("name=" + user.getName()); System.out.println("age=" + user.getAge()); return SUCCESS; &#125; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; &#125; 在链接中已经直接给DomainModel，也就是User进行了赋值。User代码如下：123456789101112131415161718package com.bjsxt.struts2.user.model;public class User &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 这里还设计了一个UserDTO类，重要是用于在action和DomainModel之间传递数据。示例图如下： 第十七课. 用ModelDriven接收参数运行效果如下： 在上一个project中，链接是user.name和user.age来对DomainModel进行设置，但是这一次我们直接进行对name和age设置。 类组织如下： 来看UserAction的代码： 12345678910111213141516171819202122package com.bjsxt.struts2.user.action;import com.bjsxt.struts2.user.model.User;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;public class UserAction extends ActionSupport implements ModelDriven&lt;User&gt;&#123; private User user = new User(); public String add() &#123; System.out.println("name=" + user.getName()); System.out.println("age=" + user.getAge()); return SUCCESS; &#125; @Override public User getModel() &#123; return user; &#125; &#125; 里面涉及到了一个ModelDriven，我们再来研究ModelDriven，代码如下：12345678910//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.opensymphony.xwork2;public interface ModelDriven&lt;T&gt; &#123; T getModel();&#125; 可以看到，ModelDriven只有一个getModel方法，我们的UserAction实现了这个方法，返回了一个DomainModel，也就是user 完整的执行机制： 总结一下：Struts2中Action接收参数的方法主要有以下三种：1.使用Action的属性接收参数： &nbsp;&nbsp;&nbsp;&nbsp;a.定义：在Action类中定义属性，创建get和set方法； &nbsp;&nbsp;&nbsp;&nbsp;b.接收：通过属性接收参数，如：userName； &nbsp;&nbsp;&nbsp;&nbsp;c.发送：使用属性名传递参数，如：user1!add?userName=Magci；2.使用DomainModel接收参数： &nbsp;&nbsp;&nbsp;&nbsp;a.定义：定义Model类，在Action中定义Model类的对象（不需要new），创建该对象的get和set方法； &nbsp;&nbsp;&nbsp;&nbsp;b.接收：通过对象的属性接收参数，如：user.getUserName()； &nbsp;&nbsp;&nbsp;&nbsp;c.发送：使用对象的属性传递参数，如：user2!add?user.userName=MGC；3.使用ModelDriven接收参数： &nbsp;&nbsp;&nbsp;&nbsp;a.定义：Action实现ModelDriven泛型接口，定义Model类的对象（必须new），通过getModel方法返回该对象； &nbsp;&nbsp;&nbsp;&nbsp;b.接收：通过对象的属性接收参数，如：user.getUserName()； &nbsp;&nbsp;&nbsp;&nbsp;c.发送：直接使用属性名传递参数，如：user2!add?userName=MGC 其中第一种偶尔用，第二种常用，第三种不经常用，所以要牢记第二种用法。 第十八课. Struts2.1.6版本的中文问题.运行： 后台看到结果： 可以显示中文字符~ struts.xml内容：12345678910111213&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;constant name="struts.i18n.encoding" value="GBK" /&gt; &lt;!-- internationalization --&gt; &lt;package name="user" extends="struts-default" namespace="/user"&gt; &lt;action name="userAdd" class="com.bjsxt.struts2.user.action.UserAction" method="add"&gt; &lt;result&gt;/user_add_success.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="user" class="com.bjsxt.struts2.user.action.UserAction"&gt; &lt;result&gt;/user_add_success.jsp&lt;/result&gt; &lt;/action&gt;&lt;constant name="struts.i18n.encoding" value="GBK" /&gt; 一句就可以解决中文显示问题了。 下面这个是web.xml的内容，之前我们用的是第二个filter，也就是旧的filter，没有问题，可以正常显示中文，但是使用新的filter时，就是下面的代码时，name就会显示乱码 12345678910&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;!--&lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;--&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 乱码： 之后我们会用Spring的过滤器解决这个问题。 第十九课. 简单数据验证读源码方式：从jsp页面开始读起 我们先看一下运行效果： 先看一下index.jsp的代码：123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="GB18030" ?&gt;&lt;%@ page language="java" contentType="text/html; charset=GB18030" pageEncoding="GB18030"%&gt;&lt;% String path = request.getContextPath();String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=GB18030" /&gt;&lt;base href="&lt;%=basePath %&gt;"/&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;使用addFieldError方法和s:fieldError标签简单处理数据校验&lt;a href="user/user!add?name=a" &gt;添加用户&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 点击添加用户后就执行user/user!add?name=a这个action 看一下struts.xml的代码： 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="user" extends="struts-default" namespace="/user"&gt; &lt;action name="user" class="com.bjsxt.struts2.user.action.UserAction"&gt; &lt;result&gt;/user_add_success.jsp&lt;/result&gt; &lt;result name="error"&gt;/user_add_error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 链接首先匹配到user的package，是user，然后在user下执行user这个action，并且传入name=a的参数，它的Action对象是com.bjsxt.struts2.user.action.UserAction，该类代码如下：12345678910111213141516171819202122232425package com.bjsxt.struts2.user.action;import com.opensymphony.xwork2.ActionSupport;public class UserAction extends ActionSupport &#123; private String name; public String add() &#123; if(name == null || !name.equals("admin")) &#123; this.addFieldError("name", "name is error"); this.addFieldError("name", "name is too long"); return ERROR; &#125; return SUCCESS; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 执行这个对象的add方法，由于name不等于admin，所以执行：12345if(name == null || !name.equals("admin")) &#123; this.addFieldError("name", "name is error"); this.addFieldError("name", "name is too long"); return ERROR;&#125; addFieldError方法就是向ValueStack中的fieldError中添加域错误信息。 查看Value Stack中的信息： 发现Value Stack是一个栈，存的是一个一个键值对，键是Property Name，值是Property Value，值中又存的是一个Map比如我们的errors，键是name，值是一个数组，包括name is error和name is too long这两个值， 看一下user_add_error.jsp中的代码123456789101112131415161718&lt;?xml version="1.0" encoding="GB18030" ?&gt;&lt;%@ page language="java" contentType="text/html; charset=GB18030" pageEncoding="GB18030"%&gt;&lt;%@taglib uri="/struts-tags" prefix="s" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=GB18030" /&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; User Add Error! &lt;s:fielderror fieldName="name" theme="simple"/&gt; &lt;br /&gt; &lt;s:property value="errors.name[0]"/&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt; 其中&lt;s:fielderror fieldName=&quot;name&quot; theme=&quot;simple&quot;/&gt;以固定的css样式取出错误信息，不方便我们进行相应的处理 为了用我们自己的样式来显示错误信息，我们利用如下的写法，将Value Stack中的一个元素取出来，这样就可以加上我们的css样式了:&lt;s:property value=&quot;errors.name[1]&quot;/&gt; 为了显示详细的栈信息，可以如下写：&lt;s:debug&gt;&lt;/s:debug&gt; 这里再声明一下，&lt;%@taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt; 这一句是将struts-tags.tld引入进来，文件位置如下： 我们的&lt;s:fielderror …&gt;就是用了其中的标签，可以将UserAction中的参数值传入进来，比如我们的UserAction中name=a，那么fieldname中的name也就等于了a 第二十课. 简单数据验证_2在值栈中可以为同一个名字加多个值，比如12345if(name == null || !name.equals("admin")) &#123; this.addFieldError("name", "name is error"); this.addFieldError("name", "name is too long"); return ERROR; &#125; 就为name这个名字添加了两个FieldError，在上一节的值栈也可以直观地看到这一点。 第二十一课. 访问Web元素_1先看一下运行效果： 输入一个用户名r，密码r得到下面的结果： 我们来读源码，先看index.jsp内容：1234567891011121314151617181920&lt;body&gt;取得Map类型request,session,application,真实类型 HttpServletRequest, HttpSession, ServletContext的引用:&lt;ol&gt; &lt;li&gt;前三者：依赖于容器&lt;/li&gt; &lt;li&gt;前三者：IOC&lt;/li&gt; (只用这种) &lt;li&gt;后三者：依赖于容器&lt;/li&gt; &lt;li&gt;后三者：IOC&lt;/li&gt;&lt;/ol&gt;&lt;br /&gt;&lt;form name="f" action="" method="post"&gt;用户名：&lt;input type="text" name="name"/&gt;密码：&lt;input type="text" name="password"/&gt;&lt;br /&gt;&lt;input type="button" value="submit1" onclick="javascript:document.f.action='login/login1';document.f.submit();" /&gt;&lt;input type="button" value="submit2" onclick="javascript:document.f.action='login/login2';document.f.submit();" /&gt;&lt;input type="button" value="submit3" onclick="javascript:document.f.action='login/login3';document.f.submit();" /&gt;&lt;input type="button" value="submit4" onclick="javascript:document.f.action='login/login4';document.f.submit();" /&gt;&lt;/form&gt; &lt;/body&gt; 点击第一个按钮，会执行onclick里面的js代码，取到了form，action是login/login1再看一下struts.xml内容：12345678&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="login" extends="struts-default" namespace="/login"&gt; &lt;action name="login*" class="com.bjsxt.struts2.user.action.LoginAction&#123;1&#125;"&gt; &lt;result&gt;/user_login_success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 匹配到login这个package，发现action有通配符，匹配成功，执行LoginAction1这个类的对象。查看对应java代码：12345678910111213141516171819202122232425262728package com.bjsxt.struts2.user.action;import java.util.Map;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginAction1 extends ActionSupport &#123; private Map request; private Map session; private Map application; public LoginAction1() &#123; request = (Map)ActionContext.getContext().get("request"); session = ActionContext.getContext().getSession(); application = ActionContext.getContext().getApplication(); &#125; public String execute() &#123; request.put("r1", "r1"); session.put("s1", "s1"); application.put("a1", "a1"); return SUCCESS; &#125; &#125; 里面request是从(Map)ActionContext.getContext().get(“request”);这样的方式取到的，这时候就需要getContext其实拿到的就是我们的Stack Context，Context在servlet是servlet context，在jsp中就是application，也就是上下文。我们查看我们的Stack Context，就是上下文栈，里面有request，session，也有application，通过get(“request”)，getSession()和getApplication()就可以拿到对应的Map 然后在request、session和application中存值：123request.put("r1", "r1");session.put("s1", "s1");application.put("a1", "a1"); 在我们一开始的前台页面可以看到这三个值是存放成功的，其实这里struts2做了一个工作，就是把我们定义得到Map中存放的值导入到了HTTP报文中，所以可以在HTTP中的request、session和application中可以直接去访问信息。 user_login_success.jsp代码如下：123456789101112&lt;body&gt; User Login Success! &lt;br /&gt; &lt;s:property value="#request.r1"/&gt; | &lt;%=request.getAttribute("r1") %&gt; &lt;br /&gt; &lt;s:property value="#session.s1"/&gt; | &lt;%=session.getAttribute("s1") %&gt; &lt;br /&gt; &lt;s:property value="#application.a1"/&gt; | &lt;%=application.getAttribute("a1") %&gt; &lt;br /&gt; &lt;s:property value="#attr.a1"/&gt;&lt;br /&gt; &lt;s:property value="#attr.s1"/&gt;&lt;br /&gt; &lt;s:property value="#attr.r1"/&gt;&lt;br /&gt; &lt;s:debug&gt;&lt;/s:debug&gt; &lt;br /&gt;&lt;/body&gt; 发现前台是是通过直接方法HTTP的request、session和application来显示信息的。Value Stack内容可以直接拿，但是Stack Context中内容需要在前台使用#来取，也就是我们上面写的：&lt;s:property value=&quot;#request.r1&quot;/&gt;取到了request中r1的值。后面的&lt;%=request.getAttribute(&quot;r1&quot;) %&gt;是使用传统jsp方式取到了request值，和前面效果一样。 &lt;s:property value=&quot;#attr.a1&quot;/&gt;会在Stack Context中搜索request、session和application来查找值叫a1的属性是什么，查到了就返回来，不建议使用，因为通常情况下我们没有准确知道一个值是属于request、session还是application。 第二十二课. 访问Web元素_2来看第二种获取web元素的方式：查看LoginAction2.java：12345678910111213141516171819202122232425262728293031323334353637383940414243package com.bjsxt.struts2.user.action;import java.util.Map;import org.apache.struts2.interceptor.ApplicationAware;import org.apache.struts2.interceptor.RequestAware;import org.apache.struts2.interceptor.SessionAware;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginAction2 extends ActionSupport implements RequestAware,SessionAware, ApplicationAware &#123; private Map&lt;String, Object&gt; request; private Map&lt;String, Object&gt; session; private Map&lt;String, Object&gt; application; //DI dependency injection //IoC inverse of control public String execute() &#123; request.put("r1", "r1"); session.put("s1", "s1"); application.put("a1", "a1"); return SUCCESS; &#125; @Override public void setRequest(Map&lt;String, Object&gt; request) &#123; this.request = request; &#125; @Override public void setSession(Map&lt;String, Object&gt; session) &#123; this.session = session; &#125; @Override public void setApplication(Map&lt;String, Object&gt; application) &#123; this.application = application; &#125; &#125; 发现这个代码很有趣，因为之前我们的request等需要自己取出，然后再使用，而现在，我们的setRequest参数列表中，直接给我们传入一个Map request，都不知道是从哪里来的，就可以用了。其实这里涉及到了一个设计方法，第一个叫DI(dependency injection)–依赖注入第二个叫IoC(inverse of control)– 控制反转 这个过程的流程图如下： 首先struts2创建一个LoginAction对象，然后查看是否实现了RequestAware接口，如果实现了，就可以使用setRequest(Map request)这样的方法来依赖注入，也就是原先是自己去获取getContext，然后调用方法，是主动地，但是现在是struts帮我们注入一个request，这就叫做依赖注入，也叫做控制反转，就是从主动变为被动。 我们访问web元素时，只用这种方法。 为了直接访问HttpRequest，而不是通过Map来访问，可以定义使用第三种方法（LoginAction3.java）：123456789101112131415161718192021222324252627282930package com.bjsxt.struts2.user.action;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.apache.struts2.ServletActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginAction3 extends ActionSupport &#123; private HttpServletRequest request; private HttpSession session; private ServletContext application; public LoginAction3() &#123; request = ServletActionContext.getRequest(); session = request.getSession(); application = session.getServletContext(); &#125; public String execute() &#123; request.setAttribute("r1", "r1"); session.setAttribute("s1", "s1"); application.setAttribute("a1", "a1"); return SUCCESS; &#125; &#125; 直接定义HttpServletRequest并获取来进行访问，这种方式基本不用，所以可以忘记了。 第四种方式也是依赖注入的，代码如下（LoginAction4.java）：1234567891011121314151617181920212223242526272829303132333435package com.bjsxt.struts2.user.action;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import org.apache.struts2.interceptor.ServletRequestAware;import com.opensymphony.xwork2.ActionSupport;public class LoginAction4 extends ActionSupport implements ServletRequestAware &#123; private HttpServletRequest request; private HttpSession session; private ServletContext application; public String execute() &#123; request.setAttribute("r1", "r1"); session.setAttribute("s1", "s1"); application.setAttribute("a1", "a1"); return SUCCESS; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; this.session = request.getSession(); this.application = session.getServletContext(); &#125; &#125; 第四种方式也基本不用。 综上所述，我们只用第二种方式，其他三种方式理解就可以了。 第二十三课. 模块包含.struts.xml文件如下：123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;include file="login.xml" /&gt;&lt;/struts&gt; 里面就是把login.xml包含进来，目的是为了模块化，不同的人开发不同的xml，最后将共同的一些配置在struts.xml中进行定义，并且将这些不同的xml文件include进来。 第二十四课. 默认Action我们先来查看struts.xml文件内容：12345678910&lt;struts&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;package name="default" namespace="/" extends="struts-default"&gt; &lt;default-action-ref name="index"&gt;&lt;/default-action-ref&gt; &lt;action name="index"&gt; &lt;result&gt;/default.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 如果把&lt;default-action-ref name=&quot;index&quot;&gt;&lt;/default-action-ref&gt;这一句注释掉，那么直接访问就会localhost:8888会报错，因为没有找到对应的Action，如果加上这一句，在没有找到Action的时候，也会执行default.jsp，就是默认Action，即使URI输错了，也会跳到默认Action： 这样，我们可以利用这个功能，来制作类似404 Not Found这样的页面。 第二十五课. Action总结 实现一个Action的最常用的方式：从ActionSupport继承 DMI动态方法定义! 通配符设置&#42;{1}{2}…&nbsp;&nbsp;a)&#42;_&#42;&nbsp;&nbsp;b) &#42;|&#42;(其他都可以，但是不能&#42;&#42;) 接收参数的方法（一般用属性或者DomainModel来接受） 简单参数验证addFieldErrora) 一般不使用Struts2的UI标签 访问Web元素a) Map类型&nbsp;&nbsp;i. IoC&nbsp;&nbsp;ii. 以来Struts2 包含文件配置 默认action处理 再精简总结，Struts非常简单，就是从ActionSupport继承实现一个Action，然后自己定义add、delete等方法，用DomainModel来接受参数，如果需要访问Web元素，就使用IoC来访问。这就是Struts2中Action的全部精髓。]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BBS搭建完整过程笔记]]></title>
    <url>%2F2017%2F12%2F01%2FBBS%2F</url>
    <content type="text"><![CDATA[本文介绍利用jsp和MySql、JDBC来搭建一个BBS的完整过程。 第三课. build_the_data目标： 掌握递归方法 掌握javascript + html + css + jsp + servlet初步应用 掌握分页写法 初步掌握前台/后台的概念 为下一个项目做准备 不会涉及太多的分析/设计上的知识 简单需求 能够树形展现 能够平板型展现 能够回复帖子 后台能够管理帖子 删除 构造数据库（build_the_data） 首先创建一个J2EE的项目：BBS 然后在这个项目下创建一个SQL文件夹，在这个文件夹下创建一个bbs.sql文件：1234567891011121314151617181920212223create database bbs;use bbs;create table article (id int primary key auto_increment,pid int,rootid int,title varchar(255),cont text,pdate datetime,isleaf int );insert into article values (null, 0, 1, '蚂蚁大战大象', '蚂蚁大战大象', now(), 1);insert into article values (null, 1, 1, '大象被打趴下了', '大象被打趴下了',now(), 1);insert into article values (null, 2, 1, '蚂蚁也不好过','蚂蚁也不好过', now(), 0);insert into article values (null, 2, 1, '瞎说', '瞎说', now(), 1);insert into article values (null, 4, 1, '没有瞎说', '没有瞎说', now(), 0);insert into article values (null, 1, 1, '怎么可能', '怎么可能', now(), 1);insert into article values (null, 6, 1, '怎么没有可能', '怎么没有可能', now(), 0);insert into article values (null, 6, 1, '可能性是很大的', '可能性是很大的', now(), 0);insert into article values (null, 2, 1, '大象进医院了', '大象进医院了', now(), 1);insert into article values (null, 9, 1, '护士是蚂蚁', '护士是蚂蚁', now(), 0); 在idea中运行一下这个sql文件，得到最终的table： 第四课. connect_to_mysql接下来，我们需要书写我们的jsp文件，使得数据库能够被连上：在project下的web/WEB-INF创建ShowArticleTree.jsp，内容为：1234567891011121314151617181920212223242526272829&lt;%-- Created by IntelliJ IDEA. User: korson Date: 2017/11/23 Time: 12:54 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;%Class.forName("com.mysql.jdbc.Driver");String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421";Connection conn = DriverManager.getConnection(url);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%conn.close();%&gt;&lt;/body&gt;&lt;/html&gt; 我们将mysql的jdbc驱动导入到工程中： 运行这个jsp，发现在chrome中成功显示空白页面并且没有报错，成功连接上了数据库！！！ 第五课. show_the_data我们已经连接上了数据库，下一步我们想拿出一条数据进行显示，修改ShowArticleTree.jsp文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%-- Created by IntelliJ IDEA. User: korson Date: 2017/11/23 Time: 12:54 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;%Class.forName("com.mysql.jdbc.Driver");String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421";Connection conn = DriverManager.getConnection(url);Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery("select * from article");%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1"&gt;&lt;%while (rs.next())&#123;%&gt; &lt;tr&gt; &lt;td&gt;&lt;%= rs.getInt("id")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%= rs.getString("cont")%&gt;&lt;/td&gt; &lt;/tr&gt;&lt;%&#125;%&gt;&lt;/body&gt;&lt;% rs.close(); stmt.close(); conn.close();%&gt;&lt;/html&gt; 可以看到，上面采用html和jsp轮换的方式进行编程，利用jsp取出一条数据，然后在html上进行显示。 运行这个jsp后的显示效果： 第六课. show_the_tree使用递归方法进行显示。修改ShowArticleTree.jsp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;%!String str = "";private void tree(Connection conn, int id, int level)&#123; Statement stmt = null; ResultSet rs = null; String preStr = ""; for (int i = 0; i &lt; level; i++)&#123; preStr += "----"; &#125; try&#123; stmt = conn.createStatement(); String sql = "select * from article where pid = " + id; rs = stmt.executeQuery(sql); while(rs.next())&#123; str += "&lt;tr&gt;&lt;td&gt;" + rs.getInt("id") + "&lt;/td&gt;&lt;td&gt;" + preStr + rs.getString("cont") + "&lt;/td&gt;&lt;/tr&gt;"; if(rs.getInt("isleaf") != 0)&#123; tree(conn, rs.getInt("id"), level + 1); &#125; &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; try&#123; if(rs != null)&#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125;&#125;%&gt;&lt;%Class.forName("com.mysql.jdbc.Driver");String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421";Connection conn = DriverManager.getConnection(url);Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery("select * from article where pid = 0");while(rs.next())&#123; str += "&lt;tr&gt;&lt;td&gt;" + rs.getInt("id") + "&lt;/td&gt;&lt;td&gt;" + rs.getString("cont") + "&lt;/td&gt;&lt;/tr&gt;"; if(rs.getInt("isleaf") != 0)&#123; tree(conn, rs.getInt("id"), 1); &#125;&#125;rs.close();stmt.close();conn.close();%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1"&gt;&lt;%= str %&gt;&lt;/table&gt;&lt;/body&gt;&lt;%&lt;% str = ""%&gt;%&gt;&lt;/html&gt; 这里特别要注意每次显示完str内容后要清空，就是&lt;% str = &quot;&quot;%&gt;，要不然就会再原来基础上进行叠加。运行jsp显示页面： bingo!!! 第七课. show the detail先修改我们的ShowArticleTree.jsp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;%!String str = "";private void tree(Connection conn, int id, int level)&#123; Statement stmt = null; ResultSet rs = null; String preStr = ""; for (int i = 0; i &lt; level; i++)&#123; preStr += "----"; &#125; try&#123; stmt = conn.createStatement(); String sql = "select * from article where pid = " + id; rs = stmt.executeQuery(sql); while(rs.next())&#123; str += "&lt;tr&gt;&lt;td&gt;" + rs.getInt("id") + "&lt;/td&gt;&lt;td&gt;" + preStr + "&lt;a href='ShowArticleDetail.jsp?id=" + rs.getInt("id") + " '&gt;" + rs.getString("title") + "&lt;/a&gt;" + "&lt;/td&gt;&lt;/tr&gt;"; if(rs.getInt("isleaf") != 0)&#123; tree(conn, rs.getInt("id"), level + 1); &#125; &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; try&#123; if(rs != null)&#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125;&#125;%&gt;&lt;%Class.forName("com.mysql.jdbc.Driver");String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421";Connection conn = DriverManager.getConnection(url);Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery("select * from article where pid = 0");while(rs.next())&#123; str += "&lt;tr&gt;&lt;td&gt;" + rs.getInt("id") + "&lt;/td&gt;&lt;td&gt;" + "&lt;a href='ShowArticleDetail.jsp?id=" + rs.getInt("id") + " '&gt;" + rs.getString("title") + "&lt;/a&gt;" + "&lt;/td&gt;&lt;/tr&gt;"; if(rs.getInt("isleaf") != 0)&#123; tree(conn, rs.getInt("id"), 1); &#125;&#125;rs.close();stmt.close();conn.close();%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1"&gt;&lt;%= str %&gt;&lt;% str = "";%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 这样就在每个title上面加上了链接，支持页面的跳转，点开一个链接，发现后面也跟上了这个帖子的id号。 再补充ShowArticleDetail.jsp文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% String strId = request.getParameter("id"); int id = Integer.parseInt(strId); Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from article where id = " + id);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%if(rs.next())&#123;%&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;&lt;%= rs.getInt("id") %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Title&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString("title")%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Content&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString("cont")%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;%&#125;rs.close();stmt.close();conn.close();%&gt;&lt;/body&gt;&lt;/html&gt; 再次刷新tomcat并重新访问原来的jsp： 是的，可以正常看一条评论的全部详细内容了~不错吧~ 第八课. reply_1修改ShowArticleDetail.jsp，在上面加一句话添加一个回复按钮：1&lt;a href="Reply.jsp?id=&lt;%=rs.getInt("id")%&gt;&amp;rootid=&lt;%=rs.getInt("rootid")%&gt;"&gt;回复&lt;/a&gt; 完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% String strId = request.getParameter("id"); int id = Integer.parseInt(strId); Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from article where id = " + id);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%if(rs.next())&#123;%&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;&lt;%= rs.getInt("id") %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Title&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString("title")%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Content&lt;/td&gt; &lt;td&gt;&lt;%=rs.getString("cont")%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;a href="Reply.jsp?id=&lt;%=rs.getInt("id")%&gt;&amp;rootid=&lt;%=rs.getInt("rootid")%&gt;"&gt;回复&lt;/a&gt;&lt;%&#125;rs.close();stmt.close();conn.close();%&gt;&lt;/body&gt;&lt;/html&gt; 添加Reply.jsp：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@page import="java.sql.*" %&gt;&lt;% int id = Integer.parseInt(request.getParameter("id")); int rootId = Integer.parseInt(request.getParameter("rootid")); Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from article where id = " + id);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="ReplyOK.jsp" method="post"&gt; &lt;input type="hidden" name="id" value="&lt;%=id %&gt;"&gt; &lt;input type="hidden" name="rootid" value="&lt;%=rootId%&gt;"&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt; &lt;input type = "text" name="title" size="80"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;textarea cols="80" rows="12" name="cont"&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="submit" value="提交"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 第九课. reply_2添加ReplyOK.jsp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@page import="java.sql.*" %&gt;&lt;%request.setCharacterEncoding("gbk");int id = Integer.parseInt(request.getParameter("id"));int rootId = Integer.parseInt(request.getParameter("rootid"));String title = request.getParameter("title");String cont = request.getParameter("cont");cont = cont.replaceAll("\n", "&lt;br&gt;");Class.forName("com.mysql.jdbc.Driver");String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421";Connection conn = DriverManager.getConnection(url);String sql = "insert into article values (null, ?, ?, ?, ?, now(), 0)";PreparedStatement pstmt = conn.prepareStatement(sql);Statement stmt = conn.createStatement();conn.setAutoCommit(false);pstmt.setInt(1, id);pstmt.setInt(2, rootId);pstmt.setString(3, title);pstmt.setString(4, cont);pstmt.executeUpdate();stmt.executeUpdate("update article set isleaf = 1 where id = " + id);conn.commit();conn.setAutoCommit(true);stmt.close();pstmt.close();conn.close();response.sendRedirect("ShowArticleTree.jsp");%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;font color="red" size="7"&gt; OK!&lt;/font&gt;&lt;/body&gt;&lt;/html&gt; 注意解决换行和中文乱码的问题！可以看到现在可以正常回复评论并插入数据库了~是不是很nice~ 第十课. delete the article在ShowArticleTree.jsp中添加句子：12345678910while(rs.next())&#123; str += "&lt;tr&gt;&lt;td&gt;" + rs.getInt("id") + "&lt;/td&gt;&lt;td&gt;" + preStr + "&lt;a href='ShowArticleDetail.jsp?id=" + rs.getInt("id") + " '&gt;" + rs.getString("title") + "&lt;/a&gt;&lt;/td&gt;" + "&lt;td&gt;&lt;a href = 'Delete.jsp?id=" + rs.getInt("id") + "&amp;pid=" + rs.getInt("pid") +"'&gt;删除&lt;/a&gt;" + "&lt;/td&gt;&lt;/tr&gt;"; if(rs.getInt("isleaf") != 0)&#123; tree(conn, rs.getInt("id"), level + 1); &#125;&#125; 编写Delete.jsp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@page import="java.sql.*" %&gt;&lt;%! private void del(Connection conn, int id)&#123; Statement stmt = null; ResultSet rs = null; try&#123; stmt = conn.createStatement(); String sql = "select * from article where pid = " + id; rs = stmt.executeQuery(sql); while(rs.next())&#123; del(conn,rs.getInt("id")); &#125; stmt.executeUpdate("DELETE from article where id = " + id); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; try&#123; if(rs != null)&#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;%&gt;&lt;% int id = Integer.parseInt(request.getParameter("id")); int pid = Integer.parseInt(request.getParameter("pid")); Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); String sql = "insert into article values (null, ?, ?, ?, ?, now(), 0)"; PreparedStatement pstmt = conn.prepareStatement(sql); conn.setAutoCommit(false); del(conn, id); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("SELECT count(*) from article where pid = " + pid); rs.next(); int count = rs.getInt(1); rs.close(); stmt.close(); if(count &lt;= 0)&#123; Statement stmtUpdate = conn.createStatement(); stmtUpdate.executeUpdate("update article set isleaf = 0 where id = " + pid); stmtUpdate.close(); &#125; conn.commit(); conn.setAutoCommit(true); conn.close(); response.sendRedirect("ShowArticleTree.jsp");%&gt; 第十一课. Post_new_article增加发表新帖的功能，在ShowArticleTree.jsp中增加语句:&lt;a href=&quot;Post.jsp&quot;&gt;发表新帖&lt;/a&gt; 仿照ReplyOK.jsp编写Post.jsp文件：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;%-- Created by IntelliJ IDEA. User: korson Date: 2017/11/25 Time: 10:21 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% request.setCharacterEncoding("gbk"); String action = request.getParameter("action"); if(action != null &amp;&amp; action.equals("post")) &#123; String title = request.getParameter("title"); String cont = request.getParameter("cont"); cont = cont.replaceAll("\n", "&lt;br&gt;"); Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); String sql = "insert into article values (null, ?, ?, ?, ?, now(), 0)"; PreparedStatement pstmt = conn.prepareStatement(sql); Statement stmt = conn.createStatement(); conn.setAutoCommit(false);/* pstmt.setInt(1, id); pstmt.setInt(2, rootId); pstmt.setString(3, title); pstmt.setString(4, cont); pstmt.executeUpdate(); stmt.executeUpdate("update article set isleaf = 1 where id = " + id);*/ conn.commit(); conn.setAutoCommit(true); // stmt.close(); // pstmt.close(); conn.close(); response.sendRedirect("ShowArticleTree.jsp"); &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="Post.jsp" method="post"&gt; &lt;input type="hidden" name="action" value="post"&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt; &lt;input type = "text" name="title" size="80"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;textarea cols="80" rows="12" name="cont"&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="submit" value="提交"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 运行可以看到页面可以发帖，只不过现在还没有向数据库中插入。 再进行修改，使得可以支持向数据库插入： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% request.setCharacterEncoding("gbk"); String action = request.getParameter("action"); if(action != null &amp;&amp; action.equals("post")) &#123; String title = request.getParameter("title"); String cont = request.getParameter("cont"); cont = cont.replaceAll("\n", "&lt;br&gt;"); Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); conn.setAutoCommit(false); //pid=0,因为是主贴 String sql = "insert into article values (null, 0, ?, ?, ?, now(), 0)"; //直接帮我们生成一个新的id PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); Statement stmt = conn.createStatement(); //第一个位置是rootId pstmt.setInt(1, -1); pstmt.setString(2, title); pstmt.setString(3, cont); pstmt.executeUpdate(); //将生成的key装到结果集中 ResultSet rsKey = pstmt.getGeneratedKeys(); rsKey.next(); int key = rsKey.getInt(1); rsKey.close(); stmt.executeUpdate("update article set rootid = " + key + " where id = " + key);// stmt.executeUpdate("update article set isleaf = 1 where id = " + id);*/ conn.commit(); conn.setAutoCommit(true); stmt.close(); pstmt.close(); conn.close(); response.sendRedirect("ShowArticleTree.jsp"); &#125;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="Post.jsp" method="post"&gt; &lt;input type="hidden" name="action" value="post"&gt; &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt; &lt;input type = "text" name="title" size="80"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;textarea cols="80" rows="12" name="cont"&gt;&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;input type="submit" value="提交"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这时候再发帖，就可以成功插入了~ 第十三、十四课. admin_loginLogin.jsp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284&lt;%@ page contentType="text/html; charset=gbk" pageEncoding="gbk" %&gt;&lt;%String action = request.getParameter("action");if(action != null &amp;&amp; action.equals("login")) &#123; String username = request.getParameter("uname"); String password = request.getParameter("pwd"); if(username == null || !username.equals("admin")) &#123; %&gt; &lt;font color="white" size=5&gt;username not correct!&lt;/font&gt; &lt;% //return; &#125;else if(password == null || !password.equals("admin")) &#123; out.println("password not correct!"); //return; &#125;else &#123; session.setAttribute("admin", "true"); response.sendRedirect("ShowArticleTree.jsp"); &#125;&#125;%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;!-- saved from url=(0054)http://www.simworld.com/client_access/client_login.asp --&gt;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;SIM - Client Access - Login&lt;/TITLE&gt;&lt;META http-equiv=Content-Type content="text/html; charset=gbk" pageEncoding="gbk"&gt;&lt;LINK href="images/sim_stylesheet.css" type=text/css rel=styleSheet&gt;&lt;SCRIPT language=JavaScript src="" type=text/javascript&gt;&lt;/SCRIPT&gt;&lt;SCRIPT language=JavaScript src="" type=text/javascript&gt;&lt;/SCRIPT&gt;&lt;SCRIPT language=JavaScript src="" type=text/javascript&gt;&lt;/SCRIPT&gt;&lt;META content="MSHTML 6.00.2900.2963" name=GENERATOR&gt;&lt;style type="text/css"&gt;&lt;!--.STYLE1 &#123;color: #CCCCCC&#125;--&gt;&lt;/style&gt;&lt;/HEAD&gt;&lt;BODY bgColor=#20355a leftMargin=0 topMargin=0 onload=init() marginheight="0" marginwidth="0"&gt;&lt;!--Begin all TOP NAVIGATIOND ROPDOWN LAYERS ------------&gt;&lt;!--Begin About Sim Dropdown 1 --&gt;&lt;DIV id=about_sim_drop1&gt;&lt;TABLE cellSpacing=0 cellPadding=0 width=140 border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD bgColor=#ffffff&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width=140 border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top align=left width=130&gt;&lt;A class=topnav onmouseover="stopTime(); showLayer('about_sim_corporate_drop2'); hideLayer('about_sim_portfolio_drop2');" onmouseout=startTime(); href="http://www.simworld.com/about_sim/corporate/index.asp"&gt;Corporate Info&lt;/A&gt;&lt;/TD&gt; &lt;TD vAlign=top width=10&gt;&lt;IMG height=10 alt=arrow src="images/nav_arrows.gif" width=10&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;!-- &lt;TR&gt; &lt;TD bgColor=#cacfda&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width=140 border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top align=left width=130&gt;&lt;A class=topnav onmouseover="stopTime(); hideLayer('about_sim_corporate_drop2');" onmouseout=startTime(); href="http://www.simworld.com/about_sim/products/index.asp"&gt;Products&lt;/A&gt;&lt;/TD&gt; &lt;TD vAlign=top width=10&gt;&lt;IMG height=10 alt="" src="images/spacer.gif" width=10&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;!--&lt;tr&gt; &lt;TR&gt; &lt;TD bgColor=#ffffff&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width=140 border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top align=left width=130&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout="startTime(); hideLayer('about_sim_corporate_drop2');" href="http://www.simworld.com/about_sim/portfolio/index_temp.asp"&gt;Portfolio&lt;/A&gt;&lt;/TD&gt; &lt;TD vAlign=top width=10&gt;&lt;IMG height=10 alt=arrow src="images/spacer.gif" width=10&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/DIV&gt;&lt;!-- End About Sim Dropdown 1 --&gt;&lt;!--Begin About Sim Corporate Dropdown 2 --&gt;&lt;DIV id=about_sim_corporate_drop2&gt;&lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD bgColor=#cacfda&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top align=left width="100%"&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout=startTime(); href="http://www.simworld.com/about_sim/corporate/mission.asp"&gt;Mission&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD bgColor=#ffffff&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top align=left width="100%"&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout=startTime(); href="http://www.simworld.com/about_sim/corporate/philosophy.asp"&gt;Philosophy&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD bgColor=#cacfda&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top align=left width="100%"&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout=startTime(); href="http://www.simworld.com/about_sim/corporate/team.asp"&gt;Team&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD bgColor=#ffffff&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top align=left width="100%"&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout=startTime(); href="http://www.simworld.com/about_sim/corporate/specialty.asp"&gt;Specialty Markets &lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD bgColor=#cacfda&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top align=left width="100%"&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout=startTime(); href="http://www.simworld.com/about_sim/corporate/news.asp"&gt;News &amp;amp; Awards&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/DIV&gt;&lt;!--Begin About Sim Corporate Dropdown 2 --&gt;&lt;!--Begin About Sim Portfolio Dropdown 2 --&gt;&lt;DIV id=about_sim_portfolio_drop2&gt;&lt;/DIV&gt;&lt;!--Begin About Sim Portfolio Dropdown 2 --&gt;&lt;!--Begin Client Access Dropdown 1 --&gt;&lt;DIV id=client_access_drop1&gt;&lt;/DIV&gt;&lt;!-- End Client Access Dropdown 1 --&gt;&lt;!--Begin Client Access Customer Service Dropdown 2 --&gt;&lt;DIV id=client_access_customer_drop2&gt;&lt;/DIV&gt;&lt;!-- End Client Access Customer Service Dropdown 2 --&gt;&lt;!--Begin Join our Team Dropdown 1 --&gt;&lt;DIV id=join_our_team_drop1&gt;&lt;TABLE cellSpacing=0 cellPadding=0 width=150 border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD bgColor=#ffffff&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width=150 border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top width=10&gt;&lt;IMG height=10 alt="" src="images/client_access.htm" width=10&gt;&lt;/TD&gt; &lt;TD vAlign=top align=right width=140&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout=startTime(); href="http://www.simworld.com/join_our_team/job_openings.asp"&gt;Job Openings&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD bgColor=#cacfda&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width=150 border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top width=10&gt;&lt;IMG height=10 alt="" src="images/spacer.gif" width=10&gt;&lt;/TD&gt; &lt;TD vAlign=top align=right width=140&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout=startTime(); href="http://www.simworld.com/join_our_team/apply_online.asp"&gt;Employee Benefits&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD bgColor=#ffffff&gt; &lt;TABLE cellSpacing=2 cellPadding=2 width=150 border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD vAlign=top width=10&gt;&lt;IMG height=10 alt="" src="images/spacer.gif" width=10&gt;&lt;/TD&gt; &lt;TD vAlign=top align=right width=140&gt;&lt;A class=topnav onmouseover=stopTime(); onmouseout=startTime(); href="http://www.simworld.com/join_our_team/corp_culture.asp"&gt;Corporate Culture&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/DIV&gt;&lt;TABLE height="100%" cellSpacing=0 cellPadding=0 width="100%" align=center border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD&gt;&lt;!--Begin Main Web Site Table All Website Design elements below--&gt; &lt;TABLE borderColor=#ffffff cellSpacing=0 cellPadding=0 width=760 align=center border=1&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD&gt; &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD&gt;&lt;!-- Begin Top Logo, Navigation and Message bar Table --&gt; &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt;&lt;!--Beign Global Nav Buttons ---&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD rowSpan=2&gt;&lt;IMG height=53 alt="Screened Images Multimedia" src="images/sim_logo_top.gif" width=136 useMap=#top_logo_map border=0&gt;&lt;MAP name=top_logo_map&gt;&lt;AREA shape=RECT alt="Screened Images Multimedia [Back to Home]" coords=11,4,120,54 href="http://www.simworld.com/index.asp"&gt;&lt;/MAP&gt;&lt;/TD&gt; &lt;TD&gt;&lt;span class="STYLE1"&gt;&amp;#27426;&amp;#36814;&amp;#26469;&amp;#21040; &amp;#33879;&amp;#21517;&amp;#30340;BBS&amp;#21518;&amp;#21488;&lt;/span&gt;&lt;/TD&gt; &lt;/TR&gt; &lt;TR&gt;&lt;!--End Global Nav Buttons ---&gt; &lt;TD&gt;&lt;span class="STYLE1"&gt;&amp;#19981;&amp;#36755;&amp;#20837;&amp;#29992;&amp;#25143;&amp;#21517;&amp;#23494;&amp;#30721;&amp;#19981;&amp;#35768;&amp;#36827; &amp;#29992;&amp;#25143;&amp;#21517;: admin &amp;#23494;&amp;#30721;: admin &lt;/span&gt;&lt;/TD&gt; &lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;!-- End Top Logo, Navigation and Message bar Table --&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD&gt;&lt;!-- Begin Inner Content Table: This portion will be customizable throughout the website --&gt; &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD&gt;&lt;IMG height=324 alt="" src="images/client_login_left_arc.gif" width=137 useMap=#bot_logo_map border=0&gt;&lt;MAP name=bot_logo_map&gt;&lt;AREA shape=RECT alt="Screened Images Multimedia [Back to Home]" coords=11,0,120,24 href="http://www.simworld.com/index.asp"&gt;&lt;/MAP&gt;&lt;/TD&gt; &lt;TD&gt; &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD&gt;&lt;IMG height=91 alt="CLIENT LOG-IN" src="images/client_login_title.gif" width=282&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD&gt; &lt;FORM action=Login.jsp method=post&gt; &lt;input type=hidden name=action value=login&gt; &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" background="images/client_login_text_bg.gif" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD rowSpan=4&gt;&lt;IMG height=158 alt="" src="images/spacer.gif" width=22 border=0&gt;&lt;/TD&gt; &lt;TD colSpan=2&gt; &lt;P class=bodydarkblue&gt;Please enter your username and password here to preview your designs, check project status and/or submit new job requests.&lt;/P&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD&gt; &lt;P class=bodyldarkblue&gt;&lt;LABEL for=uname&gt;用户名:&lt;/LABEL&gt;&lt;/P&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT id=uname name=uname&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD&gt; &lt;P class=bodyldarkblue&gt;&lt;LABEL for=pwd&gt;密码:&lt;/LABEL&gt;&lt;/P&gt;&lt;/TD&gt; &lt;TD&gt;&lt;INPUT id=pwd type=password name=pwd&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD vAlign=top colSpan=2&gt;&lt;A class=bodydarkblue href="http://www.simworld.com/client_access/client_login.asp"&gt;&lt;STRONG&gt;&lt;!--Forget your password?--&gt;&lt;/STRONG&gt;&lt;/A&gt;&lt;IMG height=1 alt="" src="images/spacer.gif" width=132 border=0&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;INPUT type=image alt=Submit src="images/client_login_submit.gif" align=absMiddle value=Submit name=Submit&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD&gt;&lt;IMG height=75 alt="" src="images/client_login_bot_arc.gif" width=282&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt; &lt;TD&gt;&lt;IMG height=324 alt="Log-in Image" src="images/client_login_main_pic.jpg" width=341&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;!-- End Inner Content Table --------&gt;&lt;/TD&gt;&lt;/TR&gt; &lt;TR&gt; &lt;TD&gt;&lt;!-- Begin Bottom Navigation: Contact Us, Request A- Quote --&gt; &lt;TABLE cellSpacing=0 cellPadding=0 width="100%" border=0&gt; &lt;TBODY&gt; &lt;TR&gt; &lt;TD&gt;&lt;A onmouseover="Rollover('nav_homepage_a','nav_homepage');" onmouseout="Rollover('nav_homepage','nav_homepage');" href="http://www.simworld.com/index.asp"&gt;&lt;/A&gt;&lt;IMG height=26 alt="" src="images/interior_bot_nav_bar.gif" width=100%&gt;&lt;/TD&gt; &lt;/TR&gt; &lt;TR&gt; &lt;TD&gt;&lt;IMG height=12 alt="Copyright 2003 Screened Images, Inc." src="images/bot_footer_bar.gif" width=760&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;!-- End Bottom Navigation: Contact Us, Request A- Quote --&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;!--End Main Web Site Table --&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;&lt;!--End Browser Spanning Table --&gt;&lt;/BODY&gt;&lt;/HTML&gt; 修改ShowArticleTree.jsp，使得没有登录的用户不能删除帖子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% String admin = (String)session.getAttribute("admin"); if(admin != null &amp;&amp; admin.equals("true"))&#123; login = true; &#125;%&gt;&lt;%!String str = "";boolean login = false;private void tree(Connection conn, int id, int level)&#123; Statement stmt = null; ResultSet rs = null; String preStr = ""; for (int i = 0; i &lt; level; i++)&#123; preStr += "----"; &#125; try&#123; stmt = conn.createStatement(); String sql = "select * from article where pid = " + id; rs = stmt.executeQuery(sql); String strLogin = ""; while(rs.next())&#123; if(login)&#123; strLogin = "&lt;td&gt;&lt;a href = 'Delete.jsp?id=" + rs.getInt("id") + "&amp;pid=" + rs.getInt("pid") +"'&gt;删除&lt;/a&gt;"; &#125; str += "&lt;tr&gt;&lt;td&gt;" + rs.getInt("id") + "&lt;/td&gt;&lt;td&gt;" + preStr + "&lt;a href='ShowArticleDetail.jsp?id=" + rs.getInt("id") + " '&gt;" + rs.getString("title") + "&lt;/a&gt;&lt;/td&gt;" + strLogin + "&lt;/td&gt;&lt;/tr&gt;"; if(rs.getInt("isleaf") != 0)&#123; tree(conn, rs.getInt("id"), level + 1); &#125; &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; try&#123; if(rs != null)&#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125;&#125;%&gt;&lt;%Class.forName("com.mysql.jdbc.Driver");String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421";Connection conn = DriverManager.getConnection(url);Statement stmt = conn.createStatement();ResultSet rs = stmt.executeQuery("select * from article where pid = 0");String strLogin = "";while(rs.next())&#123; if(login)&#123; strLogin = "&lt;td&gt;&lt;a href = 'Delete.jsp?id=" + rs.getInt("id") + "&amp;pid=" + rs.getInt("pid") +"'&gt;删除&lt;/a&gt;"; &#125; str += "&lt;tr&gt;&lt;td&gt;" + rs.getInt("id") + "&lt;/td&gt;&lt;td&gt;" + "&lt;a href='ShowArticleDetail.jsp?id=" + rs.getInt("id") + " '&gt;" + rs.getString("title") + "&lt;/a&gt;&lt;/td&gt;" + strLogin + "&lt;/td&gt;&lt;/tr&gt;"; if(rs.getInt("isleaf") != 0)&#123; tree(conn, rs.getInt("id"), 1); &#125;&#125;rs.close();stmt.close();conn.close();%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="Post.jsp"&gt;发表新帖&lt;/a&gt;&lt;table border="1"&gt;&lt;%= str %&gt;&lt;% str = ""; login = false;%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 为了防止用户直接在地址框输入Delete.jsp进入删除页面，所以还需要进一步处理，防止直接通过在Delete.jsp传入参数就可以删帖的操作。添加语句：1234567&lt;%String admin = (String)session.getAttribute("admin");if (admin == null || !admin.equals("true"))&#123; out.println("不能删除啊!"); return;&#125;%&gt; 这时再访问我们的Delete.jsp，就不会删除帖子了~ 第十六课. show_article_flat1为了让BBS页面可以平板显示，现在我们去掉ShowArticleTree.jsp的递归写法，来写一个ShowArticleFlat.jsp的文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from article where pid = 0");%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="Post.jsp"&gt;发表新帖&lt;/a&gt;&lt;table border="1"&gt;&lt;% while(rs.next())&#123;%&gt; &lt;tr&gt; &lt;td&gt; &lt;%=rs.getString("cont")%&gt; &lt;/td&gt; &lt;/tr&gt;&lt;% &#125; rs.close(); stmt.close(); conn.close();%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 然后让我们的Post.jsp的重定向定向到ShowArticleFlat.jsp文件上：response.sendRedirect(&quot;ShowArticleFlat.jsp&quot;); 这时再访问ShowArticleFlat.jsp页面并不断发送新帖，发现页面长度会越来越长，这时我们就想为这个平面显示加上分页，使得一页只能显示三条。 第十七课. show_article_flat_2重新修改ShowArticleFlat.jsp，使得帖子按发表顺序先后倒序排列，即最近发的排在最前；并且一页只能显示三条帖子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% int pageSize = 3; String strPageNo = request.getParameter("pageNo"); int pageNo = 1; if(strPageNo == null || strPageNo.equals(""))&#123; pageNo = 1; &#125;else&#123; pageNo = Integer.parseInt(strPageNo.trim()); &#125; int startPos = (pageNo - 1) * pageSize; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from article where pid = 0 order by pdate desc limit " + startPos + " ," + pageSize);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="Post.jsp"&gt;发表新帖&lt;/a&gt;&lt;table border="1"&gt;&lt;% while(rs.next())&#123;%&gt; &lt;tr&gt; &lt;td&gt; &lt;%=rs.getString("title")%&gt; &lt;/td&gt; &lt;/tr&gt;&lt;% &#125; rs.close(); stmt.close(); conn.close();%&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 进行访问： 很nice是不是~ 第十八课. show_article_flat_3我们现在虽然可以显示页数，但是没有分页，没有上一页下一页按钮，于是我们修改ShowArticleFlat.jsp如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% int pageSize = 3; String strPageNo = request.getParameter("pageNo"); int pageNo = 1; if(strPageNo == null || strPageNo.equals(""))&#123; pageNo = 1; &#125;else&#123; try &#123; pageNo = Integer.parseInt(strPageNo.trim()); &#125;catch (NumberFormatException e)&#123; pageNo = 1; &#125; if(pageNo &lt;= 0) pageNo=1; &#125; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); Statement stmtCount = conn.createStatement(); ResultSet rsCount = stmtCount.executeQuery("SELECT count(*) from article WHERE pid = 0"); rsCount.next(); int totalRecords = rsCount.getInt(1); int totalPages = totalRecords % pageSize == 0 ? totalRecords/pageSize : totalRecords/pageSize +1; if(pageNo &gt; totalPages) pageNo = totalPages; int startPos = (pageNo - 1) * pageSize; Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from article where pid = 0 order by pdate desc limit " + startPos + " ," + pageSize);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="Post.jsp"&gt;发表新帖&lt;/a&gt;&lt;table border="1"&gt;&lt;% while(rs.next())&#123;%&gt; &lt;tr&gt; &lt;td&gt; &lt;%=rs.getString("title")%&gt; &lt;/td&gt; &lt;/tr&gt;&lt;% &#125; rs.close(); stmt.close(); conn.close();%&gt;&lt;/table&gt;共&lt;%=totalPages%&gt;页 第&lt;%=pageNo%&gt;页&lt;a href="ShowArticleFlat.jsp?pageNo=&lt;%=pageNo-1%&gt;"&gt; &lt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/a&gt;&lt;a href="ShowArticleFlat.jsp?pageNo=&lt;%=pageNo+1%&gt;"&gt; &gt; &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 再访问这个jsp，就会看到可以跳转上一页下一页了~是不是很bingo~ 第十九课. show_article_flat_4我们已经有了跳转，但是还想更完美一些，想搞一个下拉条： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% int pageSize = 3; String strPageNo = request.getParameter("pageNo"); int pageNo = 1; if(strPageNo == null || strPageNo.equals(""))&#123; pageNo = 1; &#125;else&#123; try &#123; pageNo = Integer.parseInt(strPageNo.trim()); &#125;catch (NumberFormatException e)&#123; pageNo = 1; &#125; if(pageNo &lt;= 0) pageNo=1; &#125; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); Statement stmtCount = conn.createStatement(); ResultSet rsCount = stmtCount.executeQuery("SELECT count(*) from article WHERE pid = 0"); rsCount.next(); int totalRecords = rsCount.getInt(1); int totalPages = totalRecords % pageSize == 0 ? totalRecords/pageSize : totalRecords/pageSize +1; if(pageNo &gt; totalPages) pageNo = totalPages; int startPos = (pageNo - 1) * pageSize; Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from article where pid = 0 order by pdate desc limit " + startPos + " ," + pageSize);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="Post.jsp"&gt;发表新帖&lt;/a&gt;&lt;table border="1"&gt;&lt;% while(rs.next())&#123;%&gt; &lt;tr&gt; &lt;td&gt; &lt;%=rs.getString("title")%&gt; &lt;/td&gt; &lt;/tr&gt;&lt;% &#125; rs.close(); stmt.close(); conn.close();%&gt;&lt;/table&gt;共&lt;%=totalPages%&gt;页 第&lt;%=pageNo%&gt;页&lt;a href="ShowArticleFlat.jsp?pageNo=&lt;%=pageNo-1%&gt;"&gt; &lt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/a&gt;&lt;a href="ShowArticleFlat.jsp?pageNo=&lt;%=pageNo+1%&gt;"&gt; &gt; &lt;/a&gt;&lt;form name="form1"&gt; &lt;select name = "pageNo"&gt; &lt;% for(int i = 1; i &lt;= totalPages; i++)&#123; %&gt; &lt;option value=&lt;%=i%&gt;&gt; 第&lt;%=i%&gt;页 &lt;% &#125; %&gt; &lt;/select&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 访问页面： 虽然有了下拉框，但是还不能跳转。 第二十课. show_article_flat_5我们现在就把下拉框的跳转加上，并且加上一个可以自己手动输入页面进行跳转的输入框： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@ page import="java.sql.*" %&gt;&lt;% int pageSize = 3; String strPageNo = request.getParameter("pageNo"); int pageNo = 1; if(strPageNo == null || strPageNo.equals(""))&#123; pageNo = 1; &#125;else&#123; try &#123; pageNo = Integer.parseInt(strPageNo.trim()); &#125;catch (NumberFormatException e)&#123; pageNo = 1; &#125; if(pageNo &lt;= 0) pageNo=1; &#125; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421"; Connection conn = DriverManager.getConnection(url); Statement stmtCount = conn.createStatement(); ResultSet rsCount = stmtCount.executeQuery("SELECT count(*) from article WHERE pid = 0"); rsCount.next(); int totalRecords = rsCount.getInt(1); int totalPages = totalRecords % pageSize == 0 ? totalRecords/pageSize : totalRecords/pageSize +1; if(pageNo &gt; totalPages) pageNo = totalPages; int startPos = (pageNo - 1) * pageSize; Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from article where pid = 0 order by pdate desc limit " + startPos + " ," + pageSize);%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="Post.jsp"&gt;发表新帖&lt;/a&gt;&lt;table border="1"&gt;&lt;% while(rs.next())&#123;%&gt; &lt;tr&gt; &lt;td&gt; &lt;%=rs.getString("title")%&gt; &lt;/td&gt; &lt;/tr&gt;&lt;% &#125; rs.close(); stmt.close(); conn.close();%&gt;&lt;/table&gt;共&lt;%=totalPages%&gt;页 第&lt;%=pageNo%&gt;页&lt;a href="ShowArticleFlat.jsp?pageNo=&lt;%=pageNo-1%&gt;"&gt; &lt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &lt;/a&gt;&lt;a href="ShowArticleFlat.jsp?pageNo=&lt;%=pageNo+1%&gt;"&gt; &gt; &lt;/a&gt;&lt;form name="form1"&gt; &lt;select name = "pageNo" onchange="document.form1.submit()"&gt; &lt;% for(int i = 1; i &lt;= totalPages; i++)&#123; %&gt; &lt;option value=&lt;%=i%&gt; &lt;%=(pageNo == i) ? "selected" : ""%&gt; &gt; 第&lt;%=i%&gt;页 &lt;% &#125; %&gt; &lt;/select&gt;&lt;/form&gt;&lt;form name="form2" action = "ShowArticleFlat.jsp"&gt; &lt;input type="text" size="4" name="pageNo" value=&lt;%=pageNo%&gt;&gt; &lt;input type="submit" value="go"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 第二十一课. 总结为了防止回复空内容，所以加入下面js代码，用来检查空字符串： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script language="javascript"&gt; &lt;!-- //javascript去空格函数 function LTrim(str)&#123; //去掉字符串 的头空格 var i; for(i=0;i&lt;str.length; i++) &#123; if(str.charAt(i)!=" ") break; &#125; str = str.substring(i,str.length); return str; &#125; function RTrim(str)&#123; var i; for(i=str.length-1;i&gt;=0;i--)&#123; if(str.charAt(i)!=" "&amp;&amp;str.charAt(i)!=" ") break; &#125; str = str.substring(0,i+1); return str; &#125; function Trim(str)&#123; return LTrim(RTrim(str)); &#125; function check() &#123; if(Trim(document.reply.title.value) == "") &#123; alert("please intput the title!"); document.reply.title.focus(); return false; &#125; if(Trim(document.reply.cont.value) == "") &#123; alert("plsease input the content!"); document.reply.cont.focus(); return false; &#125; return true; &#125; --&gt;&lt;/script&gt; 在form中加入onsubmit动作，执行上面的js代码：&lt;form name=reply action=&quot;ReplyOK.jsp&quot; method=&quot;post&quot; onsubmit=&quot;return check()&quot;&gt; 修改ReplyOK.jsp，使得java也能检查空回复内容：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;%-- Created by IntelliJ IDEA. User: korson Date: 2017/11/24 Time: 16:15 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=gbk" language="java" %&gt;&lt;%@page import="java.sql.*" %&gt;&lt;%request.setCharacterEncoding("gbk");int id = Integer.parseInt(request.getParameter("id"));int rootId = Integer.parseInt(request.getParameter("rootid"));String title = request.getParameter("title");if (title == null)&#123; out.println("error! please use my bbs in the right way!"); return;&#125;title = title.trim();if(title.equals(""))&#123; out.println("title could not be empty!"); return;&#125;String cont = request.getParameter("cont");cont = cont.trim();if(cont.equals(""))&#123; out.println("content could not be empty!"); return;&#125;cont = cont.replaceAll("\n", "&lt;br&gt;");Class.forName("com.mysql.jdbc.Driver");String url = "jdbc:mysql://127.0.0.1/bbs?user=root&amp;password=09129421";Connection conn = DriverManager.getConnection(url);String sql = "insert into article values (null, ?, ?, ?, ?, now(), 0)";PreparedStatement pstmt = conn.prepareStatement(sql);Statement stmt = conn.createStatement();conn.setAutoCommit(false);pstmt.setInt(1, id);pstmt.setInt(2, rootId);pstmt.setString(3, title);pstmt.setString(4, cont);pstmt.executeUpdate();stmt.executeUpdate("update article set isleaf = 1 where id = " + id);conn.commit();conn.setAutoCommit(true);stmt.close();pstmt.close();conn.close();response.sendRedirect("ShowArticleTree.jsp");%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;font color="red" size="7"&gt; OK!&lt;/font&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>JSP</tag>
        <tag>J2EE</tag>
        <tag>BBS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 454.4Sum II]]></title>
    <url>%2F2017%2F11%2F24%2Fleetcode454%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/4sum-ii/description/ 这道题是之前那道4Sum的延伸，让我们在四个数组中各取一个数字，使其和为0。那么坠傻的方法就是遍历所有的情况，时间复杂度为O(n4)。但是我们想想既然Two Sum那道都能将时间复杂度缩小一倍，那么这道题我们使用哈希表是否也能将时间复杂度降到O(n2)呢？答案是肯定的，我们如果把A和B的两两之和都求出来，在哈希表中建立两数之和跟其出现次数之间的映射，那么我们再遍历C和D中任意两个数之和，我们只要看哈希表存不存在这两数之和的相反数就行了，参见代码如下： 1234567891011121314151617181920212223242526class Solution &#123; public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; int count = 0; HashMap&lt;Integer, Integer&gt; hm = new HashMap(); for(int i = 0; i &lt; A.length; i++) for(int j = 0; j &lt; B.length; j++) &#123; int sum = A[i] + B[j]; if(!hm.containsKey(sum)) hm.put(sum, 1); else hm.put(sum,hm.get(sum) + 1); &#125; for(int i = 0; i &lt; C.length; i++) for(int j = 0; j &lt; D.length; j++) &#123; if(hm.containsKey(-C[i]-D[j])) count += hm.get(-C[i]-D[j]); &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 347.Top K Frequent Elements]]></title>
    <url>%2F2017%2F11%2F23%2Fleetcode347%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/top-k-frequent-elements/description/ 题目介绍：就是给你一个数组，让你求出现频率最高的k个数字。 思路：1.先对数组遍历一遍，用hashset存下每个数字的出现次数。2.假设数组大小是n那么创建一个n+1大小的List[]数组，遍历hashset,将遍历到的元素存放到对应频率下标的数组中。3.按照从后向前的遍历顺序，对List[]数组进行遍历，取出k个数字即可。AC代码：12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123; HashMap&lt;Integer,Integer&gt; hm = new HashMap&lt;Integer, Integer&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); for(int x : nums) hm.put(x, (hm.getOrDefault(x , 0) + 1)); List&lt;Integer&gt;[] bucket = new List[nums.length + 1]; Set&lt;Integer&gt; KeySet = hm.keySet(); Iterator it = KeySet.iterator(); while(it.hasNext())&#123; int key = (int)it.next(); int freq = hm.get(key); if(bucket[freq] == null) bucket[freq] = new ArrayList&lt;Integer&gt;(); bucket[freq].add(key); &#125; for(int i = nums.length; i &gt;= 0; i--)&#123; if(bucket[i] == null) continue; if(bucket[i].size() != 0)&#123; it = bucket[i].iterator(); while(it.hasNext())&#123; res.add((int)it.next()); k--; if(k == 0) return res; &#125; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 655.打印二叉树]]></title>
    <url>%2F2017%2F11%2F23%2Fleetcode655%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/print-binary-tree/description/ 思路：假设二叉树的高度是h,那么二叉树的打印宽度就是2^h-1,每次打印只需要计算好位移，打印到当前区间的中点就可以了。具体实现就是：1.先用DFS算出二叉树的高度h2.利用层次遍历将一层的节点存到队列中，如果是null就存null，假设被存储的是第i层，那么一层节点的数量是2^(i-1)个节点3.取出节点对其进行打印,dif = 2^(h-i)-1,第一个节点打印位置是dif，之后的节点都在上一个节点位置上进行位移：pos = pos + 2 * dif + 2; AC代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;String&gt;&gt; printTree(TreeNode root) &#123; int height = DFS(root); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;(); //存放每一层节点的队列 LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if(root == null) return res; queue.add(root); int max_wid = (int)(Math.pow(2, height) - 1); //每一层进行处理 for(int i = 1; i &lt;= height; i++)&#123; //计算这一层有多少节点 int count = (int)Math.pow(2, i-1); int dif = (int)(Math.pow(2, height-i) - 1); int pos = 0; ArrayList&lt;String&gt; cur = new ArrayList&lt;String&gt;(); for(int j = 0; j &lt; max_wid; j++) cur.add(""); TreeNode tmp = queue.poll(); count--; pos += dif; if(tmp == null) &#123; queue.add(null); queue.add(null); &#125; else &#123; cur.set(pos, tmp.val + ""); queue.add(tmp.left); queue.add(tmp.right); &#125; while(count != 0)&#123; tmp = queue.remove(); pos = pos + 2 * dif + 2; if(tmp == null) &#123; queue.add(null); queue.add(null); &#125; else &#123; cur.set(pos, (tmp.val + "")); queue.add(tmp.left); queue.add(tmp.right); &#125; count --; &#125; res.add(cur); &#125; return res; &#125; public int DFS(TreeNode root)&#123; if(root == null) return 0; int left = DFS(root.left); int right = DFS(root.right); if(left &gt; right) return left + 1; return right + 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 477.Total Hamming Distance]]></title>
    <url>%2F2017%2F11%2F23%2Fleetcode477%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/total-hamming-distance/description/ 思路：题目的意思就是给了一个数组，现在求总的海明距离，其中： 海明距离：任意两个数在二级制的表示下（int = 32bit），每个bit对应的值是1或0，那么这两个数在这32个位置下，取值不一样的地方的总和就是海明距离 总的距离：该数组中，所有两两组合得到的元素的海明距离的和 看到这里，其实就可以猜到，应该不能暴力解决了 而方法也找到了一个很简单的： int长度是32bit，一共n个数 在每个位置上，如果有k个数为1，那么就有n-k个为0 那么贡献的海明距离就贡献了 k*(n-k) 代码：1234567891011121314151617181920class Solution &#123; public int totalHammingDistance(int[] nums) &#123; int length = nums.length; if(length == 0) return 0; int res = 0; int cnt; for(int i = 0; i &lt; 32; i++)&#123; cnt = 0; for(int j = 0; j &lt; length; j++) &#123; if(nums[j] % 2 == 1) cnt++; nums[j] = nums[j]/2; &#125; res += cnt * (length - cnt); &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC常用的连接Oracle的程序]]></title>
    <url>%2F2017%2F11%2F22%2FJDBC%2F</url>
    <content type="text"><![CDATA[本文主要介绍JDBC的使用方法，几个比较经典的连接Oracle数据库的例子。 第五课. JDBC初步_1内容概要： Java Database Connectivity JDBC简介 SQL语言回顾 JDBC基础编程 JDBC高级编程 DataSource and RowSet 最早的数据库编程： 缺点：不能跨数据库平台。 解决方法： 将数据库系统分层，这样就可以实现跨数据库平台了我们的JDBC： SQL语言回顾：Select Select * from T where …… Insert Insert into T values(……) Create Create table T(……) Delete Delete from T where …… Update Update T set t1=… and t2=… where t3=… Drop Drop table T JDBC编程步骤（完全固定的） Load thd Driver(1) Class.forName()|Class.forName().newInstance()|new DriverName()(2) 实例化时自动向DriverManager注册，不需要显示调用DriverManager.registerDriver方法 Connect to the DataBase DriverManager.getConnection() Execute the SQL(1) Connection.CreateStatement()(2) Statement.executeQuery()(3) Statement.excuteUpdate() Retrive the result data(1) 循环取得结果 while(rs.next()) Show the result data(1)将数据库中的各种类型转换为Java中的类型(getXXX)方法 Close(1) close the resultset / close the statement / close the connection 来看一个例子：首先我们在idea下创建一个JDBC工程，存放将来所有的关于JDBC的程序。再创建一个TestJDBC的module，在里面创建一个TestJDBC的class。之后我们要连接oracle，所以在oracle的安装目录下找到JDBC的驱动:D:\app\korson\product\11.2.0\dbhome_1\oui\jlib在这个目录下找到classes12.jar，这么就是我们要找的JDBC驱动 在我们的module配置里加入这个jar包： 最好的方式是将classes12.jar放在自己工程下面，不要放在系统class path下面，防止和其他项目合并时产生jar包冲突。 我们在写代码之前，需要知道我们数据库的ip地址，端口号，用户名，密码。我们这里的ip地址是127.0.0.1，端口号是1521。因为在netstat -ano下显示的127.0.0.1:1521被监听，而一般127.0.0.1是只有本地地址可以访问，0.0.0.0是外网可以访问的。 我们的代码是：12345678910111213import java.sql.*;public class TestJDBC &#123; public static void main(String[] args) throws Exception &#123; //第一种向DriverManager注册的方式 Class.forName("oracle.jdbc.driver.OracleDriver"); //第二种向DriverManager注册的方式 //new oracle.jdbc.driver.OracleDriver(); Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger"); &#125;&#125; 这样就连接上了名为orcl的数据库了。 第六课. JDBC初步_2继续完善上面的代码，写出一个完整的数据库操作程序：12345678910111213141516171819202122232425262728293031import java.sql.*;public class TestJDBC &#123; public static void main(String[] args) throws Exception &#123; //第一种向DriverManager注册的方式 Class.forName("oracle.jdbc.driver.OracleDriver"); //第二种向DriverManager注册的方式 //new oracle.jdbc.driver.OracleDriver(); //连接数据库 Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger"); //创建一条Statement Statement stmt = conn.createStatement(); //执行查询，结果集就像一个游标,指在结果集的最顶端 ResultSet rs = stmt.executeQuery("select * from dept"); while(rs.next())&#123; //把结果的"deptno"值当字符串拿出来 System.out.println(rs.getString("deptno")); //把结果的"deptno"值当int拿出来 System.out.println(rs.getInt("deptno")); &#125; //后打开的先关闭 rs.close(); stmt.close(); conn.close(); &#125;&#125; 该程序的执行结果是从数据库的dept表中取出deptno字段进行打印，最后将各种管道关闭，后打开的先关闭。 第七课. JDBC初步_3上面的代码有很多问题，比如数据库操作出现异常时不能正常关闭，比如rs、stmt、conn为空时会关闭等，所以加入健全的异常处理机制： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.sql.*;public class TestJDBC &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try &#123; //第一种向DriverManager注册的方式 Class.forName("oracle.jdbc.driver.OracleDriver"); //第二种向DriverManager注册的方式 //new oracle.jdbc.driver.OracleDriver(); //连接数据库 conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger"); //创建一条Statement stmt = conn.createStatement(); //执行查询，结果集就像一个游标,指在结果集的最顶端 rs = stmt.executeQuery("select * from dept"); while(rs.next())&#123; //把结果的"deptno"值当字符串拿出来 System.out.println(rs.getString("deptno")); //把结果的"deptno"值当int拿出来 System.out.println(rs.getInt("deptno")); &#125; &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; //后打开的先关闭 if(rs != null) &#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; if(conn != null)&#123; conn.close(); conn = null; &#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 第八课. JDBC处理DML语句_1先创建一个dept2表：123456create table dept2( DEPTNO NUMBER(2), DNAME VARCHAR2(14), LOC VARCHAR2(13)); 再用java代码对表进行插入数据操作：123456789101112131415161718192021222324252627282930import java.sql.*;public class TestDML &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Connection conn = null; Statement stmt = null; try &#123; Class.forName("oracle.jdbc.driver.OracleDriver"); conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger"); stmt = conn.createStatement(); //将一条数据插入数据库中的dept2表 String sql = "insert into dept2 values (98, 'GAME', 'BJ')"; stmt.executeUpdate(sql); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (stmt != null)&#123; stmt.close(); stmt = null;&#125; if (conn != null)&#123; conn.close(); conn = null;&#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 我们在sql&#42;plus下验证数据是否插入： 可以看到数据被成功插入了。 上面的操作比较繁琐，我们想，我们的IDE能不能集成一个看数据库内容的插件呢？答案是肯定的。在我们的idea的View按钮上，就有可以查看数据库的一项： 找到我们的oracle项： 然后对我们要查看的数据库稍加配置： 对Driver进行添加： 之后就可以查看我们的数据库并进行SQL操作了~ 第九课. JDBC处理DML语句_2通过在主函数中输入三个参数，完成一条插入语句： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.sql.*;/** * 输入三个参数，进行数据库一条语句的插入 */public class TestDML2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //必须是三个参数，如果不是，就退出 if(args.length != 3)&#123; System.out.println("Parameter Error! Please Input Again!"); System.exit(-1); &#125; int deptno = 0; try &#123; deptno = Integer.parseInt(args[0]); &#125;catch (NumberFormatException e)&#123; System.out.println("Parameter Error!Deptno should be Number Format!"); System.exit(-1); &#125; String dname = args[1]; String loc = args[2]; Connection conn = null; Statement stmt = null; try &#123; Class.forName("oracle.jdbc.driver.OracleDriver"); conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger"); stmt = conn.createStatement(); //将一条数据插入数据库中的dept2表 String sql = "insert into dept2 values (" + deptno + ",'" + dname + "','" + loc + "')"; System.out.println(sql); stmt.executeUpdate(sql); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (stmt != null)&#123; stmt.close(); stmt = null;&#125; if (conn != null)&#123; conn.close(); conn = null;&#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 一定要注意插入语句的写法：String sql = &quot;insert into dept2 values (&quot; + deptno + &quot;,&#39;&quot; + dname + &quot;&#39;,&#39;&quot; + loc + &quot;&#39;)&quot;;其中由于dname和loc都是字符串，需要加单引号。 第十课. JDBC处理PreparedStatement上面的操作过于繁琐，因为我们写一条sql语句时，还需要考虑是不是字符串，要不要加单引号。 引入一个接口：PreparedStatement其实它的基类就是Statement。它的灵活性更强一些，可以灵活指定SQL语句中的变量。 对上一节的代码进行改进：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.sql.*;/** * 输入三个参数，进行数据库一条语句的插入 */public class TestDML2 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //必须是三个参数，如果不是，就退出 if(args.length != 3)&#123; System.out.println("Parameter Error! Please Input Again!"); System.exit(-1); &#125; int deptno = 0; try &#123; deptno = Integer.parseInt(args[0]); &#125;catch (NumberFormatException e)&#123; System.out.println("Parameter Error!Deptno should be Number Format!"); System.exit(-1); &#125; String dname = args[1]; String loc = args[2]; Connection conn = null; Statement stmt = null; try &#123; Class.forName("oracle.jdbc.driver.OracleDriver"); conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger"); stmt = conn.createStatement(); //将一条数据插入数据库中的dept2表 String sql = "insert into dept2 values (" + deptno + ",'" + dname + "','" + loc + "')"; System.out.println(sql); stmt.executeUpdate(sql); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (stmt != null)&#123; stmt.close(); stmt = null;&#125; if (conn != null)&#123; conn.close(); conn = null;&#125; &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 第十一课. JDBC处理存储过程创建一个PLSQL过程：12345678910111213SQL&gt; create or replace procedure p (v_a in number, v_b number, v_ret out number, v_temp in out number) is begin if (v_a &gt; v_b) then v_ret := v_a; else v_ret := v_b; end if; v_temp := v_temp + 1; end; / 对于Java怎么调用一个存储过程，下面这个代码掌握就足够了！ 12345678910111213141516171819202122232425import java.sql.*;public class TestProc &#123; public static void main(String[] args) throws Exception &#123; Class.forName("oracle.jdbc.driver.OracleDriver"); Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger");//调用存储过程 CallableStatement cstmt = conn.prepareCall("&#123;call p(?, ?, ?, ?)&#125;"); //告诉程序，第三第四个占位符是输出参数 cstmt.registerOutParameter(3, Types.INTEGER); cstmt.registerOutParameter(4, Types.INTEGER); //第一个参数是3，第二个参数是4，第三个参数是5 cstmt.setInt(1, 3); cstmt.setInt(2, 4); cstmt.setInt(4, 5); //执行 cstmt.execute(); //把第三个和第四个参数经过运算的值拿出来 System.out.println(cstmt.getInt(3)); System.out.println(cstmt.getInt(4)); cstmt.close(); conn.close(); &#125;&#125; 第十二课. JDBC进行批处理.有两种方法可以进行批处理：第一种是利用Statement的addBatch方法。代码如下：123456789101112131415161718import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class TestBatch &#123; public static void main(String[] args) throws Exception &#123; Class.forName("oracle.jdbc.driver.OracleDriver"); Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger"); Statement stmt = conn.createStatement(); stmt.addBatch("insert into dept2 values (51, '500', 'haha')"); stmt.addBatch("insert into dept2 values (52, '500', 'haha')"); stmt.addBatch("insert into dept2 values (53, '500', 'haha')"); stmt.executeBatch(); stmt.close(); &#125;&#125; 第二种是利用PreparedStatement的addBatch()方法进行批处理：12345678910111213141516171819202122232425262728293031323334353637383940import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.Statement;public class TestBatch &#123; public static void main(String[] args) throws Exception &#123; Class.forName("oracle.jdbc.driver.OracleDriver"); Connection conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger");/* Statement stmt = conn.createStatement(); stmt.addBatch("insert into dept2 values (51, '500', 'haha')"); stmt.addBatch("insert into dept2 values (52, '500', 'haha')"); stmt.addBatch("insert into dept2 values (53, '500', 'haha')"); stmt.executeBatch(); stmt.close();*/ PreparedStatement ps = conn.prepareStatement("insert into dept2 values (?, ?, ?)"); ps.setInt(1, 61); ps.setString(2, "haha"); ps.setString(3, "bj"); ps.addBatch(); ps.setInt(1, 62); ps.setString(2, "haha"); ps.setString(3, "bj"); ps.addBatch(); ps.setInt(1, 63); ps.setString(2, "haha"); ps.setString(3, "bj"); ps.addBatch(); ps.executeBatch(); ps.close(); conn.close(); &#125;&#125; 结果是： 这样就把一批操作一块执行了。 第十三课. JDBC处理Transaction1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class TestTransaction &#123; public static void main(String[] args) &#123; Connection conn = null; Statement stmt = null; try&#123; Class.forName("oracle.jdbc.driver.OracleDriver"); conn = DriverManager.getConnection("jdbc:oracle:thin:@127.0.0.1:1521:orcl", "scott", "tiger"); conn.setAutoCommit(false); stmt = conn.createStatement(); stmt.addBatch("insert into dept2 values (51, '500', 'haha')"); stmt.addBatch("insert into dept2 values (52, '500', 'haha')"); stmt.addBatch("insert into dept2 values (53, '500', 'haha')"); stmt.executeBatch(); conn.commit(); conn.setAutoCommit(true); &#125;catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch (SQLException e)&#123; e.printStackTrace(); try&#123; if(conn != null)&#123; conn.rollback(); conn.setAutoCommit(true); &#125; &#125;catch (SQLException e1)&#123; e1.printStackTrace(); &#125; &#125;finally &#123; try&#123; if(stmt != null) stmt.close(); if(conn != null) conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面代码中，先设置 conn.setAutoCommit(false);防止sql语句被提交，然后执行12conn.commit();conn.setAutoCommit(true); 使得sql语句可以被一起提交，达到事务的要求 第十四课. JDBC处理可滚动的结果集代码：12345678910111213141516171819202122232425262728293031323334353637383940import java.sql.*;public class TestScroll &#123; public static void main(String[] args) &#123; try&#123; new oracle.jdbc.driver.OracleDriver(); String url = "jdbc:oracle:thin:@127.0.0.1:1521:orcl"; Connection conn = DriverManager.getConnection(url, "scott", "tiger"); //TYPE_SCROLL_INSENSITIVE代表对滚动不敏感，可以在任意位置滚来滚去 //CONCUR_READ_ONLY代表在并发访问结果集时只能只读访问，不能更新 Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); ResultSet rs = stmt.executeQuery("SELECT * FROM emp order by sal"); //指到第一个结果 rs.next(); //也就是取出empno字段的值 System.out.println(rs.getInt(1)); rs.last(); System.out.println(rs.getString(1)); //打印是不是最后一条 System.out.println(rs.isLast()); //是不是最后一条的下一条 System.out.println(rs.isAfterLast()); //计算有多少条记录 System.out.println(rs.getRow()); //往前一条，就是倒数第二条 rs.previous(); System.out.println(rs.getString(1)); //绝对的定位，定位到第六条 rs.absolute(6); System.out.println(rs.getString(1)); rs.close(); stmt.close(); conn.close(); &#125;catch (SQLException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 结果： 第十五课. JDBC处理可更新的结果集代码：123456789101112131415161718192021222324252627282930313233343536373839404142import java.sql.*;public class TestUpdateRs &#123; public static void main(String[] args) &#123; try&#123; new oracle.jdbc.driver.OracleDriver(); String url = "jdbc:oracle:thin:@127.0.0.1:1521:orcl"; Connection conn = DriverManager.getConnection(url , "scott" , "tiger"); //CONCUR_UPDATABLE表明结果集是可以更新的 Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE); ResultSet rs = stmt.executeQuery("select * from emp"); rs.next(); //更新一行数据 rs.updateString("ename","AAAA"); rs.updateRow(); //插入新行 rs.moveToInsertRow(); rs.updateInt(1, 9999); rs.updateString("ename","AAAA"); rs.updateInt("mgr", 7839); rs.updateDouble("sal", 99.99); rs.insertRow(); //将光标移动到新建的行 rs.moveToCurrentRow(); //删除行 rs.absolute(5); rs.deleteRow(); //取消更新 //rs.cancleRowUpdates(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行报错： 原因：虽然Sun设计了updateString，但是Oracle不支持 第十六课. DataSource_RowSet介绍和总结DataSource &amp; RowSetDataSource DriverManager的替代 连接池实现 分布式实现 DataSource的属性可以动态改变 RowSet 新的ResultSet 从ResultSet继承 支持断开的结果集 支持JavaBean标准 学习方法 如何掌握JDBC 记住常用各种类型程序段: TestJDBC.java, TestDML.java，TestPrepStmt, TestTransaction 将程序处理完善（1） JDBC初步（2） DML（3） Transaction（4） DataSource &amp; RowSet]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（十三） 字符串]]></title>
    <url>%2F2017%2F11%2F19%2FThinkingInJava13%2F</url>
    <content type="text"><![CDATA[可以证明，字符串操作是计算机程序设计中最常见的行为。 13.1 不可变StringString对象是不可变的。查看JDK文档你就会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，以包含修改后的字符串内容。而最初的String对象则丝毫未动。内部有final char[] values，没有方法修改其内容 13.2 重载“+”与StringBuilder不可变性会带来一定的效率问题。为String对象重载的“+”操作符就是一个例子（“+”和“+=”是Java中仅有的两个重载过的操作符，而Java并不允许程序员重载任何操作符）。通过反编译代码(javap -c [类名])，我们可以发现它真正的工作情况：编译器自动引入了java.lang.StringBuilder类。虽然我们在源代码中并没有使用StringBuilder类，但是编译器却自作主张地使用了它，因为它更高效。调用StringBuilder的append()方法实现字符串的加操作，最后调用toString()生成结果。 现在，也许你会觉得可以随意使用String对象，反正编译器会为你自动优化性能。可是在这之前，让我们更深入地看看编译器能为我们优化到什么程度。通过循环分别通过追加创建一个字符串，反编译源码，我们可以看到：利用String创建时，编译器通过StringBuilder优化了字符串的创建，但是由于循环的存在，导致每次循环编译器都会创建一个StringBuilder对象；相比之下，利用StringBuilder创建字符串则只创建了一个StringBuilder对象，反编译的汇编指令也比前一个简洁的多。因此，当你为一个类编写toString()方法时，若字符串操作比较简单，那就可以信赖编译器，它会为你合理地构造最终的字符串结果。但是，如果你要在toString方法中使用循环，那么最好自己创建一个StringBuilder对象，用它来构造最终结果。如果拿不准该用哪种方式，随时可以用javap来分析你的程序。 StringBuilder是在Java SE5引入的，在这之前Java用的是StringBuffer。后者是线程安全的，因此开销会大些，所以在Java SE5/6中，字符串操作应该还会更快一些。 12345678910public class Main&#123; public static void main(String[] args) &#123; String str = "a" + "b" + "c";// 1 String a = "a"; String b = "b"; String c = "c"; String abc = a + b + c; //2 String abc1 = new String("a") + new String("b") + new String("c"); //3 &#125;&#125; 对于1，编译器将做优化，str直接指向常量”abc”，而2、3则会使用StringBuilder的append方法优化。 13.3 无意识的递归Java中的每个类从根本上都是继承自Object，标准容器类自然也不例外。因此容器类都有toString()方法，并且重写了该方法，使得它生成的String结果能够表达容器自身，以及容器所包含的对象。如果你希望toString()方法打印出对象的内存地址，也许你会考虑使用关键字this。但是，你会得到一串非常长的异常。这是因为编译器会将this转换成String，怎么转换呢，调用的就是toString()方法，发生了递归调用。因此，如果你真的想要打印出对象的内存地址，应该调用Object.toString()方法，而不是返回this。 13.4 String上的操作String类有很多方法，在此不一一列举。可以参考文章：http://www.runoob.com/java/java-string.html在此，我们要注意一点，当需要改变字符串的内容时，String类的方法都会返回一个新的String对象。同时，如果内容没有发生改变，String的方法只是返回指向原对象的引用而已。 13.5 格式化输出13.5.2 System.out.format();Java SE5引入的format方法可用于PrintSteam或PrintWriter对象，其中包括System.out对象。format()方法模仿自C的printf()。如果你比较怀旧的话，也可以使用printf()； 13.5.3 Formatter类当你创建一个formatter对象的时候，需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出。 13.5.4 格式化说明符在插入数据时，如果想要控制空格与对齐，你需要更精细复杂的更是修饰符。以下是其抽象的语法： %[argument_index$][flags][width][.precision]conversion 可选的 argument_index 是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 “1$” 引用，第二个参数由 “2$” 引用，依此类推。 可选 flags 是修改输出格式的字符集。有效标志集取决于转换类型。在默认的情况下，数据是右对齐的，不过可以通过使用“-”编制来改变对齐方向。 可选 width 是一个非负十进制整数，表明要向输出中写入的最少字符数。必要时添加空格以达到指定长度。 可选 precision 是一个非负十进制整数，通常用来限制字符数。特定行为取决于转换类型。与width相对应用来指定最大尺寸。precision的意义也不同。在将precision应用于String时，它表示打印String时输出字符串的最大数量。而在将precision应用于浮点数时，它表示小数部分要显示出来的位数（默认是6位小数），如果小数位过多则舍入，太少则在尾补零。由于整数没有小数部分，所以precision无法应用于整数。 所需 conversion 是一个表明应该如何格式化参数的字符。给定参数的有效转换集取决于参数的数据类型。 13.5.5 Formatter转换类似于C语言中printf()的那些特殊的占位符，如%d，表示整数型。 13.5.6 String.format()Java SE5也参考了C中的sprintf()方法，以生成格式化的String对象。String.format()是一个static方法，它接受与Formatter.format()方法一样的参数，但是返回一个String对象。当你只需要使用format()方法一次时，String.format()用起来很方便。其实，在String.format()内部，它也是创建了一个Formatter对象，然后将你传入的参数转给该Formatter。不过，与其自己做这些事情，不如使用便捷的String.format()方法，何况这样的代码更清晰易读。 13.6 正则表达式Java中，\\的意思是“我要插入一个正则表达式的反斜线，以后的字符具有特殊的意义”，如果想插入普通的反斜线，则应该是\\\\ 字符 构造 匹配 x 字符 x \ 两个反斜线表示反斜线字符 \xhh 带有十六进制值 0x 的字符 hh \uhhhh 带有十六进制值 0x 的字符 hhhh \t 制表符 (‘\u0009’) \n 新行（换行）符 (‘\u000A’) \r 回车符 (‘\u000D’) \f 换页符 (‘\u000C’) \a 报警 (bell) 符 (‘\u0007’) \e 转义符 (‘\u001B’) \cx 对应于 x 的控制符 字符类 构造 匹配 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） [a-d[m-p]] a 到 d 或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e 或 f（交集） [a-z&amp;&amp;[^bc]] a 到 z，除了 b 和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a 到 z，而非 m 到 p：[a-lq-z]（减去） 预定义字符类 构造 匹配 . 任何字符（与行结束符可能匹配也可能不匹配） \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] POSIX字符类（仅 US-ASCII） 构造 匹配 \p{Lower} 小写字母字符：[a-z] \p{Upper} 大写字母字符：[A-Z] \p{ASCII} 所有 ASCII：[\x00-\x7F] \p{Alpha} 字母字符：[\p{Lower}\p{Upper}] \p{Digit} 十进制数字：[0-9] \p{Alnum} 字母数字字符：[\p{Alpha}\p{Digit}] \p{Punct} 标点符号：!”#$%&amp;’()*+,-./:;?@[]^_`{}~以及竖线和反斜线 \p{Graph} 可见字符：[\p{Alnum}\p{Punct}] \p{Print} 可打印字符：[\p{Graph}\x20] \p{Blank} 空格或制表符：[ \t] \p{Cntrl} 控制字符：[\x00-\x1F\x7F] \p{XDigit} 十六进制数字：[0-9a-fA-F] \p{Space} 空白字符：[ \t\n\x0B\f\r] 边界匹配器 构造 匹配 ^ 行的开头 $ 行的结尾 \b 单词边界 \B 非单词边界 \A 输入的开头 \G 上一个匹配的结尾 \Z 输入的结尾，仅用于最后的结束符（如果有的话） \z 输入的结尾 数量词 贪婪型 勉强型 占有型 匹配 X? X?? X?+ X，一次或一次也没有 X* X*? X*+ X，零次或多次 X+ X+? X++ X，一次或多次 X{n} X{n}? X{n}+ X，恰好 n 次 X{n,} X{n,}? X{n,}+ X，至少 n 次 X{n,m} X{n,m}? X{n,m}+ X，至少 n 次，但是不超过 m 次 占有型只有Java中才有 逻辑运算符 XY : X 后跟 Y X|Y : X 或 Y (X) : X，作为捕获组 典型的调用顺序是 123Pattern p = Pattern.compile("a*b");Matcher m = p.matcher("aaaaab");boolean b = m.matches(); Pattern常用方法 方法声明 说明 static Pattern compile(String regex) 将给定的正则表达式编译到模式中。 static Pattern compile(String regex, int flags) 将给定的正则表达式编译到具有给定标志的模式中。 Matcher matcher(CharSequence input) 创建匹配给定输入与此模式的匹配器。 static boolean matches(String regex, CharSequence input) 编译给定正则表达式并尝试将给定输入与其匹配。 String[] split(CharSequence input) 围绕此模式的匹配拆分给定输入序列。 String[] split(CharSequence input, int limit) 围绕此模式的匹配拆分给定输入序列。 Pattern标记 标记 说明 static int CANON_EQ 启用规范等价。当且仅当完全规范分解相匹配时，就认为它们是匹配的，指定此标记a\u030A就会匹配? static int CASE_INSENSITIVE(?i) 启用不区分大小写的匹配。 static int COMMENTS(?x) 模式中允许空白和注释。空白和以#开始的注释都会被忽略 static int DOTALL(?s) 启用 dotall 模式。.可以匹配任何字符，包括行结束符。默认情况下，此表达式不匹配行结束符。 static int LITERAL 启用模式的字面值解析。指定此标志后，输入序列中的元字符或转义序列不具有任何特殊意义。 static int MULTILINE(?m) 启用多行模式。仅分别在行结束符前后匹配，或者在输入序列的结尾处匹配。默认情况下，这些表达式仅在整个输入序列的开头和结尾处匹配。 static int UNICODE_CASE(?u) 启用 Unicode 感知的大小写折叠。 static int UNIX_LINES(?d) 启用 Unix 行模式。在此模式中，.、^ 和 $ 的行为中仅识别 ‘\n’ 行结束符。 Pattern.CASE_INSENSITIVE、Pattern.MULTILINE、Pattern.COMMENTS这三个标记特别有用。compile(String regex, int flags) 中的标记flags还可以用或(|)来组合。 Matcher常用方法 方法声明 说明 boolean matches() 尝试将整个区域与模式匹配。 boolean lookingAt() 尝试将从区域开头开始的输入序列与该模式匹配。 boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列。 boolean find(int start) 重置此匹配器，然后从指定索引开始的下一个子序列尝试查找匹配该模式。 int groupCount() 返回此匹配器模式中的捕获组数。不包括0组 String group() 返回由以前匹配操作所匹配的输入子序列。相当于group(0) String group(int group) 返回在以前匹配操作期间由给定组捕获的输入子序列。 int start() 返回以前匹配的初始索引。相当于start(0) int start(int group) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引。 int end() 返回最后匹配字符之后的偏移量。相当于end(0) int end(int group) 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量。 String replaceFirst(String replacement) 替换模式与给定替换字符串匹配的输入序列的第一个子序列。 String replaceAll(String replacement) 替换模式与给定替换字符串相匹配的输入序列的每个子序列。 Matcher appendReplacement(StringBuffer sb, String replacement) 从添加位置（一般为0，append开头的其它方法会改变这个值）到start()-1字符串添加到缓存；添加替换字符串到缓存区；将添加位置设置为end() StringBuffer appendTail(StringBuffer sb) 从添加位置开始添加到缓冲区。可以在一次或多次调用 appendReplacement 方法后调用它来复制剩余的输入序列。 Matcher reset() 重置匹配器到当前字符序列的起始位置 Matcher reset(CharSequence input) 重置此具有新输入序列的匹配器。 组是用括号划分的正则表达式，可以根据组的编号来引用某个组，组号为0表示整个表达式，组号1表示第一个括号括起来的组。A(B(C))D 组0是ABCD，组1是BC，组2是C。groupCount() 返回的组数不包括0组。只有三种是匹配操作：matches(),lookingAt(),find()，这三个方法如果匹配成功，会改变下一次匹配的起始索引。 13.7 扫描输入Java SE5新增了Scanner类。Scanner的构造器可以接受任何类型的输入对象，如File对象，InputStream，String对象。所有基本类型（除char外）包括BigDecimal和BigInteger，Scanner类都有next和hasnext方法。 Scanner定界符 在默认情况下，Scanner更具空白字符对输入进行分词，但是你可以用正则表达式指定自己所需的定界符。scanner.useDelimiter(“\s,\s“);//使用逗号作为界定符 用正则表达式扫描 除了能够扫描基本类型之外，你还可以使用自定义的正则表达式进行扫描，这在扫描复杂数据是非常有用。 12Scanner sc = new Scanner(System.in);int i = sc.nextInt(); 13.8 StringTokenizer基本上，我们可以放心的说，StringTokenizer已经可以废弃不用了。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp&Servlet笔记（五）JSP（二）]]></title>
    <url>%2F2017%2F11%2F19%2FJSP5%2F</url>
    <content type="text"><![CDATA[本文主要介绍jsp的语法（二） 第三十课. jsp_usebean_1jsp:useBean 通过jsp:useBean，可以在JSP中使用定义好的Bean Bean的基本要素： 必须要有一个不带参数的构造器。在JSP元素创建Bean时会调用空构造器 Bean类应该没有任何公共实例变量，也就是说，不允许直接访问实例变量，变量名称首字母必需小写 通过getter/setter方法来读/写变量的值，并且将对应的变量首字母改成大写 基本用法:12345&lt;jsp:useBean id=”beanName” scope=”page|request|session|application” class=”package BeanClass” type=”typeName” /&gt; &lt;jsp:useBean...&gt; &lt;jsp:setProperty...&gt; &lt;jsp:getProperty...&gt; &lt;/jsp:useBean&gt; 例子：test.jsp/CounterBean.java 不要使用裸体类 我们先看test.jsp：123456789101112131415161718192021&lt;%@ page import="bean.*" %&gt;&lt;% //response.sendRedirect("../servlet/ShowRs"); %&gt;&lt;% CounterBean cb = new CounterBean(); %&gt;&lt;font color="red" size="5"&gt; &lt;%=cb.getCount()%&gt;&lt;/font&gt;&lt;%--&lt;jsp:useBean id="cb" class="bean.CounterBean"&gt;&lt;/jsp:useBean&gt;&lt;jsp:setProperty name="cb" property="count" value="23"/&gt; &lt;%-- cb.setCount(23) --%&gt; &lt;jsp:getProperty name="cb" property="count"/&gt; &lt;%--out.write(cb.getCount())--%&gt;--%&gt; 再看CounterBean.java:123456789101112131415161718192021222324//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package bean;import java.io.Serializable;public class CounterBean implements Serializable &#123; int count = 0; public CounterBean() &#123; &#125; public int getCount() &#123; ++this.count; return this.count; &#125; public void setCount(int c) &#123; this.count = c; &#125;&#125; 将这个.java文件进行编译，生成.class文件，放在webapp/test/WEB-INF/class/bean目录下，访问：http://127.0.0.1:8888/test/testbean/test.jsp发现变量永远是1。 第三十一课. jsp_usebean_scopejsp:useBean(con.) jsp:useBean各项参数含义： id:对象实例名称 scope:Bean作用的范围，默认为page，对整个jsp页面有效 class:Bean类名称(全名） type:Bean实例类型，可以是本类，或其父类，或实现的接口，默认为本类 Scope各项参数的意义： page:仅涵盖使用JavaBean的页面 （PageBean.jsp/CounterBean.java） request:有效范围仅限于使用JavaBean的请求 （RequestBean.jsp/RequestBean2.jsp/CounterBean.java） session:有效范围在用户整个连接过程中（整个会话阶段均有效） （SessionBean.jsp/Session2.jsp/CounterBean.java） application:有效范围涵盖整个应用程序。也就是对整个网站均有效 （Application.jsp/Application2.jsp/CounterBean.java） 一、page先看一个例子：我们写了一个PageBean.jsp: 1234567891011&lt;%-- *************** PageBean.jsp **************** --%&gt;&lt;jsp:useBean id="counterBean" scope="page" class="bean.CounterBean" /&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;H3&gt;CounterBean scope="page" Example&lt;/H3&gt;&lt;B&gt;count:&lt;/B&gt; &lt;%= counterBean.getCount() %&gt;&lt;jsp:getProperty name="counterBean" property="count"/&gt;&lt;/BODY&gt;&lt;/HTML&gt; 访问地址： 发现count中第一个数是1，第二个是2.第一个count的显示语句是：&lt;B&gt;count:&lt;/B&gt; &lt;%= counterBean.getCount() %&gt;所以在0基础上加1，得到1.第二个显示是：&lt;jsp:getProperty name=&quot;counterBean&quot; property=&quot;count&quot;/&gt;它和&lt;%= counterBean.getCount() %&gt;效果是一样的，所以也加1，就是2. 二、request 再看RequestBean.jsp： 123456789101112131415161718192021222324252627282930&lt;%-- ************* RequestBean.jsp ************** --%&gt;&lt;jsp:useBean id="counterBean" scope="request" class="bean.CounterBean" /&gt;&lt;%--&lt;% bean.CounterBean counterBean = (bean.CounterBean)request.getAttribute("counterBean"); if(counterBean == null) &#123; counterBean = new bean.CounterBean(); request.setAttribute("counterBean", counterBean); &#125;%&gt;--%&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;H3&gt;CounterBean scope="request" Example&lt;/H3&gt;&lt;% counterBean.setCount(100); %&gt;&lt;jsp:forward page="RequestBean2.jsp" /&gt;&lt;%--&lt;% response.sendRedirect("RequestBean2.jsp"); %&gt;--%&gt;&lt;/BODY&gt;&lt;/HTML&gt; 其中，1234567&lt;% bean.CounterBean counterBean = (bean.CounterBean)request.getAttribute("counterBean"); if(counterBean == null) &#123; counterBean = new bean.CounterBean(); request.setAttribute("counterBean", counterBean); &#125;%&gt; 相当于1&lt;% request.setAttribute(“counterBean”, new bean.CounterBean()); %&gt; 再看一下RequestBean2.jsp：12345678910&lt;%-- ************* RequestBean2.jsp ************** --%&gt;&lt;jsp:useBean id="counterBean" scope="request" class="bean.CounterBean" /&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;H3&gt;CounterBean scope="request" Example&lt;/H3&gt;&lt;B&gt;Count:&lt;/B&gt; &lt;%= counterBean.getCount() %&gt;&lt;/BODY&gt;&lt;/HTML&gt; 运行一下： 可以看到Count的值是101，所以RequestBean和RequestBean2用的是同一个request。当不再使用forward，使用&lt;% response.sendRedirect(“RequestBean2.jsp”) %&gt;这时RequestBean和RequestBean2不再使用同一个request，而RequestBean2.jsp中的scope是request，所以找不到Count变量，就new一个新的。访问可以看到它的值是1： 三、session 我们看一下SessionBean.jsp： 1234567891011121314151617181920212223&lt;%-- *************** SessionBean.jsp **************** --%&gt;&lt;jsp:useBean id="counterBean" scope="session" class="bean.CounterBean" /&gt; &lt;%--&lt;%bean.CounterBean counterBean = (bean.CounterBean)session.getAttribute("counterBean");if(counterBean == null) &#123; counterBean = new bean.CounterBean(); session.setAttribute("counterBean", counterBean);&#125;%&gt;--%&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;H3&gt;CounterBean scope="session" Example&lt;/H3&gt;&lt;B&gt;Count:&lt;/B&gt; &lt;%= counterBean.getCount() %&gt;&lt;/BODY&gt;&lt;/HTML&gt; 访问： 发现每次刷新都自动加1.当我们新启动一个窗口时，Count又变成了1： 因为它们不是一个session 四、Application ApplicationBean.jsp代码： 1234567891011121314151617181920212223&lt;%-- *********** ApplicationBean.jsp ************ --%&gt;&lt;%--&lt;jsp:useBean id="counterBean" scope="application" class="bean.CounterBean" /&gt; --%&gt; &lt;%bean.CounterBean counterBean = (bean.CounterBean)application.getAttribute("counterBean");if(counterBean == null) &#123; counterBean = new bean.CounterBean(); application.setAttribute("counterBean", counterBean);&#125;%&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;H3&gt;CounterBean scope="application" Example&lt;/H3&gt;&lt;B&gt;Count:&lt;/B&gt; &lt;%= counterBean.getCount() %&gt;&lt;/BODY&gt;&lt;/HTML&gt; 进行访问： 发现每次刷新都会自动加1.而且即使重新开一个窗口，也会加1，因为Scope是整个application 第三十二课. jsp_set_property 建立表单参数和Bean属性之间的关联 通过param指定表单元素的名称，通过perperty指定对应的Bean属性名称，由此建立这两个变量的关联 （SaleEntry.jsp/SaleEntry.java，用url传递参数） 通过*来设置所有属性和输入参数之间的关联 (SayHelloBean.html/SayHelloBean.jsp/HelloBean.java)在建立Bean属性和表单参数之间的对应关系时，服务器会将对应的参数自动转换成和属性类型匹配的数据 先看SaleEntry.java:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package bean;/** Simple bean to illustrate the various forms * of jsp:setProperty. */public class SaleEntry &#123; private String itemID = "unknown"; private double discountCode = 1.0; private int numItems = 0; public String getItemID() &#123; return(itemID); &#125; public void setItemID(String itemID) &#123; if (itemID != null) &#123; this.itemID = itemID; &#125; else &#123; this.itemID = "unknown"; &#125; &#125; public double getDiscountCode() &#123; return(discountCode); &#125; public void setDiscountCode(double discountCode) &#123; this.discountCode = discountCode; &#125; public int getNumItems() &#123; return(numItems); &#125; public void setNumItems(int numItems) &#123; this.numItems = numItems; &#125; // Replace this with real database lookup. public double getItemCost() &#123; double cost; if (itemID.equals("a1234")) &#123; cost = 12.99*getDiscountCode(); &#125; else &#123; cost = -9999; &#125; return(roundToPennies(cost)); &#125; private double roundToPennies(double cost) &#123; return(Math.floor(cost*100)/100.0); &#125; public double getTotalCost() &#123; return(getItemCost() * getNumItems()); &#125;&#125; 再看SaleEntry.jsp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;!-- Example of using jsp:setProperty and an explicity associationwith an input parameter. See SaleEntry1.jspand SaleEntry3.jsp for alternatives. --&gt;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Using jsp:setProperty&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;TABLE BORDER=5 ALIGN="CENTER"&gt; &lt;TR&gt;&lt;TH CLASS="TITLE"&gt; Using jsp:setProperty&lt;/TABLE&gt;&lt;jsp:useBean id="entry" class="bean.SaleEntry" /&gt;&lt;jsp:setProperty name="entry" property="itemID" value='&lt;%=request.getParameter("itemID")%&gt;' /&gt; &lt;jsp:setProperty name="entry" property="numItems" param="numItems" /&gt; &lt;jsp:setProperty name="entry" property="discountCode" param="discountCode" /&gt;&lt;BR&gt;&lt;TABLE ALIGN="CENTER" BORDER=1&gt;&lt;TR CLASS="COLORED"&gt; &lt;TH&gt;Item ID&lt;TH&gt;Unit Price&lt;TH&gt;Number Ordered&lt;TH&gt;Total Price&lt;TR ALIGN="RIGHT"&gt; &lt;TD&gt;&lt;jsp:getProperty name="entry" property="itemID" /&gt; &lt;TD&gt;$&lt;jsp:getProperty name="entry" property="itemCost" /&gt; &lt;TD&gt;&lt;jsp:getProperty name="entry" property="numItems" /&gt; &lt;TD&gt;$&lt;jsp:getProperty name="entry" property="totalCost" /&gt;&lt;/TABLE&gt; &lt;/BODY&gt;&lt;/HTML&gt; 运行一下： 这里在前面遇到点小问题，就是原来的代码是value=&quot;&lt;%=request.getParameter(&quot;itemID&quot;)%&gt;&quot; /&gt;跑一下会报一堆错误。后来把双引号改成单引号，就正常了。 再看下一个例子：先看SayHelloBean.html：1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt;&lt;title&gt;数据输入&lt;/title&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;&lt;/head&gt;&lt;body bgcolor="#FFFFFF"&gt;&lt;div align="center"&gt; &lt;p&gt;请输入数据&lt;/p&gt; &lt;form method="post" action="SayHelloBean.jsp" &gt; &lt;p&gt;姓名 &lt;input type="text" name="name"&gt; 性别 &lt;select name="sex"&gt; &lt;option value="先生"&gt;先生&lt;/option&gt; &lt;option value="女士"&gt;女士&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" name="Submit" value="提交"&gt; &lt;/p&gt; &lt;/form&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 再看SayHelloBean.jsp：1234567891011121314151617181920212223242526272829303132333435&lt;%--jsp:useBean@ page language="java" import="bean.HelloBean;" --%&gt;&lt;%@ page contentType="text/html;charset=gb2312" %&gt;&lt;%//request.getParameter("name");request.setCharacterEncoding("gb2312");%&gt;&lt;jsp:useBean id="hello" class="bean.HelloBean" scope="request" &gt; &lt;jsp:setProperty name="hello" property="*" /&gt;&lt;/jsp:useBean&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;HelloBean&lt;/title&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;&lt;/head&gt;&lt;body bgcolor="#FFFFFF"&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p align="center"&gt;&lt;font size="4"&gt;欢迎&lt;font color="#0000FF"&gt;&lt;b&gt; &lt;%-- &lt;%=new String(hello.getName().getBytes("ISO8859_1"),"GBK")%&gt;--%&gt;&lt;/b&gt;&lt;/font&gt;&lt;%--&lt;%=new String(hello.getSex().getBytes("ISO8859_1"),"GBK")%&gt;--%&gt;&lt;/font&gt;&lt;/p&gt;&lt;jsp:getProperty name="hello" property="name"/&gt;&lt;jsp:getProperty name="hello" property="sex"/&gt;&lt;/body&gt;&lt;/html&gt; 最后看一下HelloBean.java： 1234567891011121314151617181920212223242526package bean; public class HelloBean&#123; private String name=""; private String sex=""; public HelloBean()&#123; &#125; public void setName( String name )&#123; this.name = name; &#125; public String getName()&#123; return this.name; &#125; public void setSex( String sex )&#123; this.sex = sex; &#125; public String getSex()&#123; return this.sex; &#125; &#125; 访问一下： 第三十三课. jsp_characterEncoding如果页面出现乱码，可以在jsp中采用类似下面的方式进行转码： 1234&lt;%String name = request.getParameter("name");out.println(new String(name.getBytes("ISO8859_1"), "GBK"));%&gt; 第三十四课. jsp_servlet_forwardJSP的内置对象 out request response pageContext -&gt;用的很少 session application config -&gt;用的很少 exception Page-&gt;用的很少 JSP编程—out Out内置对象是一个缓冲的输出流，用来给客户端返回信息。它是javax.servlet.jsp.JspWriter的一个实例 典型应用：向客户端输出内容 例：向客户端输出一个字符串“Hello World” (HelloWorld.jsp) 常用方法： println()：向客户端输出各种类型数据 newLine()：输出一个换行符 close()：关闭输出流 flush()：输出缓冲区里的数据 clearBuffer()：清除缓冲区里的数据，同时把数据输出到客户端 clear()：清除缓冲区里的数据，但不把数据输出到客户端 getBufferSize()：返回缓冲区的大小 JSP编程–request request内置对象表示的是调用JSP页面的请求。通常，request对象是javax.servlet.http.HttpServletRequest接口的一个实例 典型应用：通过request.getParameter(“paramName”)可以获得Form提交过来的参数值 可以用此对象取得请求的Header、信息（如浏览器版本、语言和编码等）、请求的方式（get/post）、请求的参数名称、参数值、客户端的主机名称等 常用方法： getMethod()：返回客户端向服务器端传送数据的方法 getParameter(String paramName)：返回客户端向服务器端传送的参数值，该参数由paramName指定 getParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举类型数据（Enumeration） getParameterValues(String name)：获得指定参数的所有值，由name指定 getRequestURI（）：获得发出请求字符串的客户端地址 getRemoteAddr()：获取客户端的IP地址 getRemoteHost()：获取客户端机器名称 getServerName()：获取服务器的名字 getServletName()：客户端所请求的脚本文件路径 getServerPort()：获取服务器端的端口 对应类: javax.servlet.http.HttpServletRequest JSP-response 表示的是返回给客户端的响应 是javax.servlethttp.HttpServletResponse接口的一个实例 经常用于设置HTTP标题，添加cookie、设置响应内容的类型和状态、发送HTTP重定向和编码URL 常用方法： addCookie(Cookie cookie)：添加一个Cookie对象，用于在客户端保存特定的信息 addHeader(String name,String value)：添加HTTP头信息，该Header信息将发送到客户端 containsHeader(String name)：判断指定名字的HTTP文件头是否存在 sendError(int)：向客户端发送错误的信息 sendRedirect(String url)：重定向JSP文件– 和的区别– – sendRedirect通过客户端发起二次申请,不同的request对象– – Jsp:forward是同一个request,在服务器内部转发– setContentType(String contentType)：设置MIME类型与编码方式 JSP-Cookie Http协议的无连接性要求出现一种保存C/S间状态的机制 Cookie：保存到客户端的一个文本文件，与特定客户相关 Cookie以“名-值”对的形式保存数据 通过getName和getValue的方式得到相应的名字和值 JSP—session &amp; application &lt;% @page session=“true”%&gt;（默认）–表示session功能已经在jsp页面中启动 session常用方法： void setAttribute(String name,Object value) Object getAttribute(String name) boolean isNew() application ServletContext Servlet和JSP的通信 从JSP调用Servlet可用请求信息自动传递到Servlet 或者通过sendRedirect 从Servlet调用JSP使用 RequestDispatcher接口的forward(req, res)方法 请求信息需要显式传递(在req、res参数中） 或者通过sendRedirect 例如: FromJspToServlet.jsp / ServletToJsp.java / ServletUseJsp.jsp forward可以用 ”/” 路径, 是指web app的根路径, servlet forward jsp的时候一定要用 “/”开头 jsp sendRedirect到servlet应该用相对路径,因为这里”/”指网站的根路径 servlet sendRedirect jsp也是request.getContextPath起作用了 看一个例子：写一个ServletToJsp.java并编译：12345678910111213141516import javax.servlet.*;import javax.servlet.http.*;public class ServletToJsp extends HttpServlet &#123; public void doGet (HttpServletRequest req,HttpServletResponse resp) &#123; try &#123; // 设置属性并将它提交给ServletUseJsp.jsps resp.setContentType("text/html;charset=gb2312"); req.setAttribute ("servletName", "ServletToJsp"); getServletConfig().getServletContext().getRequestDispatcher ("/ServletUseJsp.jsp").forward(req, resp); &#125;catch (Exception e)&#123; e.printStackTrace (); &#125; &#125;&#125; 将.class文件放到classes目录下，并在web.xml中进行修改： 123456789&lt;servlet&gt; &lt;servlet-name&gt;ServletToJSP&lt;/servlet-name&gt; &lt;servlet-class&gt;ServletToJSP&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServletToJSP&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ServletToJSP&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 看ServletToJSP: 12345678910111213141516import javax.servlet.*;import javax.servlet.http.*;public class ServletToJSP extends HttpServlet &#123; public void doGet (HttpServletRequest req,HttpServletResponse resp) &#123; try &#123; // 设置属性并将它提交给ServletUseJsp.jsp resp.setContentType("text/html;charset=gb2312"); req.setAttribute ("servletName", "ServletToJsp"); getServletConfig().getServletContext().getRequestDispatcher ("/ServletUseJsp.jsp").forward(req, resp); &#125;catch (Exception e)&#123; e.printStackTrace (); &#125; &#125;&#125; 再看ServletUseJsp.jsp: 1234567891011121314&lt;%@ page contentType="text/html;charset=gb2312"%&gt;&lt;html&gt;&lt;meta context="text/html;charset=gb2312" &gt;&lt;head&gt;&lt;title&gt;Servlet使用JSP&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="gray"&gt;&lt;h2&gt;Servlet使用JSP的例子:&lt;/h2&gt;&lt;h2&gt;这个页面是被这个Servlet调用的.&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 访问http://127.0.0.1:8888/test/servlet/ServletToJSP： 看下一个例子：文件是FromJspToServlet.jsp： 12345&lt;html&gt;&lt;body bgcolor="green"&gt;&lt;!-- Forward to a servlet，这个servlet存放在web-inf的servlet目录下 --&gt;&lt;jsp:forward page="/servlet/ServletToJSP" /&gt;&lt;/html&gt; 访问这个jsp:发现通过forward指令，该jsp还是跳转到了ServletToJSP]]></content>
      <categories>
        <category>Jsp</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp&Servlet笔记（四）JSP（一）]]></title>
    <url>%2F2017%2F11%2F18%2FJSP4%2F</url>
    <content type="text"><![CDATA[本文主要介绍jsp的语法 第二十四课. JSP_HelloWorldJSP简介 JSP—Java Server Pages 拥有servlet的特性与优点(本身就是一个servlet) 直接在HTML中内嵌JSP代码 JSP程序由JSP Engine先将它转换成Servlet代码，接着将它编译成类文件载入执行只有当客户端第一次请求JSP时，才需要将其转换、编译 优点: 优良的性能优于CGI，PHP，ASP 平台无关性操作系统无关，Web服务器无关 可扩展性tag的扩展机制，简化页面开发 JSP极大简化了servlet操作，我们写一个JSP文件HelloWorld.jsp：123456789&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;% out.println("HelloWorld!"); out.println(new java.util.Date()); %&gt; &lt;/body&gt;&lt;/html&gt; 将这个jsp文件放在tomcat9.0.1\webapps\test路径下，直接启动tomcat就可以对这个jsp进行访问了。输入地址：http://127.0.0.1:8888/test/HelloWorld.jsp我们看到如下显示： 这样，调试时候只需要改jsp文件就可以了，相当便利。tomcat下有一个文件夹work，存放jsp编译之后的.class文件和.java文件： JSP编程-基本语法JSP传统语法 Declaration–声明 Scriptlet–小程序段 Expression–表达式 Comment–注释 Directives–指令 Action动作指令 内置对象JSTLJSF 第二十五课. JSP基本语法_1Declaration–声明基本语法：&lt;%! %&gt;说明：在此声明的变量、方法都会被保留成唯一的一份，直到JSP程序停止执行例：1234&lt;%!int i;public void setName()&#123;… …&#125;%&gt; 代码（AccessCounts.jsp）：12345678910111213141516171819202122232425262728293031&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;JSP Declarations&lt;/TITLE&gt;&lt;META NAME="author" CONTENT="Marty Hall"&gt;&lt;META NAME="keywords" CONTENT="JSP,declarations,JavaServer,Pages,servlets"&gt;&lt;META NAME="description" CONTENT="A quick example of JSP declarations."&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;JSP Declarations&lt;/H1&gt;&lt;%! int accessCount = 0; %&gt;&lt;% int accessCount2 = 0; %&gt;&lt;H2&gt;Accesses to page since server reboot: &lt;%= ++accessCount %&gt;&lt;br&gt;&lt;%= ++accessCount2 %&gt;&lt;/H2&gt;&lt;/BODY&gt;&lt;/HTML&gt; 将这个jsp放在test目录下，访问网址：http://127.0.0.1:8888/test/AccessCounts.jsp不断刷新后得到页面是： 发现上面的数字每刷新一次就加1；而下面的数字总是1。这是由于&lt;%!后的变量为类的成员变量，类只初始化一次，所以accessCount每次都会在上次页面基础上加1；而&lt;% 后的变量为局部变量，所以没刷新一次都会从0加到1。验证这个结论的办法就是去查看tomcat的work目录下生成的.java文件。 发现一个问题，就是在页面刷新特别快的时候，类成员变量accessCount会回1，原因可能有两个：第一个就是tomcat在将jsp转成servlet的对象时，可能做了一个池，里面放了好几个，第一个服务不过来的时候就调第二个，这时accessCount的值有好几个第二个就是就是刷新的时候，可能上一个值修改完还没来得及reload，我们就又刷新了一次，这时刚好上一次进行了reload，所以值就修改回去了。 第二种情况可能性较大。 可以在&lt;%! %&gt;中声明方法，相当于类中方法。 Scriptlet–小程序段基本语法：&lt;%程序代码区%&gt;可以放入任何的Java程序代码例：123456&lt;%for (int i=0;i&lt;10,i++)&#123; … …&#125;%&gt; 注释格式：123&lt;%--… …--%&gt;&lt;%//… …%&gt;&lt;%/*… …*/%&gt; 代码（BGColor.jsp）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;HTML&gt;&lt;HEAD&gt; &lt;TITLE&gt;Color Testing&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;!--html注释--&gt;&lt;%--注释1aaaaaaa--%&gt;&lt;%//注释2/*注释3aaaaa*/String bgColor = request.getParameter("bgColor");boolean hasExplicitColor;if (bgColor != null) &#123; hasExplicitColor = true;&#125; else &#123; hasExplicitColor = false; bgColor = "WHITE";&#125;%&gt;&lt;BODY BGCOLOR="&lt;%= bgColor %&gt;"&gt;&lt;H2 ALIGN="CENTER"&gt;Color Testing&lt;/H2&gt;&lt;%if (hasExplicitColor) &#123; out.println("You supplied an explicit background color of " + bgColor + ".");&#125; else &#123; out.println("Using default background color of WHITE. " + "Supply the bgColor request attribute to try " + "a standard color, an RRGGBB value, or to see " + "if your browser supports X11 color names.");&#125;%&gt;&lt;/BODY&gt;&lt;/HTML&gt; 访问网址：http://127.0.0.1:8888/test/BGColor.jsp 发现背景色是白色的： 当传入参数以后，背景变色： Expression–表达式 基本语法： &lt;%=… …%&gt; =后面必须是字符串变量或者可以被转换成字符串的表达式 不需要以;结束 只有一行 例： &lt;%=“hello world”%&gt; &lt;%=i+1%&gt; &lt;%=request.getParameter(“name”)%&gt; 例子（Expressions.jsp）：12345678910111213141516171819202122232425&lt;!-- Example of JSP Expressions. --&gt;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;JSP Expressions&lt;/TITLE&gt;&lt;META NAME="author" CONTENT="Marty Hall"&gt;&lt;META NAME="keywords" CONTENT="JSP,expressions,JavaServer,Pages,servlets"&gt;&lt;META NAME="description" CONTENT="A quick example of JSP expressions."&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H2&gt;JSP Expressions&lt;/H2&gt;&lt;UL&gt; &lt;LI&gt;Current time: &lt;%= new java.util.Date() %&gt; &lt;LI&gt;Your hostname: &lt;%= request.getRemoteHost() %&gt; &lt;LI&gt;Your session ID: &lt;%= session.getId() %&gt; &lt;LI&gt;The &lt;CODE&gt;testParam&lt;/CODE&gt; form parameter: &lt;%= request.getParameter("testParam") %&gt;&lt;/UL&gt;&lt;/BODY&gt;&lt;/HTML&gt; 访问地址得到： 发现testParam是空的，这时候传入一个参数： 发现testParam将参数显示出来。 第二十六课. page_directiveDirective–编译指令Directive(编译指令)相当于在编译期间的命令格式：&lt;%@Directive 属性=“属性值”%&gt;常见的Directive： page include taglib Directive-page 指明与JSP Container 的沟通方式 基本格式：12345678910111213&lt;%@page language=“script language”| extends=“className”| import=“importList”| buffer=“none|kb size”| --none:不缓冲，默认8k session=“true|false”| --是否可以使用session，默认true autoFlush=“true|false” --缓冲器是否自动清除，默认true isThreadSafe=“true|false”| --默认false(永远不要设成true) info=“infoText”| --任何字符 errorPage=“errorPageUrl”| isErrorPage=“true|false”| contentType=“contentTyepInfo”| pageEncoding=“gb2312”%&gt; 例子：TestDirective.jsp：123456&lt;%@page import="java.util.*" session="false"%&gt;&lt;%@page contentType="text/html;charset=gb2312"%&gt;&lt;%= new Date() %&gt;&lt;% out.println("你好!");%&gt; 我们做一个测试，写一个TestErr.jsp的文件：123456&lt;%@page errorPage="ErrPage.jsp"%&gt;&lt;%String s="123Plus";int i=Integer.parseInt(s);out.println("s=" + s + " i=" + i);%&gt; 当我们把第一句&lt;%@page errorPage=&quot;ErrPage.jsp&quot;%&gt;删掉以后，访问http://127.0.0.1:8888/test/TestErr.jsp发现会报错： 所以我们为了界面的友好，还是讲发生错误的页面指向了一个新页面，所以加上：&lt;%@page errorPage=&quot;ErrPage.jsp&quot;%&gt;并编写ErrPage.jsp文件：123456789&lt;%-- ********* ErrPage.jsp ********** --%&gt;&lt;%@ page contentType="text/html;charset=gb2312" %&gt;&lt;%@ page isErrorPage="true" %&gt;&lt;HTML&gt;&lt;BODY TEXT="red"&gt;错误信息：&lt;%= exception.getMessage() %&gt;&lt;/BODY&gt;&lt;/HTML&gt; 重新访问：http://127.0.0.1:8888/test/TestErr.jsp页面显示为重新定向过的页面： 第二十七课. page_includeDirective–include 将指定的JSP程序或者HTML文件包含进来 格式： &lt;%@include file=“fileURL%&gt; JSP Engine会在JSP程序的转换时期先把file属性设定的文件包含进来，然后开始执行转换及编译的工作。(原封不动的把文件的代码copy到该位置,然后进行转换和编译,只生成一个java和class) 限制: 不能向fileURL中传递参数 不能abc.jsp?user=aaa 我们来测试一下这个功能： 我们写一个TestBar.jsp： 123456789101112&lt;%@page contentType="text/html;charset=gb2312"%&gt;&lt;HTML&gt; &lt;!-- *************** TestBar.jsp ***************** --&gt;&lt;HEAD&gt;&lt;TITLE&gt;TestBar.jsp&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;TABLE WIDTH="100%"&gt;&lt;TR&gt;&lt;TD&gt;&lt;%@ include file="TitleBar.jsp" %&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;&lt;% out.println("&lt;P&gt;这是用户显示区&lt;/P&gt;"); %&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/BODY&gt;&lt;/HTML&gt; 可以看到里面include了一个TitleBar.jsp，也就是在编译期间将TitleBar.jsp文件内容原封不动地传递进来。TitleBar.jsp内容如下： 1234567891011&lt;%@page contentType="text/html;charset=gb2312"%&gt;&lt;TABLE&gt; &lt;!-- ********** TitleBar.jsp ************** --&gt;&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;&lt;TD&gt;&lt;% out.println("Hi: " + request.getParameter("user"));%&gt;&lt;%=new java.util.Date()%&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt; 然后访问地址： 发现用户值为null。当我们将用户值传入时，界面才会予以显示： 在编译指令中不能往里传参数，所以不能这么写：&lt;TR&gt;&lt;TD&gt;&lt;%@ include file=&quot;TitleBar.jsp?user=ab&quot; %&gt;&lt;/TD&gt;&lt;/TR&gt; 第二十八课. jsp_includeAction Action(动作指令)在运行期间的命令 常见的: jsp:useBean jsp:setProperty jsp:getProperty jsp:include jsp:forward jsp:param jsp:plugin 嵌入applet jsp:include/jsp:param 用于动态包含JSP程序或HTML文件等 除非这个指令会被执行到，否则它是不会被Tomcat等JSP Engine编译。 格式： jsp:param用来设定include文件时的参数和对应的值 例如: date.jsp/include.jsp Compute.html/Compute.jsp/divide.jsp/multiply.jsp 和编译指令include的区别 include编译指令是在JSP程序的转换时期就将file属性所指定的程序内容嵌入，然后再编译执行；而include指令在转换时期是不会被编译的，只有在客户端请求时期如果被执行到才会被动态的编译载入 Include不能带参数, 而可以动态包含的文件和被包含文件用的是同一个request对象 我们来看一下上面说的例子：先看include.jsp：123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt; include test&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="white"&gt;&lt;font color="red"&gt;The current date and time are &lt;%@ include file="date.jsp" %&gt;&lt;jsp:include page="date.jsp" flush="true"/&gt;&lt;/font&gt;&lt;/body&gt;&lt;/html&gt; 上面包含了两次date.jsp，一次通过静态方式，一次通过动态方式。再看一下date.jsp：12&lt;%@ page import="java.util.*" %&gt;&lt;%= (new Date()).toLocaleString() %&gt; 即通过date.jsp获取当前时间，并转换成自己本地的字符串。 运行一下： 发现显示了两次这个时间。 接下来看第二个例子，关于计算器的例子。先看Compute.html：1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt;&lt;title&gt;Compute&lt;/title&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;&lt;/head&gt;&lt;body bgcolor="#FFFFFF"&gt;&lt;div align="center"&gt; &lt;form method="post" action="Compute.jsp"&gt; &lt;p&gt;选择要做的运算 &lt;input type="radio" name="compute" value="division" checked&gt; 除法 &lt;input type="radio" name="compute" value="multiplication"&gt; 乘法&lt;/p&gt; &lt;p&gt;被除数（被乘数） &lt;input type="text" name="value1"&gt; 除数（乘数） &lt;input type="text" name="value2"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="submit" name="Submit" value="计算结果"&gt; &lt;/p&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到表单提交后执行动作，处理程序是Compute.jsp 再看Compute.jsp：123456789101112131415&lt;%@ page language="java" %&gt;&lt;% String value1 = request.getParameter("value1"); String value2 = request.getParameter("value2");%&gt;&lt;% if( request.getParameter("compute").equals("division") ) &#123; %&gt; &lt;jsp:include page="divide.jsp" flush="true"&gt; &lt;jsp:param name="v1" value="&lt;%=value1%&gt;"/&gt; &lt;jsp:param name="v2" value="&lt;%=value2%&gt;"/&gt; &lt;/jsp:include&gt;&lt;% &#125; else &#123; %&gt; &lt;%@ include file="multiply.jsp"%&gt;&lt;% &#125; %&gt; 上面的代码中，先用两个字符串value1和value2将html中输入的两个数字进行赋值，然后通过123456&lt;% if( request.getParameter("compute").equals("division") ) &#123; %&gt;一句来对算数操作进行判断。如果是除法，执行： &lt;jsp:include page="divide.jsp" flush="true"&gt; &lt;jsp:param name="v1" value="&lt;%=value1%&gt;"/&gt; &lt;jsp:param name="v2" value="&lt;%=value2%&gt;"/&gt; &lt;/jsp:include&gt; 否则就是乘法，执行：&lt;%@ include file=&quot;multiply.jsp&quot;%&gt; 看一下除法的jsp文件，也就是divide.jsp:1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt;&lt;title&gt;Divide&lt;/title&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;&lt;/head&gt;&lt;body bgcolor="#FFFFFF"&gt;&lt;center&gt;&lt;h1&gt;&lt;% try&#123; float dividend = Float.parseFloat( request.getParameter( "value1" ) ); float divisor = Float.parseFloat( request.getParameter( "value2" ) ); double result=dividend/divisor; %&gt; &lt;%= result%&gt; &lt;% //out.println( dividend + " / " + divisor + " = " + result ); &#125; catch( Exception ex )&#123; out.println( "不合法的被除数或除数！" ); &#125;%&gt; &lt;/h1&gt;&lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 上面代码的value1也可以用v1，是可以跑通的。 再看乘法的jsp(multiply.jsp)： 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;title&gt;Devide&lt;/title&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312"&gt;&lt;/head&gt;&lt;body bgcolor="#FFFFFF"&gt;&lt;center&gt;&lt;h1&gt;&lt;% try&#123; //System.out.println(request.getParameter("v1")); float multiplicand = Float.parseFloat( request.getParameter( "value1" ) ); float multiplicator = Float.parseFloat( request.getParameter( "value2" ) ); double result=multiplicand*multiplicator; out.println( multiplicand + " * " + multiplicator + " = " + result ); &#125; catch( Exception ex )&#123; out.println( "不合法的被乘数或乘数！" ); &#125;%&gt; &lt;/h1&gt;&lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 要是把乘法代码中的value1改成v1，就会报错。因为v1是除法代码中的局部变量。 第二十九课. sp_forward_sendredirect用于将一个jsp的内容传送到page所指定的JSP程序或者Servlet中处理(URL)格式：1234&lt;jsp:forward page=“urlSpec” flush=“true”/&gt;&lt;jsp:forward page=“urlSpec”&gt; &lt;jsp:param name=“paramName” value=“paramValue”/&gt; &lt;/jsp:forward&gt; &lt;jsp:param&gt;用于指定参数和其对应的值例如:test.jspforward.jsp / forforward.jspforward1.jsp / forforward1.jsp(with parameters)Forward的页面和forward到的页面用的是同一个request与此相对应的是response.sendRedirect 先看一下forward.jsp：12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;forward example&lt;/title&gt;&lt;body bgcolor=red&gt;welcome to here!&lt;jsp:forward page="forforward.jsp" /&gt;&lt;/body&gt;&lt;/html&gt; 这个页面背景色是是红色。上面的代码执行的动作是，在执行forward.jsp时，页面会原封不动地跳转到forforward.jsp页面。 看一下forforward.jsp：123456&lt;html&gt;&lt;head&gt;&lt;title&gt;forforward.jsp&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=blue&gt;here is the forforward page&lt;/body&gt;&lt;/html&gt; 上面页面背景色是蓝色。我们尝试访问以下forward.jsp： 发现路径仍然是在forward.jsp，但是显示的却是蓝色的forforward.jsp 再看第二个例子（forward1/forforward1）：先看forward1.jsp：123456789101112&lt;html&gt;&lt;head&gt;&lt;title&gt;forward example&lt;/title&gt;&lt;body bgcolor=red&gt;welcome to here!&lt;jsp:forward page="forforward1.jsp"&gt; &lt;jsp:param name="name" value="m" /&gt; &lt;jsp:param name="oldName" value='&lt;%=request.getParameter("name")%&gt;' /&gt; &lt;jsp:param name="roles" value="manager" /&gt;&lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; 上面相当于做到forforward1.jsp?name=m&amp;oldname=… 再看一下forforward1.jsp: 1234567891011&lt;html&gt;&lt;head&gt;&lt;title&gt;forforward1.jsp&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=blue&gt;here is the forforward1 page&lt;br&gt;&lt;%=request.getParameter("name")%&gt;&lt;%=request.getParameter("oldName")%&gt;&lt;%=request.getParameter("roles")%&gt;&lt;%=request.getParameter("ccc")%&gt;&lt;/body&gt;&lt;/html&gt; 我们尝试访问forward1.jsp： 可以看到值都是null，现在给参数传值： 发现参数成功显示。 再看第三个例子(test.jsp和forforward.jsp)：先看test.jsp：1234&lt;% response.sendRedirect("forforward1.jsp"); System.out.println("ddd");%&gt; 当我们输入地址:http://127.0.0.1:8888/test/forward/test.jsp访问发现页面地址直接跳转到了http://127.0.0.1:8888/test/forward/forforward1.jsp 所以这里有一点结论： 与response.sendRedirect的区别 使用同一个request forward后的语句不会继续发送给客户端 速度快 服务器内部转换， 可以传参数 response.sendRedirect 是不同的request send后的语句会继续执行，除非return 速度慢 需要到客户端的往返，可以转到任何页面 可以传参数，直接写在url后面 上面的是使用，使用的是相同的request；下面的是使用response.sendRedirect，使用的是不同的request 跳转后的页面也可以传参数：]]></content>
      <categories>
        <category>Jsp</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp&Servlet笔记（三）Cookie，Session,Application和Java Bean]]></title>
    <url>%2F2017%2F11%2F13%2FJSP3%2F</url>
    <content type="text"><![CDATA[本篇介绍的是关于Cookie，Session,Application和Java Bean的一些原理和使用方法。 第十三课 Cookie_1HTTP是无状态的有状态：Server知道Client以前在我这儿做过什么事儿 处理Cookie Http协议的无连接性要求出现一种保存C/S间状态的机制 Cookie：保存到客户端的一个文本文件，与特定客户相关 Cookie以“名-值”对的形式保存数据 创建Cookie：new Cookie(name,value) 可以使用Cookie 的setXXX方法来设定一些相应的值 setName(String name)/getName() setValue(String value)/getValue() setMaxAge(int age)/getMaxAge() 利用HttpServletResponse的addCookie(Cookie)方法将它设置到客户端 利用HttpServletRequest的getCookies()方法来读取客户端的所有Cookie，返回一个Cookie数组 设置Cookie SetCookies.java 读取Cookie ShowCookies.java 1:服务器可以向客户端写内容2:只能是文本内容3:客户端可以阻止服务器写入4:只能拿自己webapp写入的东西5:Cookie分为两种 属于窗口/子窗口（放在内存中的）属于文本(有生命周期的） 6:一个servlet/jsp设置的cookies能够被同一个路径下面或者子路径下面的servlet/jsp读到 (路径 = URL)(路径 != 真实文件路径) 第十四课 Cookie_2SetCookies.java： 1234567891011121314151617181920212223242526272829303132333435363738import java.io.*;import javax.servlet.*;import javax.servlet.http.*;//设置Cookie//1:服务器可以向客户端写内容//2:只能是文本内容//3:客户端可以阻止服务器写入//4:只能拿自己webapp写入的东西//5:Cookie分为两种,第一种：属于窗口/子窗口（放在内存中的），第二种：属于文本(有生命周期的）//6:一个servlet/jsp设置的cookies能够被同一个路径下面或者子路径下面的servlet/jsp读到 (路径 = URL)(路径 != 真实文件路径)public class SetCookies extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; for (int i = 0; i &lt; 3; i++) &#123; // Default maxAge is -1, indicating cookie applies only to current browsing session. Cookie cookie = new Cookie("Session-Cookie-" + i, "Cookie-Value-S" + i); response.addCookie(cookie); cookie = new Cookie("Persistent-Cookie-" + i, "Cookie-Value-P" + i); // Cookie is valid for an hour, regardless of whether user quits browser, reboots computer, or whatever. cookie.setMaxAge(3600); response.addCookie(cookie); &#125; response.setContentType("text/html;charset=gb2312"); PrintWriter out = response.getWriter(); out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;设置Cookie&lt;/title&gt;&lt;/head&gt;" + "&lt;BODY&gt;\n" + "&lt;H1 ALIGN=\"CENTER\"&gt;" + "设置Cookie" + "&lt;/H1&gt;\n" + "6个Cookie\n" + "&lt;A HREF=\"ShowCookies\"&gt;\n" + "查看&lt;/A&gt;.\n" + "&lt;/BODY&gt;&lt;/HTML&gt;"); &#125;&#125; ShowCookies.java 123456789101112131415161718192021222324252627282930313233//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ShowCookies extends HttpServlet &#123; public ShowCookies() &#123; &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=gb2312"); PrintWriter out = response.getWriter(); String title = "Active Cookies"; out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;获取客户端Cookie&lt;/title&gt;&lt;/head&gt;&lt;BODY BGCOLOR=\"#FDF5E6\"&gt;\n&lt;H1 ALIGN=\"CENTER\"&gt;" + title + "&lt;/H1&gt;\n&lt;TABLE BORDER=1 ALIGN=\"CENTER\"&gt;\n&lt;TR BGCOLOR=\"#FFAD00\"&gt;\n &lt;TH&gt;Cookie Name\n &lt;TH&gt;Cookie Value"); Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for(int i = 0; i &lt; cookies.length; ++i) &#123; Cookie cookie = cookies[i]; out.println("&lt;TR&gt;\n &lt;TD&gt;" + cookie.getName() + "&lt;/TD&gt;\n &lt;TD&gt;" + cookie.getValue() + "&lt;/TD&gt;&lt;/TR&gt;\n"); &#125; &#125; out.println("&lt;/TABLE&gt;&lt;/BODY&gt;&lt;/HTML&gt;"); &#125;&#125; 访问设置cookie的页面： 点击超链接，显示出现在的cookie： 然后我们到浏览器查看cookie，发现这六个cookie都是存在的： 第十五课 Cookie_3做一个实验，将浏览器中cookie清理干净，将web.xml中的&lt;url-pattern&gt;/servlet/ShowCookies&lt;/url-pattern&gt;改为：&lt;url-pattern&gt;/ ShowCookies&lt;/url-pattern&gt; tomcat重新reload之后，先访问http://127.0.0.1:8888/test/servlet/SetCookies 再访问http://127.0.0.1:8888/test/ShowCookies 发现页面中没有任何cookie被显示出来 再做第二个实验： 将浏览器中cookie清理干净，将web.xml中的&lt;url-pattern&gt;/ ShowCookies&lt;/url-pattern&gt;改回&lt;url-pattern&gt;/servlet/ShowCookies&lt;/url-pattern&gt; 将&lt;url-pattern&gt;/servlet /SetCookies&lt;/url-pattern&gt;改为&lt;url-pattern&gt;/SetCookies&lt;/url-pattern&gt; 等tomcat重新reload之后，先访问http://127.0.0.1:8888/test/SetCookies再访问：http://127.0.0.1:8888/test/servlet/ShowCookies 发现六个cookie都被显示出来。 结论：一个servlet/jsp设置的cookies能够被同一个路径下面或者子路径下面的servlet/jsp读到 (路径 = URL)(路径 != 真实文件路径) 第十六课. Session_1Session：在某段时间一连串客户端与服务器端的“交易” 一、 我们通过程序SessionInfoServlet.java来演示Session： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import javax.servlet.*;import javax.servlet.http.*;import java.io.*;/** * 用于演示Servlet API中的Session管理机制 */public class SessionInfoServlet extends HttpServlet&#123; /** * Builds an HTML document containing session information and * returns it to the client. */ public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //get current session or, if necessary, create a new one HttpSession mySession = request.getSession(true); //MIME type to return is HTML response.setContentType("text/html"); //get a handle to the output stream PrintWriter out = response.getWriter(); //generate HTML document out.println("&lt;HTML&gt;"); out.println("&lt;HEAD&gt;"); out.println("&lt;TITLE&gt;Session Info Servlet&lt;/TITLE&gt;"); out.println("&lt;/HEAD&gt;"); out.println("&lt;BODY&gt;"); out.println("&lt;H3&gt;Session Information&lt;/H3&gt;"); out.println("New Session: " + mySession.isNew()); out.println("&lt;BR&gt;Session ID: " + mySession.getId()); out.println("&lt;BR&gt;Session Creation Time: " + new java.util.Date(mySession.getCreationTime())); out.println("&lt;BR&gt;Session Last Accessed Time: " + new java.util.Date(mySession.getLastAccessedTime())); out.println("&lt;H3&gt;Request Information&lt;/H3&gt;"); out.println("Session ID from Request: " + request.getRequestedSessionId()); out.println("&lt;BR&gt;Session ID via Cookie: " + request.isRequestedSessionIdFromCookie()); out.println("&lt;BR&gt;Session ID via rewritten URL: " + request.isRequestedSessionIdFromURL()); out.println("&lt;BR&gt;Valid Session ID: " + request.isRequestedSessionIdValid()); out.println("&lt;/BODY&gt;&lt;/HTML&gt;"); out.close(); //close output stream &#125; /** * Returns a brief description of this servlet. * * @return Brief description of servlet */ public String getServletInfo() &#123; return "Servlet returns session information."; &#125;&#125; 配置web.xml文件：123456789&lt;servlet&gt; &lt;servlet-name&gt;SessionInfoServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;SessionInfoServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SessionInfoServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/SessionInfoServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 运行http://127.0.0.1:8888/test/servlet/SessionInfoServlet 得到 再运行：http://127.0.0.1:8888/test/servlet/ShowCookies 可以看到： 发现和上面的Session ID是相同的。 结论：如果浏览器支持Cookie, 创建Session的时候会把SessionID保存在Cookie里 二、设置浏览器，阻止存取cookie运行http://127.0.0.1:8888/test/servlet/SessionInfoServlet 发现每次刷新后，Session ID都在变化，因为cookie没有存取。 第十七课. Session_2上面就是因为把cookie禁掉以后产生的Session ID变化效果，那怎么样解决这个问题呢？ 如果不支持Cookie, 必须自己编程使用URL重写的方式实现Session，用到的方法是：response.encodeURL() 1.转码 2.URL后面加上SessionID 代码实现就是在上面的SessionInfoServlet.java中进行修改，就是将123out.println("&lt;BR&gt;Valid Session ID: " + request.isRequestedSessionIdValid());out.println("&lt;/BODY&gt;&lt;/HTML&gt;"); 改为： 123out.println("&lt;BR&gt;Valid Session ID: " + request.isRequestedSessionIdValid());out.println("&lt;br&gt;&lt;a href=" + response.encodeURL("SessionInfoServlet") + "&gt;refresh&lt;/a&gt;");out.println("&lt;/BODY&gt;&lt;/HTML&gt;"); 这样在每次浏览器进行刷新的时候，URL后面都会跟上一串固定的SessionID: 第十八课. Session_3tomcat目录下的conf目录有一个web.xml，可以在里面对session过期时间进行设置，可以看到我们这里的过期时间是30分钟 管理Session的一些常用方法： getRequestedSessionId()：返回随客户端请求到来的会话ID。可能与当前的会话ID相同，也可能不同。 getSession(boolean isNew)：如果会话已经存在，则返回一个HttpSession，如果不存在并且isNew为true，则会新建一个HttpSession isRequestedSessionIdFromCookie()：当前的Session ID如果是从Cookie获得，为true isRequestedSessionIdFromURL():当前Session ID如果是由URL获得，为true isRequestedSessionIdValid()：如果客户端的会话ID代表的是有效会话，则返回true。否则（比如，会话过期或根本不存在），返回false 第十九课. Session_4跟踪Session代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.*;import javax.servlet.*;import javax.servlet.http.*;import java.net.*;import java.util.*;//Session追踪public class ShowSession extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); PrintWriter out = response.getWriter(); String title = "Session Tracking Example"; HttpSession session = request.getSession(true); String heading; // Use getAttribute instead of getValue in version 2.2. Integer accessCount = (Integer) session.getAttribute("accessCount"); if (accessCount == null) &#123; accessCount = new Integer(0); heading = "Welcome, Newcomer"; &#125; else &#123; heading = "Welcome Back"; accessCount = new Integer(accessCount.intValue() + 1); &#125; // Use setAttribute instead of putValue in version 2.2. session.setAttribute("accessCount", accessCount); out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Session追踪&lt;/title&gt;&lt;/head&gt;" + "&lt;BODY BGCOLOR=\"#FDF5E6\"&gt;\n" + "&lt;H1 ALIGN=\"CENTER\"&gt;" + heading + "&lt;/H1&gt;\n" + "&lt;H2&gt;Information on Your Session:&lt;/H2&gt;\n" + "&lt;TABLE BORDER=1 ALIGN=\"CENTER\"&gt;\n" + "&lt;TR BGCOLOR=\"#FFAD00\"&gt;\n" + " &lt;TH&gt;Info Type&lt;TH&gt;Value\n" + "&lt;TR&gt;\n" + " &lt;TD&gt;ID\n" + " &lt;TD&gt;" + session.getId() + "\n" + "&lt;TR&gt;\n" + " &lt;TD&gt;Creation Time\n" + " &lt;TD&gt;" + new Date(session.getCreationTime()) + "\n" + "&lt;TR&gt;\n" + " &lt;TD&gt;Time of Last Access\n" + " &lt;TD&gt;" + new Date(session.getLastAccessedTime()) + "\n" + "&lt;TR&gt;\n" + " &lt;TD&gt;Number of Previous Accesses\n" + " &lt;TD&gt;" + accessCount + "\n" + "&lt;/TABLE&gt;\n" + "&lt;/BODY&gt;&lt;/HTML&gt;"); &#125; /** Handle GET and POST requests identically. */ public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; HttpSession的常用方法 getAttributeNames()/getAttribute() getCreateTime() getId() getMaxInactiveInterval() invalidate() isNew() setAttribute() setMaxInactivateInterval() Session不像Cookie拥有路径访问的问题 同一个application下的servlet/jsp可以共享同一个session，前提是同一个客户端窗口 证明这个结论，做实验： 修改web.xml，将&lt;url-pattern&gt;/servlet/ShowSession&lt;/url-pattern&gt;改为：&lt;url-pattern&gt;/ShowSession&lt;/url-pattern&gt; 然后访问：http://127.0.0.1:8888/test/servlet/SessionInfoServlet得到页面： 再访问：http://127.0.0.1:8888/test/ShowSession显示页面： 发现和前面的Session ID是相同的，证明了Session不存在路径问题。 第二十课. ApplicationSession是针对于一个客户端的特定的内存区域，而application是针对所有客户端都可以访问的内存区域 每个web application的运行环境，称作一个context(上下文), servlet context是servlet运行时的上下文环境，也就是当前运行的整个webapp，比如我们之前写的webapp/test。 测试Application的代码： 123456789101112131415161718192021222324252627282930313233343536373839import javax.servlet.http.*;import javax.servlet.*;import java.io.*;import java.util.Date;public class TestServletContext extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=gb2312"); PrintWriter out = response.getWriter(); //拿到ServletContext，也就是属于所有客户端的上下文 ServletContext application = this.getServletContext(); Integer accessCount = (Integer) application.getAttribute("accessCount"); //设置访问次数 if (accessCount == null) &#123; accessCount = new Integer(0); &#125; else &#123; accessCount = new Integer(accessCount.intValue() + 1); &#125; // Use setAttribute instead of putValue in version 2.2. application.setAttribute("accessCount", accessCount); out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;Session追踪&lt;/title&gt;&lt;/head&gt;" + "&lt;BODY BGCOLOR=\"#FDF5E6\"&gt;\n" + "&lt;H1 ALIGN=\"CENTER\"&gt;" + accessCount + "\n" + "&lt;/TABLE&gt;\n" + "&lt;/BODY&gt;&lt;/HTML&gt;" + "&lt;/H1&gt;\n"); &#125;&#125; 修改对应配置，访问：http://127.0.0.1:8888/test/TestServletContext 发现当前页码显示0现在关闭这个浏览器，换一个浏览器，再访问相同网址，发现页面显示的访问次数加了1，说明application是整个web app所共享的，有点类似于静态变量。 总结一下application： 用于保存整个WebApplication的生命周期内都可以访问的数据 在API中表现为ServletContext 通过HttpServlet的getServletContext方法可以拿到 通过ServletContext的 get / setAttribute方法取得/设置相关属性 TestServletContext.java Servlet类本身位于包中，例如：com.bjsxt.servlet.HelloWorldServlet，我们需要在classes将这个.class的完整目录创建出来： 对应的配置文件中需要改为： 第二十一课. 数据库处理数据库处理以及在Servlet中使用Bean 广义javabean = 普通java类 狭义javabean = 符合Sun JavaBean标准的类 在Servlet中使用Bean和在通常程序中使用Bean类似 属性名称第一个字母必须小写，一般private，比如：private productId 一般具有getters and setters 要具有一个参数为空的构造方法 但Bean不应具有GUI表现 一般是用来实现某一业务逻辑或取得特定结果 示例: 连接数据库– ShowRs.java– ShowRsUseBean.java 首先我们来看一下连接Servlet数据库的操作，ShowRs.java代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//import java.io.IOException;import java.io.PrintWriter;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ShowRs extends HttpServlet &#123; public ShowRs() &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; response.setContentType("text/html"); response.setCharacterEncoding("gb2312"); PrintWriter out = response.getWriter(); out.println("&lt;table border=1&gt;"); out.println("&lt;tr&gt;&lt;td&gt;Content:&lt;/td&gt;&lt;/tr&gt;"); try &#123; Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost/mydata?user=root&amp;password=09129421"); stmt = conn.createStatement(); rs = stmt.executeQuery("select * from article"); while(rs.next()) &#123; out.println("&lt;tr&gt;"); out.println("&lt;td&gt;" + rs.getString("title") + "&lt;/td&gt;"); out.println("&lt;/tr&gt;"); &#125; out.println("&lt;/table&gt;"); &#125; catch (ClassNotFoundException var18) &#123; var18.printStackTrace(); &#125; catch (SQLException var19) &#123; var19.printStackTrace(); &#125; finally &#123; try &#123; if (rs != null) &#123; rs.close(); rs = null; &#125; if (stmt != null) &#123; stmt.close(); stmt = null; &#125; if (conn != null) &#123; conn.close(); conn = null; &#125; &#125; catch (SQLException var17) &#123; var17.printStackTrace(); &#125; &#125; &#125;&#125; 将这个文件的.class拷贝到classes目录下，在web.xml进行配置，访问：http://127.0.0.1:8888/test/servlet/ShowRs发现里面没有任何数据显示。这时怀疑是不是数据库没有数据，于是执行命令行操作：mysql -u root -p进行mysql，输入我们的密码，执行use mydata切换到我们的数据库，进行查询操作：select * from article;发现显示里有数据： 这时我们再查看tomcat后台，发现报错： 这时考虑要不要把mysql的连接驱动jar包导入到项目，思考后发现不可以，因为我们的servlet运行在tomcat上，所以我们的解决办法就是在WEB-INF下创建一个lib目录，然后把我们的connector驱动jar包放到lib目录下： 重启tomcat，再次访问http://127.0.0.1:8888/test/servlet/ShowRs发现Servlet成功将数据库中的数据取出来并显示在前端页面上：大功告成！ 第二十三课. UseBeanDB.java：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.sql.*;public class DB &#123; public static Connection getConn() &#123; Connection conn = null; try &#123; Class.forName("com.mysql.jdbc.Driver"); conn = DriverManager.getConnection("jdbc:mysql://localhost/mydata?user=root&amp;password=09129421"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static Statement getStatement(Connection conn) &#123; Statement stmt = null; try &#123; if(conn != null) &#123; stmt = conn.createStatement(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return stmt; &#125;// public static ResultSet getResultSet(Connection conn, String sql)&#123;// Statement stmt = getStatement(conn);// ResultSet rs = getResultSet(stmt, sql);// close(stmt);//// return rs;// &#125; public static ResultSet getResultSet(Statement stmt, String sql) &#123; ResultSet rs = null; try &#123; if(stmt != null) &#123; rs = stmt.executeQuery(sql); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return rs; &#125; public static void close(Connection conn) &#123; try &#123; if(conn != null) &#123; conn.close(); conn = null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(Statement stmt) &#123; try &#123; if(stmt != null) &#123; stmt.close(); stmt = null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; public static void close(ResultSet rs) &#123; try &#123; if(rs != null) &#123; rs.close(); rs = null; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ShowRsUseBean.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445import javax.servlet.*;import javax.servlet.http.*;import java.io.*;import java.sql.*;public class ShowRsUseBean extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html"); response.setCharacterEncoding("gb2312"); PrintWriter out = response.getWriter(); out.println("&lt;table border=1&gt;"); out.println("&lt;tr&gt;&lt;td&gt;Content:&lt;/td&gt;&lt;/tr&gt;"); Connection conn = DB.getConn(); Statement stmt = DB.getStatement(conn); ResultSet rs = DB.getResultSet(stmt, "select * from article");// String sql = "select * from t";// ResultSet rs = DB.getResultSet(stmt, sql); try &#123; while (rs.next()) &#123; out.println("&lt;tr&gt;"); out.println("&lt;td&gt;" + rs.getString("title") + "&lt;/td&gt;"); out.println("&lt;/tr&gt;"); &#125; out.println("&lt;/table&gt;"); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; DB.close(rs); DB.close(stmt); DB.close(conn); &#125; &#125;&#125; 将这两个java文件生成的.class复制到tomcat的classes目录下，然后进行配置部署，访问地址：http://127.0.0.1:8888/test/servlet/ShowRsUseBean就可以成功读取数据库的内容并显示在前端页面了：]]></content>
      <categories>
        <category>Jsp</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 448.Find All Numbers Disappeared in an Array(找没有的数)]]></title>
    <url>%2F2017%2F11%2F12%2Fleetcode448%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/ 一开始的想法是，另外开辟一个数组，将nums原来的数放到新数组对应下标的位置上，然后看这个新数组哪个位置是0，就把它加到返回列表中。AC代码如下：123456789101112131415class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int[] temp = new int[nums.length]; for(int i = 0; i &lt; nums.length; i++) temp[nums[i]-1] = 1; for(int i = 0; i &lt; temp.length; i++)&#123; if(temp[i] == 0) res.add(i+1); &#125; return res; &#125;&#125; 后来改进想法，不再使用空间，思路为：1、第一轮将每个数字对应的那个位置的数字变成负值（因为所有数都是正的，这么做不影响后续）2、第二轮，统计那些没有变成负值的，这些就是没有出现过的数 AC代码为：1234567891011121314151617public class Solution &#123; public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int n = nums.length; //第一轮，将所有出现过的值对应的位置变为负数 for(int i=0;i&lt;n;i++)&#123; int index = Math.abs(nums[i]) - 1; nums[index] = Math.abs(nums[index]) * -1; &#125; //第二轮，统计不为负数的（就是没出现过的） for(int i=0;i&lt;n;i++)&#123; if(nums[i] &gt; 0) res.add(i+1); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（十二） 通过异常处理错误]]></title>
    <url>%2F2017%2F11%2F12%2FThinkingInJava12%2F</url>
    <content type="text"><![CDATA[Java的基本理念是“结构不佳的代码不能运行” 发现错误的理想时机是在编译阶段。然而，编译阶段并不能找出所有错误。 12.1 概念通过异常处理错误，往往可以降低错误处理代码的复杂度。可以在多处抛出异常，而只在一个地方进行处理，不仅节省代码，而且把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。 12.2 基本异常异常情形是指阻止当前方法或作用域继续执行的问题。把异常情形与普通问题相区分很重要，所谓的普通问题是指，在当前环境下能够得到足够的信息，总能处理这个错误。而对于异常情形，就不能继续下去了，因为在当前环境下无法获得必要的信息来解决问题。你所能做的就是从当前环境跳出，并且把问题提交给上一级环境。这就是抛出异常时所发生的事情。 当异常抛出时，有几件事会随之发生。首先，同Java中其他对象的创建一样，将使用new在堆上创建异常对象。然后，当前的执行路径（它不能继续执行下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务就是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。 如果程序的某部分失败了，异常将”恢复“到程序中某个已知的稳定点上。 12.2.1 异常参数所有标准异常类都有两个构造器；一个是默认构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象构造器。例如：throw new NullPointerException(“t = null”); 尽管返回的异常对象其类型通常与方法设计的返回的类型不同，但从效果来看，就像是从方法“返回”的。可以简单地把异常处理看成一种不同的返回机制。另外还能用抛出异常的方式从当前作用域退出。在这两种情况下，将会返回一个异常对象，然后退出方法或作用域。 12.3 捕获异常要明白异常是如何被捕获的，必须首先理解监控区域的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。 12.3.2 异常处理程序异常处理程序紧跟在try块之后，以关键字catch表示。每个catch子句看起来就像是接收一个且仅接受一个特殊类型的参数的方法。可以在处理程序内部使用标识符，这与方法参数的使用很相似。异常处理程序必须紧跟在try块之后。当异常被抛出时，异常处理机制将负责搜索寻找参数与异常类型相匹配的第一个处理程序。终止与恢复 异常处理理论上有两种基本模型。Java支持终止模型（它是Java和C++所支持的模型）。在这种模型中，将假设错误非常关键，一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。另一种称为恢复模型。意思是在异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。如果想要用Java实现类似的恢复行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。或者，把try块放在while循环里，这样就不断地进入try快，直到得到满意的结果。虽然恢复模型开始显得很吸引人，但不是很实用。其中的主要原因可能是它所导致的耦合，恢复性的处理程序需要了解异常抛出地点，这势必要包含依赖于抛出未知的非通用性代码。这增加了代码编写和维护的困难。 12.4 创建自定义异常要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。建立新的异常类型最简单的方法就是让编译器为你产生默认构造器，所以这几乎不用写多少代码。异常的名称应该可以望文生义。 12.4.1 异常与记录日志可以使用java.util.logging工具将输出记录到日志中。这是一种很好的做法。我们需要捕获和记录其他人编写的异常，因此我们必须在异常处理程序中生成日志消息。 12.5 异常说明异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后。代码必须与异常说明一致。如果方法里的代码产生了异常却没有处理，编译器会发现这个问题并提醒你：要么处理异常，要么就在异常说明中表明此方法产生异常。通过这种自顶向下强制执行的异常说明机制，Java在编译时就可以保证一定水平的异常正确性。 不过还是有个能“作弊”的地方：可以声明方法抛出异常，实际上却不抛出。编译器相信了这个声明，并强制此方法的用户像真的抛出异常那样使用这个方法。这样做的好处是，为异常先占个位子，以后就可以抛出这种异常而不用修改已有的代码。在定义抽象基类和接口时，这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常。这种在编译时被强制检查的异常称为被检查的异常。 12.6 捕获所有异常通过捕获异常类型的基类Exception来捕获所有类型的异常，这种捕获所有异常的代码，最好把它放在处理程序列表的末尾，以防止它抢在其他处理程序之前先把异常捕获了 打印Throwable和Throwable的调用栈轨迹。调用栈显示了“把你带到异常抛出地点”的方法调用序列。 e.getMessage()-&gt;e.getLocalizedMessage()-&gt;e.printStackTrace()上面方法，每一个都是前面的超集，可以提供比前一个更多的信息 12.6.1 栈轨迹printStackTrace()方法所提供的信息可以通过getStackTrace()方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每一个元素都表示栈中的一帧。元素0是栈顶元素，并且是调用序列中最后一个方法调用（这个Throwable被创建和抛出之处）。 12.6.2 重新抛出异常有时希望把刚捕获的异常重新抛出，尤其是在使用Exception捕获所有异常的时候。重新抛出异常会把异常抛给上一级环境中的异常处理程序，同一个try块后续catch子句将被忽略此外，异常对象的所有信息都得以保持，所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息。 如果只是把当前对象重新抛出，那么printStackTrace()方法将显示原来异常抛出点的调用信息，而并非重新抛出点的信息。想要更新这个信息，可以调用fillInStackTrack()方法，这将返回一个Throwable对象，他是通过把当前调用栈信息填入原来那个异常对象而建立的。 有可能在捕获异常之后抛出另一种异常。这么做的话，得到的效果类似于使用fillInStackTrace()，有关原来异常发生点的信息会丢失，剩下的是新的抛出点有关的信息。 12.6.3 异常链常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。所有Throwable的子类在构造器中都可以接受一个cause对象作为参数。这个cause就用来表示原始异常，这样通过把原始异常传递给新的异常，就使得即使在当前位置创建并抛出新的异常，也能通过这个异常链追踪到异常最初发生的位置。在Throwable的子类中，只有三种基本的异常类提供了带cause参数的构造器。它们是Error，Exception和RuntimeException。如果要把其他类型的异常链接起来，应该使用initCause()方法而不是构造器。 例子： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ChainTest &#123; /** * test1():抛出“喝大了”异常 * test2():调用test1()，捕获喝大了异常，并且包装成运行时异常，继续抛出 * main方法中，调用test2()，尝试捕获test2()方法异常 * @param args */ public class DrunkException extends Exception&#123; public DrunkException()&#123;&#125; public DrunkException(String message)&#123; super(message); &#125; &#125; public static void main(String[] args) &#123; ChainTest ct = new ChainTest(); try &#123; ct.test2(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; public void test1() throws DrunkException&#123; throw new DrunkException("喝车别开酒"); &#125; public void test2()&#123; try &#123; test1(); &#125;catch (DrunkException e)&#123;// RuntimeException newExc = new RuntimeException(e); RuntimeException newExc = new RuntimeException("司机一滴酒，亲人两行泪"); newExc.initCause(e); throw newExc; &#125; &#125;&#125; 输出结果：1234567java.lang.RuntimeException: 司机一滴酒，亲人两行泪 at ChainTest.test2(ChainTest.java:35) at ChainTest.main(ChainTest.java:20)Caused by: ChainTest$DrunkException: 喝车别开酒 at ChainTest.test1(ChainTest.java:27) at ChainTest.test2(ChainTest.java:32) ... 1 more 当然，上面的例子也可以直接使用被注释掉的RuntimeException对异常进行包装，效果和用initCause（）方法一样。 12.7 Java标准异常Throwable这个Java类被用来表示任何可以作为异常被抛出的类。Throwable对象可分为两种类型（指从Throwable继承而得到的类型）：Error用来表示编译时和系统错误（除特殊情况外，一般不用你关心）；Exception是可以被抛出的基本类型，在Java类库、用户方法以及运行时故障中都可以抛出Exception型异常。 12.7.1 特例：RuntimeExceptionRuntimeException是Java的标准运行时检测的一部分。它们会被Java虚拟机抛出，所以不必在异常说明中把它们列出来。它们被称为“不受检查异常”。这种异常属于错误，将被自动捕获。 注意，只能在代码中忽略RuntimeException（及其子类）类型的异常，其他类型异常的处理都是由编译器强制实施的。究其原因，RuntimeException代表的是编程错误： 无法预料的错误 作为程序员，应该在代码中进行检查的错误 12.8 使用finally进行清理对于一些代码，可能会希望无论try块中的异常是否抛出，它们都能得到执行。这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成）。为了达到这个效果，可以在异常处理程序后面加上finally子句。 12.8.1 finally用来做什么对于没有垃圾回收和析构调用机制的语言来说，finally非常重要。 当要把除内存之外的资源恢复到他们的初始状态时，就要用到finally子句。这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关。 在异常没有被当前的异常处理程序捕获的情况下，异常处理机制也会在跳到更高一层的异常处理程序之前，执行finally子句。 当涉及break和continue语句的时候，finally子句也会得到执行。请注意，如果把finally子句和带标签的break和continue配合使用，在Java里就没必要使用goto语句了。 12.8.2 在return中使用finally因为finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍旧会执行。无论在哪里return，finally都总是会执行。 123456try &#123;&#125; catch (Exception) &#123; return;&#125; finally &#123; //这里总会执行&#125; 12.8.3 缺憾：异常丢失遗憾的是，Java的异常实现也有瑕疵。异常作为程序出错的标志，绝不应该被忽略，但它还是有可能被轻易地忽略。用某些特殊的方式使用finally子句，就会发生这种情况。 1234try&#123;&#125; finally &#123; return;&#125; 12.9 异常的限制当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常（可以不抛出异常，但是如果抛出，必须是基类方法的声明的异常)。这个限制很有用，因为这意味着，当基类使用的代码应用到派生类对象的时候，一样能够工作（当然，这是面向对象的基本概念），异常也不例外。异常限制对构造器不起作用。派生类构造器的异常说明必须包含基类构造器的异常说明（应该是必须包含基类默认构造器的异常说明，因为基类默认构造器会被默认调用，如果显示的调用其它基类构造器，就需要声明调用的基类构造器的异常了）。派生类构造器不能捕获基类构造器的异常（不能通过try-catch捕获基类抛出的异常，必须使用异常声明）。 12.10 构造器有一点很重要，即你要时刻询问自己“如果异常发生了，所有东西能被正确的清理吗“？尽管大多数情况下是非常安全的，但涉及构造器时，问题就出现了。构造器会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。如果在构造器内抛出了异常，这清理行为也许就不能正常工作。这意味着在编写构造器是要格外的小心。 读者也许会认为使用finally就可以解决问题。但问题并非如此简单，因为finally会每次都执行清理代码。如果构造器在执行过程中半途而废，也许该对象的某些部分还没有被成功创建，而这些部分在finally子句中确是要被清理的。 对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的try。这种通用的清理习惯在构造器不抛出任何异常时也应该运用，其基本规则是：在创建需要清理的对象之后，立即进入一个try-finally语句块。 代码：12345678910111213141516171819202122public class Cleanup &#123; public static void main(String[] args) &#123; try &#123; InputFile in = new InputFile("Cleanup.java"); try &#123; String s; int i = 1; while((s = in.getLine()) != null) ; // Perform line-by-line processing here... &#125; catch(Exception e) &#123; System.out.println("Caught Exception in main"); e.printStackTrace(System.out); &#125; finally &#123; in.dispose(); &#125; &#125; catch(Exception e) &#123; System.out.println("InputFile construction failed"); &#125; &#125;&#125; /* Output:dispose() successful*///:~ 12.11 异常匹配抛出异常的时候，异常处理系统会按照代码的书写顺序找出”最近“的处理程序。查找的时候不要求抛出的异常同处理程序所声明的异常完全匹配。派生类的对象也可以匹配其基类的处理程序。如果把捕获基类的catch子句放在最前面，就会把派生类的异常全给”屏蔽“掉。 12.12 其他可选方式异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离。 “被检查的异常”使这个问题变得复杂，因为它们强制你在可能还没准备好处理错误的时候被迫加上catch子句，这就导致了*吞食则有害*的问题 有时候不知道该如何处理”被检查的异常”，可以采取下面的措施 把异常从main传给控制台 把被检查的异常包装进RuntimeException里面 直接创建自己RuntimeException的子类。 12.13 异常使用指南 应该在下列情况下使用异常： 在恰当的级别处理问题（在知道该如何处理的情况下才捕获异常）。 解决问题并且重新调用产生异常的方法。 进行少许修补，然后绕过异常发生的地方继续执行 用别的数据进行计算，以代替方法预计会返回的值。 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。 终止程序。 进行简化。 让类库和程序更安全]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 258.Add Digits（数位相加）]]></title>
    <url>%2F2017%2F11%2F11%2Fleetcode258%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/add-digits/description/ 这道题最简单的办法，就是将所有位置上的数加起来，判断是不是大于9，如果是，再循环一次，直到小于等于9，返回。AC代码如下：1234567891011121314class Solution &#123; public int addDigits(int num) &#123; int sum = 0; while(num &gt; 9)&#123; while(num &gt; 0)&#123; sum += num % 10; num = num/10; &#125; num = sum; sum = 0; &#125; return num; &#125;&#125; 这道题其实还有更简单的办法，因为这道题其实是一道数学题。即数字根（Digital root）,公式为： AC代码为：123456789class Solution &#123;public: int floor(int x) &#123; return (x - 1) / 9; &#125; int addDigits(int num) &#123; return num - 9 * floor(num); &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数学题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 677.Beautiful Arrangement II(优雅排序2)]]></title>
    <url>%2F2017%2F11%2F11%2Fleetcode667%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/beautiful-arrangement-ii/description/ 一开始想到的是用回溯法来构造不同的序列，然后对这个序列进行判断，看看是否满足规则。这里用到了全排列的递归思想： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permutations(int[] nums) &#123; //ans用于存放全排列后的所有数组 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); //从0开始进行排列 permute(ans, nums, 0); return ans; &#125; private void permute(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans, int[] nums, int start) &#123; //如果已经到了数组的最后一个元素，前面的元素已经排好，输出。 if (start &gt;= nums.length) &#123; ArrayList&lt;Integer&gt; cur = new ArrayList&lt;Integer&gt;(); for (int x : nums) cur.add(x); ans.add(cur); &#125; else &#123; //把第一个元素分别与后面的元素进行交换，递归的调用其子数组进行排序 for (int i = start; i &lt; nums.length; i++) &#123; swap(nums, start, i); permute(ans, nums, start+1); swap(nums, start, i); //子数组排序返回后要将第一个元素交换回来。 //如果不交换回来会出错，比如说第一次1、2交换，第一个位置为2，子数组排序返回后如果不将1、2 //交换回来第二次交换的时候就会将2、3交换，因此必须将1、2交换使1还是在第一个位置 &#125; &#125; &#125; //两个数的交换 private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; private int numUniqueDiffs(ArrayList&lt;Integer&gt; arr) &#123; boolean[] seen = new boolean[arr.size()]; int ans = 0; for (int i = 0; i &lt; arr.size() - 1; i++) &#123; int delta = Math.abs(arr.get(i) - arr.get(i+1)); if (!seen[delta]) &#123; ans++; seen[delta] = true; &#125; &#125; return ans; &#125; public int[] constructArray(int n, int k) &#123; int[] nums = new int[n]; //先创建一个升序排列的递增序列 for (int i = 0; i &lt; n; i++) &#123; nums[i] = i+1; &#125; //将nums进行全排列，然后依次判断每一个排列 for (ArrayList&lt;Integer&gt; cand : permutations(nums)) &#123; //判断是符合标准的 if (numUniqueDiffs(cand) == k) &#123; int[] ans = new int[n]; int i = 0; for (int x : cand) ans[i++] = x; return ans; &#125; &#125; return null; &#125;&#125; 后来发现这个方法太暴力，就开始发掘其中的规律。发现这个题是一个很简单的规律题首先我们确定的一点：元素差最多的个数是n-1个，这个n-1的构成也很容易发现，较大的数和较小的数交替形成的序列就满足要求。例如，我们假设n= 6，k = 5，那么这个序列就是 6 1 5 2 4 3 形成的k个元素差为： 5 4 3 2 1 （反向也是可以的 即 1 6 2 5 3 4）若k不等于n-1，我们只需要按上述规律形成满足k-1的序列，剩余序列按递减序即可（剩余的差值都为1）。 AC代码为：123456789101112131415161718192021222324class Solution &#123; public int[] constructArray(int n, int k) &#123; int[] res = new int[n]; int cur = 1; int sign = 1; res[0] = 1; int pos = 1; for(int i = k; i &gt; 0; i--)&#123; res[pos] = res[pos - 1] + sign* i; sign = sign * (-1); pos ++; &#125; for( ; pos &lt; n; pos ++)&#123; res[pos] = pos + 1; &#125; return res; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp&Servlet笔记（二）Servlet初步]]></title>
    <url>%2F2017%2F11%2F10%2FJSP2%2F</url>
    <content type="text"><![CDATA[本篇介绍的是Servlet的一些基本原理和用法。 第七课. servlet_1创建一个Project，起名叫TestServlet，在这个工程中添加servlet-api.jar包： 在src下创建Test.java和HelloWorldServlet.java 第八课. servlet_2 GenericServlet是所有Servlet的鼻祖 用于HTTP的Servlet编程都通过继承 javax.servlet.http.HttpServlet 实现 请求处理方法：(分别对应http协议的7种请求） doGet 响应Get请求，常用 doPost 响应Post请求，常用 doPut 用于http1.1协议 doDelete 用于http1.1协议 doHead 仅响应Get请求的头部。 doOptions 用于http1.1协议 doTrace 用于http1.1协议 测试代码（HelloWorldServlet.java）：1234567891011121314import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloWorldServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //只要别人访问我的方法，我就打印doGet System.out.println("doGet"); &#125;&#125; 其中，request封装了客户端给servlet的请求，response封装了servlet给客户端的响应。 第九课. servlet_3servlet是被容器调用，即被tomcat调用 为了让他在被tomcat调用，我们需要在WEB-INF下创建classes目录，然后把我们刚刚写好的HelloWorldServlet进行编译，把编译后的.class文件放到WEB-INF/classes目录下，然后在WEB-INF目录外的web.xml中进行相应的配置，配置如下： 12345678910111213&lt;!--servlet可以随便起，不过servlet-class必须是放在WEB-INF下 的classes目录中的servlet编译好的.class文件--&gt; &lt;servlet&gt; &lt;servlet-name&gt;HW&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorldServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet-name必须和上面一致，url-pattern是指在url中敲什 么内容才会调用servlet,url永远以斜杠开头--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HW&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorldServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 调用过程是：url/url-pattern --&gt;server-name(HW)--&gt;server-class(HelloWorldServlet)，就完成了从url到servlet的调用。servlet就用doGet方法对客户端进行响应。 访问http://localhost:8888/test/HelloWorldServlet可以在tomcat后台看到doGet字样，表示成功。 我们再对客户端做一些响应处理，修改java文件：123456789101112131415import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException;public class HelloWorldServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //只要别人访问我的方法，我就打印doGet System.out.println("doGet"); response.getWriter().write("&lt;a href='http://www.baidu.com'&gt;go&lt;/a&gt;"); &#125;&#125; 重新编译，将生成的.class文件覆盖之前的WEB-INF/classes下的.class，然后再重启tomcat，在地址框重新输入：http://localhost:8888/test/HelloWorldServlet可以在前台页面发现go这样的超链接，点击就进入百度网页。 第十课. servlet_4测试servlet生命周期代码（TestLifeCycleServlet.java）：123456789101112131415161718192021222324252627import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class TestLifeCycleServlet extends HttpServlet &#123; public TestLifeCycleServlet()&#123; System.out.println("constructed"); &#125; @Override public void destroy() &#123; System.out.println("destroy"); &#125; @Override public void init(ServletConfig config) throws ServletException &#123; System.out.println("init"); &#125; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("doGet"); &#125;&#125; 最后在tomcat中输出是： constructed init 访问网址时输出： doGet tomcat关闭时输出： destroy Servlet生命全过程： 加载 ClassLoader 实例化 new 初始化 init(ServletConfig) 处理请求 service doGet doPost 退出服务 destroy() 只有一个对象 API中的过程：12345678init()//只执行一次， 第一次初始化的时候public void init(ServletConfig config) throws ServletException service()public void service(ServletRequest req, ServletResponse res) throws ServletException, java.io.IOException destroy()//webapp 退出的时候public void destroy() 在123public void init(ServletConfig config) throws ServletException &#123; System.out.println("init");&#125; 中，ServletConfig保存了对Servlet的配置 第十一课. servlet_5在tomcat的webapps/test目录下，加入ThreeParams.htm文件：1234567891011121314151617181920212223242526272829&lt;form id="forml" name="forml" method="get" action="servlet/ThreeParams"&gt; &lt;table width="343" border="1"&gt; &lt;tr&gt; &lt;td width="92"&gt;param1&lt;/td&gt; &lt;td width="94"&gt; &lt;input type="text" name="param1" id="param1" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;param2&lt;/td&gt; &lt;td&gt;&lt;label&gt; &lt;input type="text" name="param2" id="param2" /&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;param3&lt;/td&gt; &lt;td&gt; &lt;input type="text" name="param3" id="param3" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt;&lt;label&gt; &lt;input type="submit" value="提交" /&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; 启动tomcat服务器，在地址栏输入：http://127.0.0.1:8888/test/ThreeParams.htm就会进入这个文件的显示网页。然后点击提交，由于action=&quot;servlet/ThreeParams&quot;，所以地址在就转变为：http://127.0.0.1:8888/test/servlet/ThreeParams?param1=&amp;param2=&amp;param3= 然而发现，这个时候出现404错误。那么怎么解决这个问题呢？ 现将在idea中的src下添加ThreeParams.java文件，该文件为： 123456789101112131415161718192021222324252627282930313233343536import javax.servlet.*;import javax.servlet.http.*;import java.io.*;public class ThreeParams extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=GBK"); //解决post方式提交内容的乱码 //一定要写在存取第一个参数之前 request.setCharacterEncoding("GBK"); //解决get方式乱码问题：--&gt;URIEncoding="GBK" //拿到request中的参数对应的值 PrintWriter out = response.getWriter(); out.println(request.getParameter("param1")); out.println("&lt;br&gt;"); out.println(request.getParameter("param2")); out.println("&lt;br&gt;"); out.println(request.getParameter("param3")); out.println("&lt;br&gt;"); System.out.println("in doGet"); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("in doPost"); doGet(request, response); &#125;&#125; 对这个java文件进行编译，得到了ThreeParams.class文件，将这个二进制文件拷贝到tomcat下的test/WEB-INF/classes目录下，并且在web.xml中对这个.class进行配置： 123456789&lt;servlet&gt; &lt;servlet-name&gt;ThreeParams&lt;/servlet-name&gt; &lt;servlet-class&gt;ThreeParams&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;ThreeParams&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ThreeParams&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 一定要注意上面的url-patter是/servlet/ThreeParams，因为之前表格提交后指向的路径前面有一个/servlet 然后reload一下tomcat，再重新刷新之前的页面，在表格中填入三个参数，就可以得到这三个参数在页面中的显示了。 doGet方法处理html中action的GET请求，而doPost方法则是处理html中action的POST的请求。我们这里选择调用在doPost方法中调用doGet方法，并打印一句话来表示doPost已经执行： 第十二课. 通过request读取所有参数在tomcat的webapps/test目录下，加入ShowParameters.htm文件： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;HTML&gt;&lt;HEAD&gt; &lt;TITLE&gt;A Sample FORM using POST&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY BGCOLOR="#FDF5E6"&gt;&lt;H1 ALIGN="CENTER"&gt;A Sample FORM using POST&lt;/H1&gt;&lt;FORM ACTION="servlet/ShowParameters" METHOD="get"&gt; Item Number: &lt;INPUT TYPE="TEXT" NAME="itemNum"&gt;&lt;BR&gt; Quantity: &lt;INPUT TYPE="TEXT" NAME="quantity"&gt;&lt;BR&gt; Price Each: &lt;INPUT TYPE="TEXT" NAME="price" VALUE="$"&gt;&lt;BR&gt; &lt;HR&gt; First Name: &lt;INPUT TYPE="TEXT" NAME="firstName"&gt;&lt;BR&gt; Last Name: &lt;INPUT TYPE="TEXT" NAME="lastName"&gt;&lt;BR&gt; Middle Initial: &lt;INPUT TYPE="TEXT" NAME="initial"&gt;&lt;BR&gt; Shipping Address: &lt;TEXTAREA NAME="address" ROWS=3 COLS=40&gt;&lt;/TEXTAREA&gt;&lt;BR&gt; Credit Card:&lt;BR&gt; &amp;nbsp;&amp;nbsp;&lt;INPUT TYPE="RADIO" NAME="cardType" VALUE="Visa"&gt;Visa&lt;BR&gt; &amp;nbsp;&amp;nbsp;&lt;INPUT TYPE="RADIO" NAME="cardType" VALUE="Master Card"&gt;Master Card&lt;BR&gt; &amp;nbsp;&amp;nbsp;&lt;INPUT TYPE="RADIO" NAME="cardType" VALUE="Amex"&gt;American Express&lt;BR&gt; &amp;nbsp;&amp;nbsp;&lt;INPUT TYPE="RADIO" NAME="cardType" VALUE="Discover"&gt;Discover&lt;BR&gt; &amp;nbsp;&amp;nbsp;&lt;INPUT TYPE="RADIO" NAME="cardType" VALUE="Java SmartCard"&gt;Java SmartCard&lt;BR&gt; Credit Card Number: &lt;INPUT TYPE="PASSWORD" NAME="cardNum"&gt;&lt;BR&gt; Repeat Credit Card Number: &lt;INPUT TYPE="PASSWORD" NAME="cardNum"&gt;&lt;BR&gt;&lt;BR&gt; &lt;CENTER&gt; &lt;INPUT TYPE="SUBMIT" VALUE="Submit Order"&gt; &lt;/CENTER&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt; 然后在src目录下添加ShowParameters.java ：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.*;import javax.servlet.*;import javax.servlet.http.*;import java.util.*;//获取所有的参数public class ShowParameters extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=gb2312"); PrintWriter out = response.getWriter(); String title = "Reading All Request Parameters"; out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;读取所有参数&lt;/title&gt;&lt;/head&gt;" + "&lt;BODY BGCOLOR='#FDF5E6'&gt;\n" + "&lt;H1 ALIGN=CENTER&gt;" + title + "&lt;/H1&gt;\n" + "&lt;TABLE BORDER=1 ALIGN=CENTER&gt;\n" + "&lt;TR BGCOLOR=\"#FFAD00\"&gt;\n" + "&lt;TH&gt;Parameter Name&lt;TH&gt;Parameter Value(s)"); //取到request里面所有的参数 Enumeration paramNames = request.getParameterNames(); //对参数一次遍历，相当于迭代器 while (paramNames.hasMoreElements()) &#123; String paramName = (String) paramNames.nextElement(); out.print("&lt;TR&gt;&lt;TD&gt;" + paramName + "\n&lt;TD&gt;"); String[] paramValues = request.getParameterValues(paramName); if (paramValues.length == 1) &#123; String paramValue = paramValues[0]; //如果没有值，打印No Value if (paramValue.length() == 0) out.println("&lt;I&gt;No Value&lt;/I&gt;"); else out.println(paramValue); &#125; else &#123; //依次打印参数值 out.println("&lt;UL&gt;"); for (int i = 0; i &lt; paramValues.length; i++) &#123; out.println("&lt;LI&gt;" + paramValues[i]); &#125; out.println("&lt;/UL&gt;"); &#125; &#125; out.println("&lt;/TABLE&gt;\n&lt;/BODY&gt;&lt;/HTML&gt;"); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 将编译后的ShowParameters.class放到test/WEB-INF/classes下面，在web.xml进行配置：123456789&lt;servlet&gt; &lt;servlet-name&gt;ShowParameters&lt;/servlet-name&gt; &lt;servlet-class&gt;ShowParameters&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ShowParameters&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ShowParameters&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 再次重启tomcat，访问地址：http://127.0.0.1:8888/test/ShowParametersForm.htm可以得到如下页面： 提交之后就转变到servlet处理后的页面： 由于ShowParameters.java中对参数读取采取的是：Enumeration paramNames = request.getParameterNames();而枚举类已经比较过时，所以现在转换为采用map的读取方式，key是参数名，是String类型，value是参数值，是一个String数组，这样就可以采取迭代器方式进行读取。 程序为ShowParametersMap.java： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*;import javax.servlet.*;import javax.servlet.http.*;import java.util.*;//获取所有的参数public class ShowParametersMap extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=gb2312"); PrintWriter out = response.getWriter(); String title = "Reading All Request Parameters"; out.println("&lt;html&gt;&lt;head&gt;&lt;title&gt;读取所有参数&lt;/title&gt;&lt;/head&gt;" + "&lt;BODY BGCOLOR='#FDF5E6'&gt;\n" + "&lt;H1 ALIGN=CENTER&gt;" + title + "&lt;/H1&gt;\n" + "&lt;TABLE BORDER=1 ALIGN=CENTER&gt;\n" + "&lt;TR BGCOLOR=\"#FFAD00\"&gt;\n" + "&lt;TH&gt;Parameter Name&lt;TH&gt;Parameter Value(s)"); Map&lt;String, String[]&gt; paramMap = request.getParameterMap(); Set&lt;Map.Entry&lt;String, String[]&gt;&gt; entries = paramMap.entrySet(); for(Iterator&lt;Map.Entry&lt;String, String[]&gt;&gt; it = entries.iterator(); it.hasNext(); ) &#123; Map.Entry&lt;String, String[]&gt; entry = it.next(); String paramName = entry.getKey(); out.print("&lt;TR&gt;&lt;TD&gt;" + paramName + "\n&lt;TD&gt;"); String[] paramValues = entry.getValue(); if (paramValues.length == 1) &#123; String paramValue = paramValues[0]; if (paramValue.length() == 0) out.println("&lt;I&gt;No Value&lt;/I&gt;"); else out.println(paramValue); &#125; else &#123; out.println("&lt;UL&gt;"); for (int i = 0; i &lt; paramValues.length; i++) &#123; out.println("&lt;LI&gt;" + paramValues[i]); &#125; out.println("&lt;/UL&gt;"); &#125; &#125; out.println("&lt;/TABLE&gt;\n&lt;/BODY&gt;&lt;/HTML&gt;"); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;]]></content>
      <categories>
        <category>Jsp</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsp&Servlet笔记（一）Tomcat初步]]></title>
    <url>%2F2017%2F11%2F10%2FJSP1%2F</url>
    <content type="text"><![CDATA[本篇介绍的是Tomcat的一些基本配置和用法，以及Web App的初步介绍。 第一课.tomcat初步1常用的Web服务器： IIS Apache(C写的) Tomcat（Java写的） Linux下用Apache比较多 常用的动态网页技术： CGI (Common GateWay Interface) API常用的由（NSAPI,ISAPI） ASP(Active Server Page) PHP(Personal Home Page) Jsp/Servlet(Java Server Page) Servlet简介 Servlet是服务器小程序 用来完成B/S架构下,客户端请求的相应处理 平台独立，性能优良，能以线程方式运行 Servlet API为Servlet提供了统一的编程接口 Servlet一般在容器中运行 常见的Servlet容器： Tomcat Tomcat下载：地址：http://tomcat.apache.org/找Download，然后找到最新版本，下载64-bit Windows zip下载后解压到D盘根目录改名为tomcat加版本号 Tomacat运行：打开cmd，切换到tomcat目录下的bin目录键入startup就可以开启tomcat键入shutdown，就关闭了tomcat 或者可以键入catalina start也可以开启tomcat因为catalina.bat是tamcat中实际起作用的部分，tamcat中startup和shutdown真正调用的是catalina.bat 停止就键入catalina stop 第二课.tomcat初步2在tomcat已经启动后输入网址：127.0.0.1：8080就可以访问tomcat主页了。 第三课.tomcat初步3Tomcat的目录结构 bin/ 二进制可执行文件和脚本 common/ Catalina本身和web应用可加载的类目录 conf/ 配置文件目录 logs/ 日志目录 server/ 服务器所需的类库目录 shared/ web app共享的类库 webapps/ Web应用所存放的目录applications work/ Tomcat的工作目录（存放jsp产生的class文件） temp/ 存放临时产生的文件 conf/server.xml 服务器的主配置文件conf/web.xml 定义所有Web应用的配置 （缺省的Servlet定义和MIME类型定义）conf/tomcat-user.xml 定义了tomcat用户的信息（用于权限与安全） 如果想要修改端口，可以在server.xml中对端口进行修改。对应代码为：12345678910&lt;!-- A "Connector" represents an endpoint by which requests are received and responses are returned. Documentation at : Java HTTP Connector: /docs/config/http.html Java AJP Connector: /docs/config/ajp.html APR (HTTP/AJP) Connector: /docs/apr.html Define a non-SSL/TLS HTTP/1.1 Connector on port 8080 --&gt; &lt;Connector port="8888" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" &gt;&lt;/Connector&gt; 然后将tomcat关闭，再重新启动。键入localhost:8888就可以访问tomcat主页了 第四课.tomcat初步4在打开的tomcat主页点击 manager app这一项，会提示你输入用户名和密码。这时输入用户名tomcat，密码tomcat，发现会提示错误。这时我们需要在conf/user进行设置，设置前先对这个文件进行备份 将代码进行修改，增加角色，代码如下： 1234&lt;role rolename="manager-gui"/&gt;&lt;role rolename="admin-gui"/&gt;&lt;role rolename="admin-script"/&gt;&lt;user username="tomcat" password="s3cret" roles="manager-gui,admin-gui,admin-script"/&gt; 然后重启tomcat再进入127.0.0.1:8888，点击manager app这一项，输入账号tomcat，密码s3cret，就可以进入管理界面了。 第五课. 开发webapp初步在idea中配置一个web app如下文所示：http://simonic512.github.io/2015/11/13/Intellij-IDEA-14-%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%BC%80%E5%8F%91-servlet-%E5%85%A5%E9%97%A8/ 第六课. HTTP协议和Web app初步HTTP测试：启动tomcat，编写下面代码并运行：12345678910111213141516171819202122import java.io.*;import java.net.Socket;public class Test &#123; public static void main(String[] args) throws IOException &#123; Socket s = new Socket("127.0.0.1", 8888); PrintWriter pw = new PrintWriter(new OutputStreamWriter(s.getOutputStream())); pw.println("GET / HTTP/1.1"); pw.println("Host: localhost"); pw.println("Content-Type: text/html"); pw.println(); pw.flush(); BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream())); String str = ""; while((str = br.readLine()) != null)&#123; System.out.println(str); &#125; br.close(); pw.close(); s.close(); &#125;&#125; 结果会返回tomcat主页的html并在控台打印出来 如果将GET /改为GET /aaa，再运行就会出现如下错误： 1234HTTP/1.1 404 Content-Type: text/html;charset=utf-8Content-Language: enContent-Length: 1072 Web Application的概念Web Application Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WEB-INF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;web.xml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该web app的配置文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该web app用到的库文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;classes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存放编译好的servlet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;META-INF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;存放该web app的上下文信息，符合J2EE标准 Web Application可以直接放在webapp下面也可以通过配置文件指定到其他目录 里面&lt;Context path=“/虚拟路径名“ docBase=”目录位置&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;/&gt; 可以直接在tomcat下的webapps目录增加一个test目录，在test目录下创建WEB-INF目录，在里面创建web.xml，并且把下面代码粘过来： 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;/web-app&gt; 接下来可以在test目录下创建一个index.html，在里面书写一些html代码，直接键入127.0.0.1:8888/test就可以访问这个目录了。 或者可以在test下创建admin目录，在admin下创建index.html，然后键入127.0.0.1:8888/test/admin就可以访问这个页面了。]]></content>
      <categories>
        <category>Jsp</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 677.找前缀总和（Map Sum Pairs）]]></title>
    <url>%2F2017%2F11%2F07%2Fleetcode677%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/map-sum-pairs/description/ 方法一：方法一比较暴力一些，就是创建一个存放键值对的HashMap，其中键就是我们插入的字符串，值就是这个字符串对应的权重。当要求一个前缀在HashMap中所有包括他的字符串对应value的总和时候，只需要遍历这个哈希表，查看每一个字符串是否以这个前缀开头，如果是的话把对应的值加上去就可以了。1234567891011121314151617181920212223242526272829303132333435class MapSum &#123; HashMap&lt;String, Integer&gt; hm; /** Initialize your data structure here. */ public MapSum() &#123; hm = new HashMap&lt;String, Integer&gt;(); &#125; public void insert(String key, int val) &#123; hm.put(key, val); &#125; public int sum(String prefix) &#123; int res = 0; Set&lt;String&gt; keys = hm.keySet(); Iterator it = keys.iterator(); String temp; while(it.hasNext())&#123; temp = (String)it.next(); if(temp.startsWith(prefix))&#123; res += (int)hm.get(temp); &#125; &#125; return res; &#125;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */ 方法二：本方法以及设计到一点字典树（前缀树）的思想，就是每当插入一个单词key，都会现在我们原先的HashMap中查看这个单词有没有。要是没有，就将设置delta = val - map[key]，也就是val，并构造一个Trie，将key从头到尾遍历，并将构造出的前缀的子字符串的score与delta相加，并再次赋给score。要是有这个字符串，也是求一个差值：delta = val - map[key],然后将在这个树中的所有节点的score都和delta相加，就达到更新的效果。 代码：1234567891011121314151617181920212223242526272829303132333435class MapSum &#123; HashMap&lt;String, Integer&gt; hm; //用于存取字典树 HashMap&lt;String, Integer&gt; score; /** Initialize your data structure here. */ public MapSum() &#123; hm = new HashMap&lt;String, Integer&gt;(); score = new HashMap&lt;String, Integer&gt;(); &#125; public void insert(String key, int val) &#123; //先求差值,如果没有这个键值对，就返回0 int delta = val - hm.getOrDefault(key, 0); hm.put(key, val); //先构造一个空串 String prefix = ""; for(char c : key.toCharArray())&#123; prefix += c; score.put(prefix, score.getOrDefault(prefix, 0) + delta); &#125; &#125; public int sum(String prefix) &#123; return score.getOrDefault(prefix, 0); &#125;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */ 方法三：方法三就是利用字典树的数据结构，对prefix中每一个字母的频次进行存取。思路和上面的相同，只不过数据结构变了。Trie树的结构如下： 在上图中，最左的一支代表”to”单词。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MapSum &#123; HashMap&lt;String, Integer&gt; hm; //字典树根节点 TrieNode root; /** Initialize your data structure here. */ public MapSum() &#123; hm = new HashMap&lt;String, Integer&gt;(); root = new TrieNode(); &#125; public void insert(String key, int val) &#123; //先求差值,如果没有这个键值对，就返回0 int delta = val - hm.getOrDefault(key, 0); hm.put(key, val); TrieNode cur = root; cur.score += delta; for(char c : key.toCharArray())&#123; //如果孩子节点没有这个字母，就增加一个 cur.children.putIfAbsent(c, new TrieNode()); //获取这个字母的节点 cur = cur.children.get(c); //增加delta cur.score += delta; &#125; &#125; public int sum(String prefix) &#123; TrieNode cur = root; for(char c : prefix.toCharArray())&#123; if(cur.children.get(c) == null) return 0; //指针下移 cur = cur.children.get(c); &#125; return cur.score; &#125;&#125;//前缀树节点class TrieNode&#123; Map&lt;Character, TrieNode&gt; children = new HashMap(); int score;&#125;/** * Your MapSum object will be instantiated and called as such: * MapSum obj = new MapSum(); * obj.insert(key,val); * int param_2 = obj.sum(prefix); */]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashMap</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 553.最佳括号分配]]></title>
    <url>%2F2017%2F11%2F05%2Fleetcode553%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/optimal-division/description/ 方法一：这个方法比较暴力一些，就是利用递归来做。 当数组只有一个数字的时候，就直接把它返回即可 当数组中有两个以上的数字的时候，可以将数组分成左右两部分，那么我们要求的最大值一定就是(左边部分的最大值)/(右边部分的最小值)。所以可以创建一个类T来存储我们的最大值和最小值以及它们对应的字符串结果。 注意在返回构造字符串的时候要注意指针是不是已经走到数组末尾前的一个位置，如果已经到了那个位置，右边部分只有一个数，就不需要给它加括号了。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public String optimalDivision(int[] nums) &#123; int start = 0; int end = nums.length - 1; T t = optimal(start, end, nums); return t.max_str; &#125; class T &#123; float max_val; float min_val; String max_str; String min_str; &#125; public T optimal(int start, int end, int[] nums)&#123; T t = new T(); //如果只有一个数，直接返回自己就可以了 if(start == end) &#123; t.max_val = nums[start]; t.min_val = nums[start]; t.max_str = "" + nums[start]; t.min_str = "" + nums[start]; return t; &#125; t.max_val = Float.MIN_VALUE; t.min_val = Float.MAX_VALUE; t.max_str = ""; t.min_str = ""; //否则的话，依次把数组划分成左右两部分，并且对这两部分求最大值和最小值 for(int i = start; i &lt; end; i++)&#123; T left = optimal(start, i, nums); T right = optimal(i + 1, end, nums); if(t.max_val &lt; left.max_val/right.min_val)&#123; t.max_val = left.max_val/right.min_val; if(i + 1 == end) t.max_str = left.max_str + "/" + right.min_str; else t.max_str = left.max_str + "/(" + right.min_str + ")"; &#125; if(t.min_val &gt; left.min_val/right.max_val)&#123; t.min_val = left.min_val/right.max_val; if(i + 1 == end) t.min_str = left.min_str + "/" + right.max_str; else t.min_str = left.min_str + "/(" + right.max_str + ")"; &#125; &#125; return t; &#125;&#125; 评估：这个算法的时间复杂度是O(n!)级别的，而空间复杂度是O(n^2)级别的（因为需要进行长度为n的分划，而每一次分划内部进行递归是n次，所以需要调用O(n^2)次递归栈） 方法二：方法二是对方法一的修改，就是增加存储二维数组，对每一次已经计算过的start和end之间的结果进行存储，在求解一个start和end之间数组的T时，先看看存储中有没有已经对这部分进行计算，如果已经计算过了，直接返回结果就可以了，没有就再进行方法一的计算，并且对计算结果进行存储。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123; public String optimalDivision(int[] nums) &#123; int start = 0; int end = nums.length - 1; //用于存储已经计算出的T T [][] memo = new T[nums.length][nums.length]; T t = optimal(start, end, nums, memo); return t.max_str; &#125; class T &#123; float max_val; float min_val; String max_str; String min_str; &#125; public T optimal(int start, int end, int[] nums, T[][] memo)&#123; //第一步先进行判断，如果这部分数组已经被计算过了，直接返回已经存储的值即可 if(memo[start][end] != null) return memo[start][end]; T t = new T(); //如果只有一个数，直接返回自己就可以了 if(start == end) &#123; t.max_val = nums[start]; t.min_val = nums[start]; t.max_str = "" + nums[start]; t.min_str = "" + nums[start]; //对计算结果进行存储 memo[start][end] = t; return t; &#125; t.max_val = Float.MIN_VALUE; t.min_val = Float.MAX_VALUE; t.max_str = ""; t.min_str = ""; //否则的话，依次把数组划分成左右两部分，并且对这两部分求最大值和最小值 for(int i = start; i &lt; end; i++)&#123; T left = optimal(start, i, nums, memo); T right = optimal(i + 1, end, nums, memo); if(t.max_val &lt; left.max_val/right.min_val)&#123; t.max_val = left.max_val/right.min_val; if(i + 1 == end) t.max_str = left.max_str + "/" + right.min_str; else t.max_str = left.max_str + "/(" + right.min_str + ")"; &#125; if(t.min_val &gt; left.min_val/right.max_val)&#123; t.min_val = left.min_val/right.max_val; if(i + 1 == end) t.min_str = left.min_str + "/" + right.max_str; else t.min_str = left.min_str + "/(" + right.max_str + ")"; &#125; &#125; //对计算结果进行存储 memo[start][end] = t; return t; &#125;&#125; 评价：这个算法的时间复杂度是O(n^3)的，空间复杂度也是O(n^3) 第三种方式：因为X1/X2/X3…/Xn一定可以转化成一个P/Q的形式，而X1一定在P中，X2一定在Q中，所以上面一定是一个(X1/X2)&#42;Y的形式，而由于X1/(X2/X3…/Xn) = (X1&#42;X3&#42;…Xn)/X2的形式，所以这种情况下Y是最大的，也是整个算式的最优解（原谅我这个等式想了好久才明白…）。所以我们可以直接通过数学定理来求解这个问题： 代码：123456789101112131415class Solution &#123; public String optimalDivision(int[] nums) &#123; if(nums.length == 1) return ""+nums[0]; if(nums.length == 2) return nums[0] + "/" + nums[1]; String res = nums[0]+"/("; for(int i = 1; i &lt;= (nums.length - 2); i++) &#123; res += nums[i] + "/"; &#125; res += nums[nums.length - 1] + ")"; return res; &#125;&#125; 评估：这个代码的时间复杂度是O(n)，空间复杂度也是O(n)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记（四）]]></title>
    <url>%2F2017%2F11%2F03%2Fgitnotes4%2F</url>
    <content type="text"><![CDATA[本篇为git笔记的第四篇 第十六课. rebase当前分支树： rebase讲解： rebase步骤： 执行命令：git rebase --onto master master dev 上面的指令可以简写，如果已经在dev分支上，可以直接执行：git rebase master 第十七节.远程分支远程分支存放在.git/refs/remotes/origin/ 可以使用git branch -a查看本地和远程的所有分支 可以使用git fetch获取到远程分支： 可以查看当前分支情况： 可以看到远程分支已经被获取到本地，并且是本地分支的最新提交，如果想将二者合并，可以直接执行：git merge origin/master就可以将这两个分支进行合并了： git pull相当于是git fetch和git merge origin/master进行合并 执行git branch -vv可以查看一个分支的跟踪分支 现在我们在远程新建一个dev分支然后在本地执行git fetch命令 切换到dev：git checkout dev查看分支树：查看本地dev分支的跟踪树： 可以看到，远程的dev分支就是本地dev分支的跟踪分支，远程master分支就是本地master分支的跟踪分支。 第十八节.reset命令 git reset -- .当前暂存区中有c0，c1两个文件： 而代码仓库只有已经提交的c0文件 现在执行git reset -- .可以看到代码仓库把暂存区全部覆盖，所以没有了c1文件 git reset --soft chash 现在工作目录有c0和c1,暂存区只有c0，现在再次将工作目录文件添加并提交： 发现提交信息写错了，想重新提交： 由上面可以看到c1已经进入暂存区，而且待提交 如果想直接修改最后一次提交的提交信息，可以直接敲：git commit --amend -m ‘相输入的内容’ git reset --mixed chash可以更新commit记录并覆盖暂存区。 可以看到c1已经不被跟踪了 git reset --hard chash上面这个指令可以使分支回滚到上一次提交记录上： git reset chash上面这个指令默认选项是mixed 总结一下：• –soft – 缓存区和工作目录都不会被改变• –mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响• –hard – 缓存区和工作目录都同步到你指定的提交 第十九课.交互式rebase 第二十节.cherry-pickgit cherry-pick chash(想要挑选的commit可以合并到当前分支上去)： 第二十一节.revert当前状态： 发现d2提交有问题，可以对d2的提交进行撤销：git revert 1702保存后变为：再对d0进行撤销：上面的revert操作相当于undo操作，就是撤销。 现在想回到最初的d2，只需要执行操作：git reset --hard 1702就可以得到如下的分支提交树：切换到master,再对dev和master进行merge对merge后的提交进行撤销，首先我们可以查看79ef的情况： 可以看到，这个merge是由622f4d3和1702b16合并而成的，所以可以执行命令：git revert -m 1 79ef上面的1就是指定622f4d3为回退后的主分支可以得到如下的界面：保存并退出：:wq 可以得到如下版本树： revert小结：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记（三）]]></title>
    <url>%2F2017%2F11%2F03%2Fgitnotes3%2F</url>
    <content type="text"><![CDATA[本篇为git笔记的第三篇 第十一课. 再谈分支切换和checkout 第十二节.stash命令SourceTree：图形化的git操作工具 git stash：可以把当前未commit的工作放在存储区，该存储区是一个栈，最顶上是最新的stash列出所有存储：git stash list恢复最近存储：git stash pop你指定版本号为stash@{1}的工作取出来：git stash apply stash@{1}将所有的栈都应用回来：git stash clear 第十三节.分支合并1.快进（Fast Forward）没有merge之前的分支情况： 执行：git checkout mastergit merge b效果： 可以看到，这个合并是Fast forward（快进）的 由于b是master的直接祖先，所以直接就采用快进的方式将两个分支合并。 2.三方合并情况如下： 现在将分支e合并到master分支上去： 由于e不是master的直接祖先，所以采用recursive策略（三方合并），合并效果如下： 三方合并是哪三方？ 当前分支（提交）内容 要合并的分支（提交）内容 共同的一个祖先提交的内容 第十四节.分支合并之冲突解决如图所示，这个图中master和f是有冲突的（同时对同一个7.txt进行不同的修改） 现在将master和f分支进行合并（其中f不能合并master，只能用master合并f） 由上图可知，f和master产生了冲突解决冲突的办法：使用git mergetool查找merge工具 上面没有找到，采用vimdiff，敲回车： 决定不采用这种方式merge，所以退出，各种选择no: 利用BCompare来配置mergetool并再次执行mergetool: 这个指令会进入BCompare的图形化界面： 左边是本地分支，右边是要merge的分支，中间是共同的祖先分支，我们采用先左后右的方式对两个分支进行合并。合并成功后，输入ll查看文件情况，发现多了一个7.orig文件： 该文件保存了merge之前的内容，因为已经merge成功，所以可以直接删除：rm 7.orig此时提交，就会去掉merging状态 ： 第十五课.分支冲突idea解决和gitignore对于上面已经解决的冲突，如果想撤回操作，直接使用git reset –hard 提交的哈希就可以将已经执行的操作撤回了。 在idea中打开ck文件夹，并且点开View-&gt;Tool Windows-&gt;Version Control就可以打开git的版本插件： 不打算让git管理的文件，可以写到.gitignore 这样上面这些文件在提交时就会被忽略提交gitignore，按ctrl+K，添加提交信息即可提交。 点击下面的Log，就可以查看提交的树状图形化界面，还可以切换分支，进行merge 对master进行merge操作： 之后的操作就和BCompare的一样了：]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记（二）]]></title>
    <url>%2F2017%2F11%2F03%2Fgitnotes2%2F</url>
    <content type="text"><![CDATA[本篇为git笔记的第二篇 第八课.git如何存储数据 执行下面的命令： 生成一个.git文件夹，里面一个index文件就是暂存区.git/objects文件夹就是git的对象区。 执行命令：$ git ls-files -s就可以得到暂存区内容：100644 190a18037c64c43e6b11489df4bf0b9eb6d2c9bf 0 a.txt查看哈希值对应的内容：git cat-file -p 190a就可以得到内容：123进行提交git commit -m ‘创建文件a.txt’生成新的对象：生成commit和tree对象 之后再创建新的文件b.txt，再添加并提交，就可以得到新的对象： 总结： 每一个提交的索引： 一个提交的索引： 分支：跟踪文件版本 第九课. 深入Git存储之文件格式 第十课.git分支查看历史提交记录：git log 查看提交的哈希值：git log –oneline 查看分支，当前只有一个分支： 查看分支中的内容： 由分支可以知道，内容哈希与第二次提交的哈希相同。 新建开发分支：git branch dev查看当前分支：git branch 切换到dev分支：git checkout dev查看一下当前有哪些分支： 查看一下两个分支指向的提交的hash值： 所以两个分支当前都指向相同的提交 自动创建并切换到一个分支bug_11：$ git checkout -b bug_11 HEAD指向当前分支： 查看HEAD指向的分支，可以看到当前是在bug_11分支上。 分支总结： 查看分支的另一个方法：git log --oneline --decorate 基于某一次提交的hash创建分支：git branch dev commithash(分支的hash)或者git branch dev master 空的提交：git commit --allow-empty -m ‘功能1’ git log --oneline不能看到空的提交，要想看到空的提交，也就是所有提交，得执行：git log --oneline all顺便查看提交和分支：git log --oneline all –decorate图形化展示:git log --oneline all –decorate –graph给上面起别名：git config alias.logg &quot;log --oneline --all --decorate --graph&quot;利用别名展示：git logg]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git笔记（一）]]></title>
    <url>%2F2017%2F11%2F03%2Fgitnotes1%2F</url>
    <content type="text"><![CDATA[本篇为git笔记的第一篇 第四课：github账号创建-仓库创建创建好账号，然后在自己账号下点New repository： 填写仓库名字并创建： 填写ReadMe(Markdown格式) 可以利用gitpage创建个人主页：命名规则：仓库名/仓库名.github.io在里面添加index.html就可以。输入：仓库名.github.io即可打开主页（参见之前的个人blog搭建过程） 第五课：git配置简单右键文件夹，git bash here，对用户名和邮箱进行输入即可：$ git config –global user.name XX$ git config –global user.email YY@sina.cn 第六课：git大致工作流程在文件夹下克隆一个项目：右键git bash，然后 git clone https://github.com/caocan/test.git 这样一个项目就被复制到你想要的文件夹下了，而且这个文件夹下有了一个隐藏的.git文件夹。切换到已经克隆好的项目下，新建一个a.txt文件，再在git下执行git add a.txt，这样就将a.txt添加到了暂存区了。执行git commit就可以添加注释并提交了 上面的提交只是提交到了本地的仓库.git，如果想提交到远端，需要执行：git push（如果没有创建仓库需要输入用户名和邮箱）这样就提交成功了。 如果远端仓库被更新，只需要在本题执行git pull，就可以将最新的项目仓库更新。上面的工作流程讲解： 第七课.git文件状态在一个新文件夹下创建仓库：右键git bash here–&gt;git init test在test文件夹下有一个本地仓库.git cd test在test文件夹下新建一个init文件：touch init看一下文件状态：git status可以看到init文件是未跟踪文件 添加文件git add .再次查看文件状态：git status由上面的状态可知，我们已经将文件添加到暂存区了，但是还没有提交（commit） 再次提交到本地仓库：git commit -m ‘创建init’ 查看状态：git status 工作目录已经清空，都已经提交到本地仓库了 编辑init文件：vi init--&gt;o--&gt;111--&gt;esc--&gt;shift+zz 查看状态：git status 上面的意思是：在工作目录中修改了，还没有添加到暂存区。添加工作目录的所有文件：git add .再对文件进行修改vi init--&gt; o--&gt;222--&gt;esc--&gt;shift+zz再查看：git status可以看到工作区的需要添加暂存区，而已经在暂存区的需要被提交到本地仓库 查看差别的三个命令：git diff：是查看工作目录与暂存区的差别的。git diff --cached：是查看暂存区与本地仓库的差别的。git diff HEAD：是查看工作目录和本地仓库的差别的。（你一定没有忘记，HEAD代表的是最近的一次commit的信息） 流程图]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL笔记]]></title>
    <url>%2F2017%2F11%2F03%2FMySQL%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一课 MySQL的安装安装教程：https://jingyan.baidu.com/article/cd4c2979033a17756f6e6047.html 我设置的root密码是：09129421 测试是否安装成功以管理员权限运行命令提示符，用net start mysql56启动MySQL服务。用net stop mysql56关闭MySQL服务。其中mysql56为Windows下MySQL的服务名。 打开MySQL方式：可以通过MySQL 5.7 Command Line Client客户端输入上面密码打开，也可以在用管理者权限打开cmd后键入mysql -u root -p并输入密码来打开。之后就和sql*plus用法相似。 第二课. mysql_started1234567891011121314151617181920212223242526--建立数据库：create database mydata;--使用这个数据库use mydata;--创建表deptcreate table dept( deptno int primary key, dname varchar(14), loc varchar(13));--创建emp表create table emp( empno int primary key, ename varchar(10), job varchar(10), mgr int, hiredate datetime, sal double, comm double, deptno int, foreign key (deptno) references dept(deptno)); 另外一种方式创建表：可以将上面创建emp表的代码写入一个文件，起名叫mydata.sql，然后再mysql中执行该脚本文件：\. c:\\mysql_script\\mydata.sql如果已经建表，就不会再建。 第三课. page_seperation12345678910111213141516--查看当前用户有多少个数据库：show databases;--查看当前用户有多少个表：show tables;--查看一张表的信息desc dept;--插入多条信息：insert into dept values (10, 'A', 'A');insert into dept values (20, 'B', 'B');insert into dept values (30, 'C', 'C');insert into dept values (40, 'D', 'D');insert into dept values (50, 'E', 'E');--提交commit;--将dept数据按deptno倒序排，从第三条开始，去后面两条。select * from dept order by deptno desc limit 3, 2; 第四课. auto_increment123456--先创建一个article表，在id后加上auto_increment，该字段就会自动递增：create table article( id int primary key auto_increment, title varchar(255)); –显示一下select * from article; –再插一条insert into article values(null,&#39;b&#39;); –显示一下，id自动递增select * from article; –在指定字段上插入数据insert into article (title)values(&#39;c&#39;); 第五课. datetime–查看当前时间：select now(); –修改时间格式select date_format(now(),&#39;%Y-%m-%d %H:%i:%s&#39;); –向emp表中插入一条数据insert into emp values (9999, &#39;test&#39;, &#39;clerk&#39;, 7369, &#39;1981-12-23 12:23:23&#39;, 8000, 80, 10); 第六课.mysql_jdbc下载好MySql到JDBC的驱动程序https://www.mysql.com--&gt;products--&gt; MySQL Connectors–&gt; JDBC Driver for MySQL (Connector/J) 在project中导入connector的jar包：http://blog.csdn.net/a153375250/article/details/50851049 编写从jdbc到mysql的连接查询代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.sql.*;public class TestMysqlConnection &#123; public static void main(String[] args)&#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; //添加jdbc到mysql的驱动 Class.forName("com.mysql.jdbc.Driver"); //连接数据库 conn = DriverManager.getConnection("jdbc:mysql://localhost/mydata?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false" , "root","09129421"); //实例化数据库操作 stmt = conn.createStatement(); //返回数据库查询结果 rs = stmt.executeQuery("select * from dept"); //将查询结果中的deptno的值依次打印 while(rs.next())&#123; System.out.println(rs.getString("deptno")); &#125; // Do something with the Connection &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; catch (SQLException ex) &#123; // handle any errors System.out.println("SQLException: " + ex.getMessage()); System.out.println("SQLState: " + ex.getSQLState()); System.out.println("VendorError: " + ex.getErrorCode()); &#125;finally &#123; try&#123; if(rs != null) &#123; rs.close(); rs = null; &#125; if(stmt != null) &#123; stmt.close(); stmt = null; &#125; if(conn != null) &#123; conn.close(); conn = null; &#125; &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 第八课.article_tree我们要在mysql下执行bbs.sql文件该sql文件如下：1234567891011121314151617181920212223242526create database bbs;use bbs;create table article (id int primary key auto_increment,pid int,rootid int,title varchar(255),cont text,pdate datetime,isleaf int );insert into article values (null, 0, 1, '蚂蚁大战大象', '蚂蚁大战大象', now(), 1);insert into article values (null, 1, 1, '大象被打趴下了', '大象被打趴下了',now(), 1);insert into article values (null, 2, 1, '蚂蚁也不好过','蚂蚁也不好过', now(), 0);insert into article values (null, 2, 1, '瞎说', '瞎说', now(), 1);insert into article values (null, 4, 1, '没有瞎说', '没有瞎说', now(), 0);insert into article values (null, 1, 1, '怎么可能', '怎么可能', now(), 1);insert into article values (null, 6, 1, '怎么没有可能', '怎么没有可能', now(), 0);insert into article values (null, 6, 1, '可能性是很大的', '可能性是很大的', now(), 0);insert into article values (null, 2, 1, '大象进医院了', '大象进医院了', now(), 1);insert into article values (null, 9, 1, '护士是蚂蚁', '护士是蚂蚁', now(), 0); 由于mysql编码问题，有时会出现因为乱码而无法插入数据的现象，解决办法如下：C:\ProgramData\MySQL\MySQL Server 5.7下，有可能ProgramData文件又能隐藏了，设置一下文件夹选项，然后再这个文件夹下面可以找到my.ini配置文件，将字符编码改为：default-character-set=gbk就可以了。 第九课.article_tree 2idea中连接数据库的详细教程：http://blog.csdn.net/qq_27093465/article/details/52872582可以将数据库的可视化界面调用出来。 将上面第八课的bbs数据库的article表树状打印出来：代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.sql.*;public class ArticleTree &#123; public static void main(String[] args)&#123; new ArticleTree().show(); &#125; public void show()&#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; try&#123; //添加jdbc到mysql的驱动 Class.forName("com.mysql.jdbc.Driver"); //连接数据库 conn = DriverManager.getConnection("jdbc:mysql://localhost/bbs?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false" , "root","09129421"); stmt = conn.createStatement(); rs =stmt.executeQuery("select * from article where pid = 0"); while(rs.next())&#123; System.out.println(rs.getString("cont")); tree(conn, rs.getInt("id"), 1); &#125; &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(rs != null) &#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; if(conn != null)&#123; conn.close(); conn = null; &#125; &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125; private void tree(Connection conn, int id, int level)&#123; Statement stmt = null; ResultSet rs = null; StringBuffer strPre = new StringBuffer(""); for(int i = 0; i &lt; level; i++)&#123; strPre.append(" "); &#125; try&#123; stmt = conn.createStatement(); String sql = "select * from article where pid = " + id; rs = stmt.executeQuery(sql); while(rs.next())&#123; System.out.println(strPre +(rs.getString("cont"))); if(rs.getInt("isleaf") != 0) tree(conn, rs.getInt("id"), level + 1); &#125; strPre = new StringBuffer(""); &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if(rs != null) &#123; rs.close(); rs = null; &#125; if(stmt != null)&#123; stmt.close(); stmt = null; &#125; &#125; catch(SQLException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 647.找出字符串回文子串的个数]]></title>
    <url>%2F2017%2F11%2F03%2Fleetcode647%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/palindromic-substrings/description/ 这道题，就是找出一个字符串中所有可能出现的回文子串的个数。首先想到了一种最为直接粗暴的做法，就是把一个字符串的所有子串都求出来，然后依次判断是不是回文，如果是，计数器+1.最后将计数器返回。AC代码如下：12345678910111213141516171819202122232425class Solution &#123; public int countSubstrings(String s) &#123; int count = 0; int n = s.length(); for(int i = 1; i &lt;= n; i++)&#123; for(int j = 0 ; j &lt;= n-i; j++) &#123; String des = s.substring(j,j+i); // System.out.println("这次的子串是："+des); int desn = des.length(); int k; for(k = 0; k &lt; desn; k++) if(des.charAt(k) != des.charAt(desn-k-1)) break; if(k == desn) &#123; count++; // System.out.println(des+"是回文"); &#125; &#125; &#125; return count; &#125;&#125; 更为简洁的做法，应该是利用中心拓展来求解： 中心拓展，假设当前位置i为回文的中心，那么设置left=i-1 right=i+1，比较left与right位置是否相同，相同就+1，然后各自移动一步，重复直到退出 。 中心拓展当前的回文长度是偶数的，那么就设置left=i，right=i+1，其他同2一样。 代码如下：123456789101112131415161718192021public class Solution &#123; int count = 0; public int countSubstrings(String s) &#123; if (s == null || s.length() == 0) return 0; for (int i = 0; i &lt; s.length(); i++) &#123; // i is the mid point extendPalindrome(s, i, i); // 奇数长度; extendPalindrome(s, i, i + 1); // 偶数长度 &#125; return count; &#125; //中心拓展子函数 private void extendPalindrome(String s, int left, int right) &#123; while (left &gt;=0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; count++; left--; right++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 406.根据身高重新排队]]></title>
    <url>%2F2017%2F11%2F02%2Fleetcode406%2F</url>
    <content type="text"><![CDATA[题目描述：https://leetcode.com/problems/queue-reconstruction-by-height/description/ 首先需要对身高和前面的人数进行排序：先对身高降序排列，再对前面的人升序排列。 对已经排好序的数组进行遍历，取出当前人的，开始对结果队列的人进行遍历，并设置计数器。如果结果队列中有一个人的身高大于h，就将计数器+1,；如果计数器的值等于了k，就在这个位置把我们当前的人插入到结果列表中去。示例：people：[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]排序后：[[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]然后从数组people第一个元素开始，放入到数组result中，放入的位置就是离result开始位置偏移了元素第二个数字后的位置。如下： people: [7,0]插入到离开始位置偏移了0个距离的位置。result: [[7,0]] people: [7,1]插入到离开始位置偏移了1个距离的位置，即插入到[7,0]的后面。result: [[7,0], [7,1]] people: [6,1]插入到离开始位置偏移了1个距离的位置，即插入到[7,0]的后面。result: [[7,0], [6,1], [7,1]] people: [5,0]插入到离开始位置偏移了0个距离的位置，即插入到[7,0]的前面。result: [[5,0], [7,0], [6,1], [7,1]] people: [5,2]插入到离开始位置偏移了2个距离的位置，即插入到[7,0]的后面。result: [[5,0], [7,0], [5,2], [6,1], [7,1]] people: [4,4]插入到离开始位置偏移了4个距离的位置，即插入到[6,1]的后面。result: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 这种算法体现了元素第二个数字与其插入位置的关系，所以通过简单的一个for循环就可以搞定。 我的AC代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution &#123; public int[][] reconstructQueue(int[][] people) &#123; //如果输入数组为空，直接返回空数组即可 if(people.length == 0) return people; //利用Arrays.sort对二维数组进行排序，先对身高降序排列，如果身高相同，就对前面的人数升序排列（这里需要用到比较器Comparator） Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] o1, int[] o2) &#123; if(o1[0] == o2[0]) return o1[1] - o2[1]; else return o2[0] - o1[0]; &#125; &#125;); //创建一个存放键值对的链表res LinkedList&lt;int[]&gt; res = new LinkedList&lt;&gt;(); int[] temp = new int[2]; //将第一个人的身高和k值传入 res.add(new int[]&#123;people[0][0], people[0][1]&#125;); //对已经排好序的数组进行遍历，取出当前人的&lt;h,k&gt;，开始对结果队列的人进行遍历，并设置计数器。如果结果队列中有一个人的身高大于h，就将计数器+1,；如果计数器的值等于了k，就在这个位置把我们当前的人插入到结果列表中去。 for(int i = 1; i &lt; people.length; i++) &#123; int h = people[i][0]; int k = people[i][1]; int count = 0; int p = 0; Iterator&lt;int[]&gt; it = res.iterator(); while(it.hasNext())&#123; if (count &lt; k)&#123; temp = it.next(); p++; if(temp[0] &gt;= h)&#123; count++; &#125; else continue; &#125; if (count &gt;= k) break; &#125; res.add(p, new int[]&#123;h, k&#125;); &#125; Iterator&lt;int[]&gt; it = res.iterator(); //将结果列表转换为数组 int pos = 0; while(it.hasNext())&#123; temp = it.next(); people[pos][0] = temp[0]; people[pos][1] = temp[1]; pos ++; &#125; return people; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 669.裁剪二叉搜索树]]></title>
    <url>%2F2017%2F10%2F22%2Fleetcode669%2F</url>
    <content type="text"><![CDATA[原题地址：https://leetcode.com/problems/trim-a-binary-search-tree/description/ 思路：第一种是循环+递归方法做裁剪： 1.如果root是null，就直接返回null；2.如果root值位于L和R之间，那么要求解的左子树就是将根的左子树带入递归算法得出的裁剪节点，求解的右子树就是根的右子树带入递归算法得出的裁剪节点；3.如果root值不位于L和R之间，那么就让根一直查找到位于L和R的区间，再重复2的求解过程。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public TreeNode trimBST(TreeNode root, int L, int R) &#123; if(root==null)&#123; return root; &#125; if(root.val&gt;=L&amp;&amp;root.val&lt;=R)&#123; root.left=trimBST(root.left, L, R); root.right=trimBST(root.right, L, R); return root; &#125; else if(root.val&lt;L)&#123;//root和root左边的部分肯定要被trim掉 while (root.val &lt; L) &#123; root = root.right; // 保证 root.val&gt;=l while (root != null &amp;&amp; root.val &lt; L) &#123; root = root.right; &#125; // 保证 l&lt;=root.val&lt;=R while (root != null &amp;&amp; root.val &gt; R) &#123; root = root.left; &#125; if (root == null) &#123; return root; &#125; &#125; root.left=trimBST(root.left, L, R); root.right=trimBST(root.right, L, R); return root; &#125; else&#123;//root.val&gt;R while (root.val &gt; R) &#123; root = root.left; // 保证 root.val&lt;=R while (root != null &amp;&amp; root.val &gt; R) &#123; root = root.left; &#125; // 保证 l&lt;=root.val&lt;=R while (root != null &amp;&amp; root.val &lt; L) &#123; root = root.right; &#125; if (root == null) &#123; return root; &#125; &#125; root.left=trimBST(root.left, L, R); root.right=trimBST(root.right, L, R); return root; &#125; &#125; 另外更简单的使用递归去做： 1.如果当前 root 正好在范围之内，那么把问题递归到它的左结点和右结点。2.如果当前 root 不在范围内，比 L 小，那么 它和它的左子树 可以被抛弃了。3.如果当前 root 不在范围内，比 R 大，那么 它和它的右子树 可以被抛弃了。 代码： 12345678910public TreeNode trimBST(TreeNode root, int L, int R) &#123; if(root == null) return null; if(root.val &gt;= L &amp;&amp; root.val &lt;= R) &#123; root.left = trimBST(root.left, L, R); root.right = trimBST(root.right, L, R); return root; &#125; if(root.val &lt; L) return trimBST(root.right, L, R); if(root.val &gt; R) return trimBST(root.left, L, R);&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode | 575.分糖块]]></title>
    <url>%2F2017%2F10%2F22%2Fleetcode575%2F</url>
    <content type="text"><![CDATA[Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. Example 1: Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind. Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too. The sister has three different kinds of candies. Example 2: Input: candies = [1,1,2,3] Output: 2 Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1]. The sister has two different kinds of candies, the brother has only one kind of candies. Note: The length of the given array is in range [2, 10,000], and will be even. The number in given array is in range [-100,000, 100,000]. 思路：记录糖果的种类，放在set集合中，然后取糖果种类和数组一半长度中较小的一个；1234567891011public class Solution &#123; public int distributeCandies(int[] candies) &#123; Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;(); for(int i=0;i&lt;candies.length;i++) &#123; if(!s.contains(candies[i])) &#123; s.add(candies[i]); &#125; &#125; return s.size()&lt;(candies.length/2) ? s.size():(candies.length/2); &#125; &#125; 但是这种方法需要额外的存储空间。 如果不想用额外的set集合来存储糖果种类，可以先对数组排序，然后用一个整数来存储糖果种类。 12345678910public int Solution(int[] candies) &#123; Arrays.sort(candies); int res = 0; for(int i=0;i&lt;candies.length;i++) &#123; if(i==0 || candies[i]!=candies[i-1]) &#123; res++; &#125; &#125; return Math.min(res, candies.length/2); &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（十一） 持有对象]]></title>
    <url>%2F2017%2F10%2F22%2FThinkingInJava11%2F</url>
    <content type="text"><![CDATA[11.2 基本概念容器类类库的用途是“保存对象”，可划分为两个不同概念： Collection。一个独立元素的序列，这些元素都服从一条或多条规则。• List必须按照插入顺序保存元素。• Set不能有重复元素• Queue按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同） Map。一组成对的“键值对”对象，允许你使用键来查找值。也被称为”关联数组”或”字典”。某种意义上来说，ArrayList也是一种Map 理想情况下，编写的大部分代码都是在与这些接口打交道，并且唯一需要指定所使用的精确类型的地方就是在创建的时候。可以这样创建一个List：List apples = new ArrayList好处在于修改实现时，只需要在创建处修改代码。如把ArrayList改为LinkedList。但是导出类一般具有额外的功能，如果需要使用这些功能，就不能将它们向上转型为更通用的接口。 11.3 添加一组元素1.Arrays.asList()。public static &lt;T&gt; List&lt;T&gt; asList(T... a)该方法接受一个数组或是一个用逗号分割的元素列表（使用可变参数），并将其转换为一个List对象，然后将其返回。可以直接使用此方法的输出当做一个List，但是在这种情况下，其底层表示是数组，因此不能调整大小，如果试图用add()或delete()方法在这种列表中添加或删除元素，有可能会引发改变数组尺寸的尝试，获得“Unsupported Operation”错误。另一个限制：会对所产生的List的类型做出最理想的假设，而不关心对它赋予的类型。 例： 12345678910111213141516171819202122232425262728/: holding/AsListInference.java // Arrays.asList() makes its best guess about type. import java.util.*; class Snow &#123;&#125; class Powder extends Snow &#123;&#125; class Light extends Powder &#123;&#125; class Heavy extends Powder &#123;&#125; class Crusty extends Snow &#123;&#125; class Slush extends Snow &#123;&#125; public class AsListInference &#123; public static void main(String[] args) &#123; List&lt;Snow&gt; snow1 = Arrays.asList( new Crusty(), new Slush(), new Powder()); // 不能编译: // List&lt;Snow&gt; snow2 = Arrays.asList( // new Light(), new Heavy()); // 编译说: // found : java.util.List&lt;Powder&gt; // required: java.util.List&lt;Snow&gt; // Collections.addAll() doesn't get confused: List&lt;Snow&gt; snow3 = new ArrayList&lt;Snow&gt;(); Collections.addAll(snow3, new Light(), new Heavy()); // 显式类型参数说明：Give a hint using an // explicit type argument specification: List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList( new Light(), new Heavy()); &#125; &#125; ///:~ 解决办法：使用显式类型参数说明（List&lt;Snow&gt; snow4 = Arrays.&lt;Snow&gt;asList(new Light(), new Heavy());） ，象上面的例子中最后所做的那样。 2. Collections.addAll() public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)该方法接受一个Collection对象，以及一个数组或是一个用逗号分割的列表，将元素添加到Collection中。先构建一个不包含元素的Collection，然后调用Collections.addAll()这种方式很方便，因此是首选方式。 3. Collection导出类构造器，可以接受另一个Collection，用它来将自身初始化。 4.Collection的addAll()方法，将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。相比使用构造函数初始化，这种方法快的多。 11.4 容器的打印数组需要用Arrays.toString()，容器不需要任何其它手段 （它们自己的toString()方法就足够了）。Collection打印出来的内容以[]括住，逗号分隔；Map则用{}，逗号分隔，键和值用=连接。 HashSet(HashMap)提供最快的查找技术，存储顺序无实际意义；LinkedHashSet(LinkedHashMap)按照被插入的顺序保存元素；TreeSet(TreeMap)按照比较结果的升序保存对象。 11.5 ListList 类 随机访问元素 插入和移除元素 其它 ArrayList 快 慢 LinkedList 慢 快 更大的特性集 常用方法： 方法 说明 boolean add(E e) 向列表的尾部添加指定的元素（可选操作）。 void add(int index, E element) 在列表的指定位置插入指定元素（可选操作）。 boolean addAll(Collection&lt;? extends E&gt; c) 添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序（可选操作）。 boolean addAll(int index, Collection&lt;? extends E&gt; c) 将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）。 void clear() 从列表中移除所有元素（可选操作）。 boolean contains(Object o) 如果列表包含指定的元素，则返回 true。 boolean containsAll(Collection&lt;?&gt; c) 如果列表包含指定 collection 的所有元素，则返回 true。 boolean equals(Object o) 比较指定的对象与列表是否相等。 E get(int index) 返回列表中指定位置的元素。 int hashCode() 返回列表的哈希码值。 int indexOf(Object o) 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 boolean isEmpty() 如果列表不包含元素，则返回 true。 Iterator iterator() 返回按适当顺序在列表的元素上进行迭代的迭代器。 int lastIndexOf(Object o) 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 ListIterator listIterator() 返回此列表元素的列表迭代器（按适当顺序）。 ListIterator listIterator(int index) 返回列表中元素的列表迭代器（按适当顺序），从列表的指定位置开始。 E remove(int index) 移除列表中指定位置的元素（可选操作）。 boolean remove(Object o) 从此列表中移除第一次出现的指定元素（如果存在）（可选操作）。 boolean removeAll(Collection&lt;?&gt; c) 从列表中移除指定 collection 中包含的其所有元素（可选操作）。 boolean retainAll(Collection&lt;?&gt; c) 仅在列表中保留指定 collection 中所包含的元素（可选操作）。交集 E set(int index, E element) 用指定元素替换列表中指定位置的元素（可选操作）。 int size() 返回列表中的元素数。 List subList(int fromIndex, int toIndex) 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图。 Object[] toArray() 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 T[] toArray(T[] a) 返回按适当顺序（从第一个元素到最后一个元素）包含列表中所有元素的数组；返回数组的运行时类型是指定数组的运行时类型。 • contains()、remove()、retainAll()、removeAll()方法都是基于equals()方法的。不同类，equals()方法定义可能有所不同，比如String只有在内容完全一样的情况下才会是等价的。• subList()返回的列表的修改都会反映到初始列表中，反之亦然。• Collections.sort()，Collections.shuffle()方法，进行排序、打乱顺序。• List重载了一个addAll(int, Collection)方法，可以插入一个新的列表到List中间； Collection的addAll方法追加到结尾。• toArray()方法：有一个重载；无参数的返回Object[]；传递目标类型的数组，将返回指定类型的数组，传递的数组如果太小，该方法新创建一个合适尺寸的数组。 11.6 迭代器一种设计模式，在不知道或不关心序列底层结构的情况下，遍历序列，选择每一个元素。迭代器是一种轻量级对象：创建代价低。Java的Iterator只能单向移动，用法： 使用iterator()方法返回Collection的迭代器；迭代器准备返回序列的第一个元素； 使用next()方法获取下一个元素；注意：iterator()返回的迭代器是”准备返回序列的第一个元素”，而不是已经指向了第一个元素，因此要获取第一个元素也得调用一次next()，即c.iterator().next()得到的是第一个元素。 hasNext()方法检验序列是否还有元素； 使用remove()方法删除迭代器返回的最后一个元素。注意，remove()是一种可选方法，依赖于具体实现，但Java标准容器类库都实现了这个方法。 当仅仅是遍历并获取每个元素，用foreach语法更简练。调用remove()之前必须调用next()方法。注意ConcurrentModificationException异常（所谓的fail-fast iterator）。 迭代器的威力：将遍历序列的操作与序列的底层结构分离，统一了对容器的访问方式。 11.6.1 ListIteratorListIterator：Iterator的子类，只能用于List类的访问，可双向移动；可以返回前一个和后一个元素的索引；可以使用set()方法替换最后访问的元素；listIterator()方法返回指向List开始处的ListIterator；listIterator(n)方法返回指向索引为n的元素处的ListIterator。 11.7 LinkedListLinkedList添加了一些可以使其用于栈、队列或双端队列的方法。某些方法只是别名，或者只存在些许差异，以使得它们在特定用法的上下文环境中更加适用（特别是在Queue中）。• getFirst()和element()方法完全相同，都返回列表的头，而并不移除它，如果List为空，抛出NoSuchElementException；peek()方法与他们基本相同，只是列表为空时返回null。• removeFirst()与remove()方法相同，移除并返回列表的头，List为空，抛出NoSuchElementException；poll()方法只是在列表为空时返回null。• offer()、add()、addLast()相同，都将某个元素插入到列表的尾端。• addFirst()将元素插入到列表的头。• removeLast()移除并返回列表的最后一个元素。 11.8 Stackjava.util中的Stack类采用了继承LinkedList的方式实现，实际上使用组合实现更好。 12345678910import java.util.LinkedList;public class Stack&lt;T&gt;&#123; private LinkedList&lt;T&gt; storage = new LinkedList&lt;T&gt;(); public void push(T v)&#123; storage.addFirst(v); &#125; public T peek()&#123; return storage.getFirst(); &#125; public T pop()&#123; return storage.removeFirst(); &#125; public boolean empty()&#123; return storage.isEmpty(); &#125; public String toString()&#123; return storage.toString(); &#125;&#125; 11.9 Set查找是Set最重要的操作，因此通常选择HashSet，因为快速查找正是它的长项。 Set的接口与Collection接口完全相同，只是行为不同而已，典型的继承与多态。 TreeSet使用红黑树数据结构，HashSet使用散列函数来保存对象，LinkedHashSet也使用散列来优化查找速度，但看起来使用链表来维护元素的插入顺序。 TreeSet默认按照字典序（lexicographically）排序，如果需要改变排序方法，可将比较器传给TreeSet构造器，如String.CASE_INSENTIVE_ORDER（按照字母表顺序alphabetically）。 11.10 Mapget(key)返回key所对应的值，如果key不在Map中，返回null。 containKey()和containValue()方法。 多维Map：值为Map或者别的Array、Collections。 Map可以返回它的键的Set（keySet()方法），它的值的Collection（values()方法），或者它的键值对的Set（entrySet()）。 11.11 QueueQueue常被用来可靠、安全地传输对象， 如从程序的一个区域传输到另一个区域，或者并行编程中从一个任务传输给另一个任务。 LinkedList实现了Queue接口，因此可用作Queue的一种实现（向上转型为Queue） 。 插入队尾：offer() 查询并返回队头：peek()：队列为空时返回nullelement()：队列空的时候抛出异常NoSuchElementException 移除并返回队头：poll()：队列为空时返回nullremove()：队列空的时候抛出异常NoSuchElementException 11.11.1 PriorityQueue队列规则：给定一组队列中的元素，确定下一个弹出队列的元素的规则 。FIFO是典型的一种规则，声明的是下一个元素应该是等待时间最长的元素。 优先级队列：下一个元素是最需要的元素（优先级最高的元素）。 Java SE5添加了这种队列。 offer()插入一个对象到PriorityQueue时，会在队列中被排序 （实际上依赖于具体实现，典型的是插入时排序，但也可以在移除时选择最重要的元素，如果对象的优先级在队列等待时可以改变，那算法的选择就很重要）。默认排序使用对象的自然顺序，但可以通过提供Comparator（如Collections.reverseOrder()，Java SE5）改变这个顺序。peek()、poll()和remove()可以获得优先级最高的元素 （对于内置类型，最小值拥有最高优先级）。 如果要在PriorityQueue使用自定义类型，就需要添加额外的功能以提供自然顺序，或者提供自己的Comparator。 11.12 Collection和IteratorCollection被认为是一个“附属接口”即因为要表示其它若干个接口的共性而出现的接口。 通过针对接口而非具体实现编写代码，我们的代码可以应用于更多的对象类型。 实现Collection接口可以通过继承AbstractCollection，但必须实现Iterator()和size()；如果类继承自其它类，就必须实现完整的Collection，但此时实现Iterator()似乎是一种更明智的选择 ，因为生成Iterator是将队列与使用队列的方法连接在一起耦合度最小的方式，并且与实现Collection相比，在序列类上所施加的约束也少得多。 11.13 Foreach与迭代器foreach可以用于数组，也可以用于Collection对象。因为Collection对象实现了Iterable接口（Java SE5引入，包含一个产生Iterator的iterator()方法）。也就是说，foreach可以用于数组和实现了Iterable接口的类（数组并不是Iterable）。 当类需要提供多种在foreach语句使用的方法时，可以采用适配器方法的惯用法。当已经拥有一个接口并需要另一个接口时，就可以编写适配器。例如，想在默认前向迭代器的基础上，添加产生反向迭代器的能力，此时不能使用覆盖，而是应该添加一个能够产生Iterable对象的方法，该对象可以用于foreach语句，像这样 123456789101112131415161718192021222324252627282930313233import java.util.*; class ReversibleArrayList&lt;T&gt; extends ArrayList&lt;T&gt; &#123; public ReversibleArrayList(Collection&lt;T&gt; c) &#123; super(c); &#125; public Iterable&lt;T&gt; reversed() &#123; return new Iterable&lt;T&gt;() &#123; public Iterator&lt;T&gt; iterator() &#123; return new Iterator&lt;T&gt;() &#123; int current = size() - 1; public boolean hasNext() &#123; return current &gt; -1; &#125; public T next() &#123; return get(current--); &#125; public void remove() &#123; // Not implemented throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125; &#125; public class AdapterMethodIdiom &#123; public static void main(String[] args) &#123; ReversibleArrayList&lt;String&gt; ral = new ReversibleArrayList&lt;String&gt;( Arrays.asList("To be or not to be".split(" "))); // Grabs the ordinary iterator via iterator(): for(String s : ral) System.out.print(s + " "); System.out.println(); // Hand it the Iterable of your choice for(String s : ral.reversed()) System.out.print(s + " "); &#125; &#125; 通过这种方法，可以创建不同行为多个迭代器，如随机访问random()等。 意识到Arrays.asList()产生的List对象会使用底层数组作为其物理实现是很重要的。下面的代码直接使用Arrays.asList()返回的List，Collections.shuffle(stringList);原来的数组也会改变。 123456789class TestArrays&#123; public static void main(String[] args)&#123; String[] strings = &#123;"hello","world","!"&#125;; List&lt;String&gt; stringList = Arrays.asList(strings); System.out.println(Arrays.toString(strings)); Collections.shuffle(stringList); System.out.println(Arrays.toString(strings)); &#125;&#125; 新程序中不应该使用过时的Vector、Hashtable和Stack。 点线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的点线表示一个特定的类实现了一个接口，实心箭头表示某个类可以生成箭头所指向的对象。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（十） 内部类]]></title>
    <url>%2F2017%2F10%2F22%2FThinkingInJava10%2F</url>
    <content type="text"><![CDATA[内部类主要有四种：静态内部类，普通内部类，局部内部类，匿名内部类。内部类不能和外部类同名。静态内部类不依赖于外部类实例而创建，不能访问外部类的普通成员变量和方法，只能访问静态成员变量和方法。普通内部类和外部类实例绑定，可以访问外部类的任一成员和方法，不能定义静态成员和方法，但是可以有static final 成员变量。局部内部类和局部变量一样，不能被public、protected、private、static修饰，只能访问定义为final类型的局部变量，也可以访问外部类成员。 10.1 创建内部类典型用法：外部类通过方法返回内部类的引用。想从外部类的非静态方法之外的任意位置创建某个内部类的对象，就得用OuterClassName.InnerClassName的形式定义内部类对象。 注意，非static内部类只能在外部类的非静态方法中直接生成对象；在外部类静态方法和其它类中，必须先生成外部类对象实例，然后外部类对象.new。 10.2 链接到外部类内部类对象有一个到创建它的外部类对象的链接，因而可以直接的、没有任何限制地访问该外部类对象的成员，而且内部类可以访问外部类的所有成员（包括private）（C++的嵌套类没有这个特性）；而外部类访问内部类的成员，必须创建内部类的对象，可以访问任何成员（包括private）。 内部类对象中隐式包含了一个外部类对象的引用。内部类对象构建需要外部类对象的引用，如果没有，编译报错（对于非静态内部类，静态内部类可以直接被创建new Outer.Inner()，而不需要先创建外部类对象）。 10.3 使用.this和.mew.this用来返回外部类引用，编译期可知道和检查正确类型，无运行时开销（OuterClassName.this）；.new用来由外部类对象创建其内部类的对象，OuterClassObject.new InnerClassName ()（注意：在拥有外部类对象之前是不能创建内部类对象的） 嵌套类，static 内部类，其对象创建不需要外部类对象引用，也可在static方法中创建。 10.4 内部类与向上转型内部类在向上转型的时候很有用处。因为内部类通常为某个接口的实现，且能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，能更好得隐藏细节。 10.5 在方法和作用域内的内部类可以在一个方法里或者任意的作用域内定义内部类，称为局部内部类。两个理由： 实现一个接口 需要一个不公开的类辅助解决复杂的问题 内部类形式 方法内的内部类； 方法中的一个作用域内的内部类； 实现接口的匿名内部类； 继承的匿名内部类（基类含有带参数的构造器）； 进行字段初始化的匿名内部类； 使用实例初始化块进行构造的匿名内部类（匿名类没有构造器）。 10.6 匿名内部类匿名内部类 ：new T(){…}; {…}为匿名内部类的定义，”;”不可少（;只是该语句的结束，而不是用来表示匿名内部类的结束，所以没有什么特殊的地方）。 前面是基类构造器为默认构造器的情况，当基类构造器有参数时：new T(args){…};此时会调用基类相应构造器。 当需要用到外部定义的对象时，传递的引用参数必须为final，否则编译报错； 匿名类没有命名的构造器（类本身就没有名字），可以通过实例初始化来完成构造器的功能。 匿名内部类只能在继承类和实现接口中2选一，且只能实现一个接口。 10.7 嵌套类static内部类。有点类似C++嵌套类的概念，但Java的嵌套类可以访问外部类的所有成员（包括private，当然只能通过外部类对象访问非静态成员）。 不需要通过外部类对象来创建嵌套类对象； 不能通过嵌套类对象访问非静态外部类对象(嵌套类是静态的，没有外部类对象的引用，.this不可用)； 普通内部类的字段和方法，只能在类的外部层次上，不能有static成员、方法和嵌套类（普通内部类有static final字段，普通内部类继承的父类中有静态域，这时可以通过内部类直接访问静态域）。 嵌套类可以位于接口内部，位于接口内部的类自动为public static的，而且嵌套类甚至本身就可以实现该接口，好处在于可以在嵌套类内编写该接口所有实现中都要用到的代码。 10.8 为什么需要内部类内部类的使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现“多重继承”。也就是说，内部类允许继承多个非接口类型（类或抽象类）。 代码：12345678910111213141516171819package access; class D &#123;&#125; abstract class E &#123;&#125; class Z extends D&#123; E makeE()&#123; return new E() &#123;&#125;; &#125; &#125; public class MultiImplementation &#123; static void takesD(D d) &#123;&#125; static void takesE(E e) &#123;&#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Z z = new Z(); takesD(z); takesE(z.makeE()); &#125; &#125; 如果拥有的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承。特性： 内部类可以有多个实例，每个实例可以拥有独立于外部类对象的不同信息； 一个外部类可以有多个内部类，每个内部类可以以不同的方式实现同一个接口或者继承同一个类； 内部类实例创建时刻并不受到外部类对象创建的限制； 用内部类不会制造”is-a”关系的混乱，每个内部类都是个实体。 10.8.1 闭包与回调闭包是一种可调用的对象，它记录了来自创建它的作用域的一些信息。内部类是一种面向对象的闭包，不仅包含了外部类的信息，而且通过包含一个指向外部类对象的引用，可以操作所有成员，包括private。 回调，通过其它对象携带的信息，可以在稍后的某个时刻调用初始对象。回调的价值在于灵活性，可以在运行时决定需要调用的方法。 GUI编程将体现得更明显。 10.8.2 内部类与控制框架一个应用程序框架是指一个用来解决一个特定类型问题的类或一组类。应用方法是，继承其中一个或多个类，覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，来解决特定问题，这是设计模式中模板方法的一个例子。 模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法。设计模式将不变的和变化的事情分开。在这个设计模式中，模板方法是保持不变的事物，而可覆盖的方法是变化的事物。 控制框架是用来响应事件的一类特殊的应用程序框架 。主要用来响应事件的系统称为事件驱动系统，如GUI。Java Swing就是一个控制框架。 内部类在控制框架中两个作用： 用来表示解决问题所需的各种不同的action()。 内部类可以直接访问外部类的所有成员，因而使得实现变得更灵活。参见P209控制温室的运作例子。 10.9 内部类的继承内部类指向外部类对象的引用必须初始化，而在它的继承类中并不存在要联接的缺省对象，必须使用特殊的语法明确指出这种关联。 12345678910111213class WithInner&#123; class Inner&#123; &#125;&#125;public class InheritInner extends WithInner.Inner &#123; InheritInner(WithInner wi)&#123; wi.super(); &#125; public static void main(String[] args)&#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(); &#125;&#125; 10.10 内部类可以被覆盖吗继承外部类，像重写方法一样重写内部类并不起作用，此时两个内部类只是两个独立的实体。 10.11 局部内部类局部内部类不能有访问限定符；有访问局部final变量和外部类所有成员的权限；可以有命名的构造器；在方法外不能访问。绝大部分情况下，可以用匿名类来替代局部内部类，除非： 需要命名的构造器，或者需要重载构造器 需要多个内部类的对象 10.12 内部类标识符内部类生成的.class文件命名规则：外围类的名字，加上’$’，再加上内部类的名字。 如果内部类是匿名的，编译器会简单地产生一个数字作为标识符。如果内部类是嵌套在别的内部类之中，只需要直接将它们的名字加在其外围类标识符与“$”的后面。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle（三） PLSQL]]></title>
    <url>%2F2017%2F10%2F22%2FOracle-PLSQL%2F</url>
    <content type="text"><![CDATA[第三十八课：PL_SQL/输出Hello World!/1234set serveroutput on; begin dbms_output.put_line('Hello World!!'); end; 12345678910111213141516declare v_name varchar2(20); begin v_name:='xiaoyu'; dbms_output.put_line(v_name); end; declare v_num number:=0; begin v_num:=2/v_num; dbms_output.put_line(v_num); exception when others then //任何错误，都会不找并打印为error dbms_output.put_line('error'); end; –变量声明的规则 1.变量名不能使用保留字 2.第一个字符必须是字母 3.变量名最多包含30个字母 4.不要与数据库或表名同名 5.每一行只能声明一个变量 /&#42;这是多行注释&#42;/–常用变量类型 1.binary_integer：整数，主要用来计数而不是用来表示字段类型 2.number数字类型 3.char定长字符串 4.date日期 5.long长字符串，最长2GB 6.boolean类型：可以取值true、false、null，默认为null，另外boolean类型值不可直接打印 1234567891011121314151617181920--变量声明 declare v_temp number(1); v_count binary_integer:=0; v_sal number(7,2):=8888.88; v_date date:=sysdate; v_pi constant number(3,2):=3.14; v_valid boolean:=false; v_name varchar2(20) not null:='geniusxiaoyu'; begin dbms_output.put_line('v_temp value:' || v_temp); end; --变量声明：使用%type属性 declare v_empno number(4); v_empno2 emp.empno%type; v_empno3 v_empno2%type; begin dbms_output.put_line('test for type'); end; 第四十一课12345678910--Table变量类型,相当于数组类型 declare type type_table_emp_empno is table of emp.empno%type index by binary_integer;//声明类型 v_empnos typa_table_emp_empno; begin v_empnos(0):=7777; v_empnos(1):=7778; v_empnos(-1):=6666; dbms_output.put_line(v_empnos(-1)); end; 123456789101112131415--Record变量类型，相当于类 declare type type_record_dept is record ( deptno dept.deptno%type, dname dept.dname%type, loc dept.loc%type ); v_temp type_record_dept; begin v_temp.deptno:=50; v_temp.dname:='yugang'; v_temp.loc:='beijing'; dbms_output.put_line(v_temp.deptno || ' ' || v_temp.dname || ' ' || v_temp.loc); end; 123456789--使用%rowtype声明record变量 declare v_temp dept%rowtype; begin v_temp.deptno:=50; v_temp.dname:='yugang'; v_temp.loc:='beijing'; dbms_output.put_line(v_temp.deptno || ' ' || v_temp.dname || ' ' || v_temp.loc); end; 12345678910--SQL语句的运用 --select语句必须和into语句一块使用并且只能返回一条记录 --sql%rowcount declare v_name emp.ename%type; v_sal emp.sal%type; begin select ename,sal into v_name,v_sal from emp where empno=7369; dbms_output.put_line(v_name || ' ' || v_sal); end; 123456declare v_temp emp%rowtype; begin select * into v_temp from emp where empno=7369; dbms_output.put_line(v_temp.ename || ' ' || v_temp.eno); end; 123456789/*向dept表中插入一条数据*/declare v_deptno dept.deptno%type:=50; v_dname dept.dname%type:='mm'; v_loc dept.loc%type:='bj'; begin insert into dept values(v_deptno,v_dname,v_loc); commit; end; 12345678910declare v_deptno dept.deptno%type:=50; v_count number; begin --update emp set sal =sal/2 where deptno=v_deptno; --select deptno into v_deptno from emp where empno=7369; select count(*) into v_count from emp; dbms_output.put_line(sql%rowcount || '条记录被影响！'); commit; end; 1234--DDL语句，在PLSQL中使用DDL语句要加上execute immediate,两个单引号代表一个单引号 begin execute immediate 'create table tt(name varchar2(20) default ''Army'')'; end; 1234567891011121314--if语句--取出7369的薪水，如果&lt;1200，则输出‘low’，如果&lt;2000则输出‘middle’，否则‘high’ declare v_sal emp.sal%type; begin select sal into v_sal from emp where empno=7369; if(v_sal&lt;1200) then dbms_output.put_line('low'); elsif(v_sal&lt;2000) then dbms_output.put_line('middle'); else dbms_output.put_line('high'); end if; end; –循环 12345678910--do while循环 declare i binary_integer:=1; begin loop dbms_output.put_line(i); i:=i+1; exit when (i &gt;= 11); end loop; end; -- while循环 declare j binary_integer:=1; begin while j&lt;11 loop dbms_output.put_line(j); j:=j+1; end loop; end; /*逆序输出*/ begin for k in 1..10 loop dbms_output.put_line(k); end loop; for k in reverse 1..10 loop dbms_output.put_line(k); end loop; end; --错误处理（too_many_rows，others，no_data_found） declare v_temp number; begin select empno into v_temp from emp where deptno=10; exception when too_many_rows then dbms_output.put_line(&apos;太多记录了&apos;); when others then dbms_output.put_line(&apos;error&apos;); end; declare v_temp number(4); begin select deptno into v_temp from emp where empno=2222; exception when no_data_found then dbms_output.put_line(&apos;没数据&apos;); end; --创建错误日志 create table errorlog ( id number primary key, errcode number, errmsg varchar2(1024), errdate date ); create sequence seq_errorlog_id start with 1 increment by 1; –SQLCODE 是出错代码，SQLERRM 是出错信息 123456789101112131415 declare v_deptno dept.deptno%type:=10; v_errcode number; v_errmsg varchar2(1024); begin delete from dept where deptno=v_deptno; commit; exception when others then rollback; v_errcode:=SQLCODE; v_errmsg:=SQLERRM; insert into errorlog values(seq_errorlog_id.nextVal,v_errcode,v_errmsg,sysdate); commit; end; –显示错误日志select * from errorlog; –显示错误时间select to_char(errdate , &#39;YYYY-MM-DD HH24:MI:SS&#39;) from errorlog; 第47~48课：cursor（重点） 12345678910 declare cursor c is select * from emp; v_emp c%rowtype; begin open c; fetch c into v_emp; dbms_output.put_line(v_emp.ename); close c; end; 12345678910111213--简单循环 declare cursor c is select * from emp; v_emp c%rowtype; begin open c; loop fetch c into v_emp; exit when(c%notfound); dbms_output.put_line(v_emp.ename); end loop; end; 123456789101112131415161718192021222324252627282930313233declare cursor c is select * from emp; v_emp c%rowtype; begin open c; loop fetch c into v_emp; --下面两行顺序改变后，将会把最后一条记录打印两遍 dbms_output.put_line(v_emp.ename); exit when(c%notfound); end loop; end; ``` ```sql--while循环 declare cursor c is select * from emp; v_emp emp%rowtype; begin open c; fetch c into v_emp; while(c%found) loop dbms_output.put_line(v_emp.ename); fetch c into v_emp; end loop; close c; end; 123456789--for循环 declare cursor c is select * from emp; begin for v_emp in c loop dbms_output.put_line(v_emp.ename); end loop; end; 12345678910--带参数的游标 declare cursor c(v_deptno emp.deptno%type,v_job emp.job%type) is select ename,sal from emp where deptno=v_deptno and job=v_job; --v_emp emp%rowtype; begin for v_emp in c(30,'JAY') loop dbms_output.put_line(v_emp.ename); end loop; end; 123456789101112131415--可更新的游标 declare cursor c is select * from emp for update; --v_temp c%rowtype; begin for v_temp in c loop if(v_temp.sal &lt; 2000) then update emp set sal=sal*2 where current of c; elsif(v_temp.sal=5000) then delete from emp where current of c; end if; end loop; commit; end; 第49～50课：procedure1234567891011121314151617181920--只有create or replace procedure p -- is --替换了最初的declare语句--创建存储过程 create or replace procedure p is cursor c is select * from emp for update; begin for v_temp in c loop if(v_temp.deptno=10) then update emp set sal=sal+10 where current of c; elsif(v_temp.deptno=20) then update emp set sal=sal+20 where current of c; else update emp set sal=sal+50 where current of c; end if; end loop; commit; end; –执行上面的存储过程：exec p; 123456789101112--带参数的存储过程 create or replace procedure p (v_a in number,v_b number,v_ret out number,v_temp in out number) is begin if(v_a&lt;v_b) then v_ret:=v_b; else v_ret:=v_a; end if; v_temp:=v_temp+1; end; 12345678910111213141516171819--调用过程 declare v_a number:=10; v_b number:=20; v_ret number; v_temp number:=99; begin p(v_a,v_b,v_ret,v_temp); dbms_output.put_line(v_ret); dbms_output.put_line(v_temp); end; /* begin P; end 存储过程在创建过程中如果出现错误，仍然会创建，并且不会提示错误在哪儿，可以使用 show error来查看错误出现在哪儿。 */ 1234567891011121314----创建函数 create or replace function tax_sal (v_sal number) return number is begin if(v_sal&lt;2000) then return 0.10; elsif(v_sal&lt;3000) then return 0.20; else return 0.30; end if; end; –执行函数：select tax_sal(sal) from emp; 1234567--触发器 create table emp_log --创建一个表记录操作( uname varchar2(20), action varchar2(10), atime date); 123456789101112131415--after insert：插入之后触发事件--before insert：插入之前触发事件 create or replace trigger trig after/before insert or update or delete on emp2 for each row begin if inserting then insert into emp_log values(USER,'insert',sysdate); elsif updating then insert into emp_log values(USER,'update',sysdate); else insert into emp_log values(USER,'delete',sysdate); end if; end; --更新6行数据 update emp2 set sal = sal * 2 where deptno = 30;12--deptno被参考，违反约束条件 update dept set deptno=99 where deptno=10; 12--删除触发器：drop trigger trig; 123456--创建新的触发器： create or replace trigger trig after update on dept for each row begin update emp set deptno=:NEW.deptno where deptno=:OLD.deptno; end; 12--再更新：update dept set deptno=99 where deptno=10; ————–树状结构的存储和展示——————–123456789101112131415161718create table article(id number primary key,cont varchar2(4000),pid number,isleaf number(1), --0代表非叶子节点，1代表叶子节点alevel number(2));insert into article values(1,'蚂蚁大战大象',0,0,0);insert into article values(2,'大象被打趴下了',1,0,1);insert into article values(3,'蚂蚁也不好过',2,1,2);insert into article values(4,'瞎说',2,0,2);insert into article values(5,'没有瞎说',4,1,3);insert into article values(6,'怎么可能',1,0,1);insert into article values(7,'怎么没有可能',6,1,2);insert into article values(8,'可能性是很大的',6,1,2);insert into article values(9,'大象进医院了',2,0,2);insert into article values(10,'护士是蚂蚁',9,1,3);commit; –展现方法1234567891011121314create or replace procedure p (v_pid article.pid%type, v_level binary_integer) is cursor c is select * from article where pid = v_pid;v_preStr varchar2(1024) := '';begin for i in 1..v_level loop v_preStr := v_preStr || '****'; end loop; for v_article in c loop dbms_output.put_line(v_preStr||v_article.cont); if(v_article.isleaf = 0) thenp(v_article.id, v_level + 1); end if; end loop;end; –执行上面操作exec p(0,0); 结果： 蚂蚁大战大象 ****大象被打趴下了 ********蚂蚁也不好过 ********瞎说 ************没有瞎说 ********大象进医院了 ************护士是蚂蚁 ****怎么可能 ********怎么没有可能 ********可能性是很大的]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle（二） DML、DDL、事务控制语句]]></title>
    <url>%2F2017%2F10%2F22%2FOracle-DDL%2F</url>
    <content type="text"><![CDATA[第二十四课备份与恢复:1— backup scottexp2— create user12create user liuchao identified by liuchao default tablespace users quota 10M on users;grant create session , create table , create view to liuchao; 3— import the data;impDOS环境下:exp导出,imp导入12345678--drop user yugang cascade; //删除YUGANG 用户--cd \ --cd temp --delete *.* --exp --create user yugang indentified by yugang default tablespace users quota 10M on users //创建用户--grant create session,create table,create view to yugang //分配权限--imp the data 第一次输入的用户名密码为:yugang/yugang第二次输入的用户名密码为:导出数据的用户的用户名和密码 12--rollback //取消刚才的操作create table emp2 as select * from emp; //复制emp 插入数据操作：123insert into dept2 values(50 , 'game' , 'bj'); //插入全部值insert into dept2 (deptno , dname) values (60 , 'game2'); //插入部分值insert into dept2 select * from dept; //将一张表插入现在的表 第二十五课:rownumrownum是在Oracle中在表的后面加的一个尾字段,并且只能使用诸如rownum&lt;=n或rownum&lt;=n这样的形式,不能与&gt;或&gt;=相连接在一起 Oracle里面有一个尾字段叫–&gt;rownum 它是按照1，2，3…进行排列的，它不显示所以如果想求&gt;或者&gt;=的行数，可以给rownum起别名，就如下面这么做：select ename from (select rownum r , ename from emp) where r &gt; 10; 1.求薪水值最高的前5条记录.1select ename , sal from (select ename , sal from emp order by sal desc)where rownum &lt;=5; 2.求薪水值最高的第6~10条记录.123456select ename,sal from ( select ename,sal,rownum r from (select ename,sal from emp order by sal desc) ) where r &gt;=6 and r &lt;= 10; 第二十六课:homework_dml_transactionSQL面试题有三张表S、C、SCS(SNO、SNAME)代表（学号、姓名）C(CNO、CNAME、CTEACHER)代表（课号、课名、老师）SC(SNO、CNO、SCGRADE)代表（学号、课号、成绩）1.求出没选过郭富城老师的所有学生姓名2.列出2门以上（含2门）不及格的学生姓名及平均成绩3.既学过1号课程又学过2号课程的所有学生姓名 1.12345678910select sname from s join sc on (s.sno = sc.sno) join c on (c.cno = sc.cno) where c.cteacher &lt;&gt; '郭富城';``` 2.```sqlselect sname from s where sno in ( select sno from sc where scgrade &lt; 60 group by sno having count(*) &gt;= 2 ) 3.12345select sname from s where sno in ( select sno from sc where cno=1 and sno in (select distinct sno from sc where cno=2) ) update 更新表中的数据 把emp2这张表里，编号为10的，所有人的薪水提1倍12update emp2 set sal = sal*2, ename = ename||'-' where depton = 10//修改数据delete from dept2 where depton = 10; 四条语句讲完了：背过语法格式DDL– 数据定义语言，建表，建视图，建其他一些东西。1.创建表– create tablecreate table t (a varchar2(10));2.删除表 drop tabledrop table xx;跳过此阶段，先讲事务控制语句事务transaction代表一组不可分割的操作，要么全部执行，要么全部不执行，transaction起始于一条DML语句，结束于commit;语句，或者是DCL、DDL语句，在事务未提交前 可以通过rollback回滚事务，正常退出事务会自动提交，非正常退出事务会自动回滚。 第二十七课：create table 为什么有变长字符串Varchar2还要有定长字符串Char呢? 因为存在效率问题，用Char效率高，但浪费空间，这就是拿空间换时间Hashtable也是拿空间换时,创建一张表，并往里插入一条数据123456789101112131415161718192021222324create table stu( id number(6), name varchar2(20), sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) );create table stu ( id number(6), name varchar2(20) not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) ); 第二十八~三十课五个约束条件：非空 唯一 主键 外键 check主键：PRIMARY KEY 叫做：可以唯一标识整条记录的这样的一个东西从语法上来说主键的约束可以理解为：非空 ，唯一 两个的组合主键约束在逻辑意义上代表着单独的，每一条记录，看到主键就知道你是一条单独的不同的记录，是唯一的代表的记录 我们可以用两个字段的组合作为主键 外键(最麻烦的约束)：建立于一张表的两个字段，或者两张表的两个字段constraint stu_class_fk foreign key (class)references class (id) 外键关系：是建立在两个字段上，某一个字段会参考另外一个字段里面的值，如果另外一个字段里面没有这个值，你不能够把这个字段里面的值，设置成为其他的值。被参考的字段必须是主键，被其他人参考的字段不能作为删除条件主键约束和外键约束非常重要，老牢牢掌握其概念 1.唯一约束–&gt;在这个字段里面所有的记录不能取重复的值，每个值必须是唯一的 唯一约束后面 + unique ，当然也可以用constraint + 名字字段级的约束：把约束条件+在字段名的后面表级的约束：+在所有字段名的最后面 constraint stu_name_email_uni unique(email,name) 表示的是：这两个字段的组合不能重复 2.constraint//非空约束约束条件本身也是一个对象，本身约束条件你个可以为它起一个名字用constraint stu_name_nn not null –&gt;为约束条件not null起名字为：stu_name_nn如果不给约束条件起名字，系统会默认的给约束条件起一个名字 not null,unique(当某字段有unique约束时，可以插入空值，空值之间不重复)、主键、外键、 check约束123456789101112create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, //（字段级约束）sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50) unique //unique唯一约束 都为空可以) / //名字和email的组合不能重复：行级约束（放在字段后面）与表级约束（加在表后面）：12345678910111213create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_email_name_uni unique(name,email) //name,email的组合唯一约束（表级约束）) / 主键约束123456789101112131415161718192021222324252627create table student ( id number(6) primary key, name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_email_name_uni unique(name,email) ) / create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_id_pk primary key(id), constraint stu_email_name_uni unique(name,email) ) / 外键约束外键约束被参考的字段必须是主键。 先建表：123456create table class ( id number(4) primary key, name varchar2(20) not null ) / 第一种创建外键的方法：1234567891011121314create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4) references class(id), email varchar2(50), constraint stu_id_pk primary key(id), constraint stu_email_name_uni unique(name,email) ) / 第二种创建外键的方法：123456789101112131415create table student ( id number(6), name varchar2(20) constraint stu_name_nn not null, sex number(1), age number(3), sdate date, grade number(2) default 1, class number(4), email varchar2(50), constraint stu_id_pk primary key(id), constraint stu_class_fk foreign key (class) references class(id), constraint stu_email_name_uni unique(name,email) ) / 第三十一课：123456789alter table drop table //修改表结构；alter table student add(addr varchar2(100)); //添加结构alter table student drop(addr); //删除结构alter table student modify(addr varchar2(50)); //修改若addr字段中有的记录长度大于50，则修改不成功。 alter table student drop constraint stu_class_fk; //去掉约束条件alter table student add constraint stu_class_fk foreign key (class) references class (id); //添加约束条件drop table class; 第二范式的要求：当一张表里面有多个字段作为主键的时候，非主键的这些字段，不能依靠于部分主键(只能依赖整个组合的主键，不能依赖部分) 叫做：不能存在部分依赖第三范式的要求：不能存在传递依赖(除了主键之外的任何其他字段必须直接依赖于主键) 第三十二课：Oracle dictionaries1234567desc user_tables; select table_name from user_tables; select view_name from user_views; select constraint_name from user_constraints; select constraint_name,table_name from user_constraints; desc dictionary; //显示目录字典表select table_name from dictionary where table_name like ‘user%’; //显示目录字典表中’user’开头的名字 第三十三课：indexes_and_views索引可以提高读数据的效率，但会降低修改、写数据的效率,索引还会占用一定的存储空间12create index idx_stu_email on student(email); drop index idx_stu_email; 视图会带来一些维护的代价，比如表结构改了，那么视图也得跟着改变。视图还可以用来保护私有数据。123select index_name from user_indexes; select view_name from user_views; create view v$_stu as select id , name , age from student; 视图其实就是一个子查询，可以用来更新数据，但是不经常这么用，目的是为了简化查询，保护私有数据。 第三十四课：sequences and review序列可以自动增长，在sql server中有identity，mysql中有auto_increment1234567create table article ( id number, title varchar2(1024), cont long ) / 如何保证插入数据时id不重复？select max(id) from article;这样做也不行，如果有多个线程同时访问数据，则可能会出现数据不一致的现象，比方说第一个用户查询出最大id值是100，第二个用户也查询出最大id是100，然后第二个用户新插入一条记录：id是101，然后第一个用户也插入了一条记录：id也是101可以用Oracle的sequencecreate sequence seq_article_id;多个表之问可以共用一个序列，但是一般情况下为每个字段分别建立一个序列sequence有两个属性CurrVal、NextVal12345select seq.nextvalue from dual; insert into article values(seq.nextval,'y','yy'); insert into article values(seq.nextval,'x','xx'); insert into article values(seq.nextval,'z','zz'); insert into article values(seq.nextval,'q','qq'); 删除序列：drop sequence seq; 第三十五课：三范式第一范式：1.每个表都要有主键2.列不可分，比如：1234567891011121314create table stu ( id number, name varchar2(20), age number ) / insert into stu values(1,'yu',21); create table stu2 ( inf long ) / insert into stu2 values('1_yu_21'); 虽然表stu2可以字符串解析后可以达到和表stu一样的效果，但是显然第一种方法更好，查询数据更加方便，而表stu2违反了第一范式的列不可分原则。 第二范式：当有两个以上字段作主键时，非主键字段不能部分依赖于主键字段，如有一个需求，一名老师教多名学生，一名学生可以选多个老师的课。然后设计了一张表，有以下字段（老师编号、学生编号、老师姓名、学生姓名等），其中以老师编号和学生编号作联合主键，则些表就存在部分依赖，老师姓名部分依赖于老师编号，不满足第二范式，有数据冗余。要解决这个问题可以设计三张表：老师表，学生表，老师学生关系表。 第三范式：不能存在传递依赖，如有一张表有以下字段：（学号、姓名、班级号、班级名称、班级位置），其中学号为主键，则班级号依赖于学号，每个学生都有相应的班级号，但是班级名称、班级位置 是依赖于班级号，即它们通过班级号传递依赖于学号，不满足第三范式。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle（一） Select语句]]></title>
    <url>%2F2017%2F10%2F14%2FOracle-Select%2F</url>
    <content type="text"><![CDATA[第一课：口令超级管理员：sqlplus sys/bjsxt as sysdba普通管理员：system/manager普通用户：scott/tiger大数据用户：sh/sh 在cmd下敲：12sqlplus sys/bjsxt as sysdba //以sys超级管理员的权限去登录bjsxt 这个数据库alter user scott account unlock; //(解锁)用户已更改。 第二课：SQL语言Sql语言是在数据库地下进行操作的专门的语言，sql语言本身是一种标准语言，它是一个国际标准，它定义了套标准SQL1922， SQL1999，SQL在大多数数据库上通用，或许有轻微的改变包含四大语句： 查询语句 查询语句只有一种就是select语句 DML语句 DML语句包含Insert,Update,Delete等常用语句 DDL语句 DDL语句包含Create, Alter， Drop等常用语句 事务控制语句 包含Commit， Rollback等常用语句还有一大类语句：叫DCL语句（Data Control Language），主要用于权限的分配与回收，由于与开发关系不是十分密切，不做重点讲解Select语句就是从表里把数据选出来首先熟悉试验中的数据第一条语句：desc emp; desc 表名; 列出 表头 == 字段 == 列Varchar2 可变字符串支持国际化 NUMBER(7,2) 7位的数字，2位的小数每行显示的宽度setlinesize 200; 显示的页数 setpagesize 30; 第三课：table_structures12desc 表名 //描述表select * from 表名 //查看表数据 第四课：select语句1.含有别名的sql语句例子1：1select ename, sal&amp;#42;12 annual_sal from emp; 例子2：1Select ename, sal&amp;#12 “Annual_sal” from emp; 如果想让别名强制大小写混合可以使用双引号 例子3：1Select ename, sal&amp;#12 “Annual sal” from emp; 如果想让别名中有空格也使用双引号 2.1desc dual，select 2*3 from dual，dual是系统自带的一张空表，计算数据时可以使用该表 3.任何含有空值的算术表达式的计算结果是空值 4.select ename||sal from emp; 字符串连接符：|| 5.select ename || &#39;abcdefg&#39; from emp; 6.select ename || &#39;abcd&#39;&#39;efg&#39; from emp;当字符串中含有单引号时，可用两个单引号代表一个单引号 7.set linesize 200;--用于设定每行显示的宽度 8.set pagesize 30;--设置显示的页数 9.select syadate from dual;//显示系统时间 第五课：distinct1.select distinct deptno from emp; //把deptno值重复的不显示出来 2.select distinct deptno,job from emp; //把deptno,job都重复的都不显示出来； 第六课：where1.select * from emp where empno = 10; //显示部门编号为10的所有员工的详细信息 2.select * from emp where empno &lt;&gt; 10;//&lt;&gt;是不等于 3.select * from emp where ename = &#39;KING&#39;; //显示名字为KING的员工的详细信息, 判断字符串是否相等时，字符串要用单引号引起来，单引号中字符串内容是要区分大小写的；比较的按字母顺序 4.select * from emp where comm is (not) null; //为空值的表项查询 5. AND， OR， NOT例1：Select ename, deptno, sal from emp wheredeptno = 10 and sal &gt; 1000; 查询部门标号为10 并且薪水&gt;1000 的员工 例2：Select ename, deptno, job from emp where deptno = 10 or job = ‘CLEARK; 查询部门编号为10或者工作岗位为CLERK 的员工 例3：select * from emp where sal (not) between 800 and 1500; //取出薪水位于800和1500(包含800和1500)之间的雇员名字和薪水 6.In语句：用于塞选某一个值12select * from emp where ename (not) in ('smith','philip','jay'); //把名字为SMITH, ALLEN, KING 的雇员取出来Select ename, sal from emp where sal in(800, 1250, 1500, 2000); //把薪水是800，1250， 1500， 2000 的雇员信息取出来 7.1select * from emp where hiredate &gt; '20-2 月 1820'； //20-2 月 1820后的时间, 如果想用自己定义的日期格式，可以使用to_char or to_date函数; Oracle默认的日期格式为：DD-MON-RR 8.模糊查询使用like关键字，和通配符 % 表示0个或多个字符，&#95;表示1个字符, “?”为0个或1个123select * from emp where ename like '_A%'; // 查询第二字母中含有 A 的雇员 select * from emp where ename like '_\%a%'; //系统默认转义符是\,可以自己指定转义符 select * from emp where ename like '_$%a%' escape '$'; 第七课：order by 使用order by对数据进行排序123select * from dept; select * from dept order by dept desc; //(默认为asc) desc为降序排列，asc为升序 select ename, sal, deptno from emp where sal &gt; 2000 order by deptno asc,ename desc; 第八课：sql_function1.select ename,sal*12 annual_sal from emp where ename not like &#39;_A%&#39; and sal &gt; 1500 order by sal desc; 2.select lower(ename) from emp; // Lower()函数 将字符串全部转换成小写,把ename 转换为小写值 3.select ename from emp where lower(ename) like &#39;_a%&#39;; //把ename的值第二个字母为A或a输出 4.select substr(ename,2,3) from emp; //从第二字符截，一共截三个字符。 5.select chr(65) from dual; //求一个与某个ASCII码值对应的字符,结果为A 6.select ascii(&#39;a&#39;) from dual; //求一个字符的ASCII码值,结果为65 7.round()函数 对参数值进行四舍五入的操作例子1： Select round(23.652)from dual; //对23.652进行四舍五入操作 24例子2： Select round(23.652,2) from dual; //对23.652四舍五入到小数点后2位 23.65例子3： Select round(23.652,-1) from dual; //用负数指定小数点前面几位,对23.652四舍五入到小数点前1位 20 &#42;8.to_char() 用于将数字或日期转换成特定的字符串，To_char()有两个参数：第一个参数：需要进行转换的日期或数字第二个参数：特定的转换格式，对于数字有一下几个格式可以指定：9 代表数字，若果该位没有数字则不进行显示，但对于小数点后面的部分仍会强制显示0 代表一位数字，如果该位没有数字则强制显示0 1234select to_char(sal,'$99,999.9999') from emp; //to_char函数主要用于对日期和数字格式化 $16,000.0000select to_char(sal,'$0000,000.0000') from emp; //结果$0016,000.0000select to_char(sal,'L99,999.9999') from emp; //人民币符号，L代表本地符号。 select birthdate from emp; 显示为：BIRTHDATE&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;22-3月-87改为：select to_char(birthdate,&#39;YYYY-MM-DD HH24:MI:SS&#39;) from emp; //24制的 没有24为12制的 格式控制符 含义YYYY、YY —————————– 代表4位，2位数字的年份MM —————————– 用数字表示的月份MON —————————– 月份的缩写对中文月份来说就是全称DD —————————– 数字表示的日DY —————————– 星期的缩写，对中文的星期来说就是全称HH24、HH12 —————————12小时或者24小时进制下的时间MI —————————– 分钟数SS —————————– 秒数 &#42;9.to_data函数将特定的字符串转换成日期格式，这个函数有两个参数:第一参数：自定义的日期字符串第二参数：指定这个字符串的格式1select ename,birthdate from emp where birthdate &gt; to_date('1987-3-22 12:00:00','YYYY-MM-DD HH24:MI:SS'); //不能直接写birthdate&gt;'1987-2-22 11:22:33'会出现格式不匹配，因为表中格式为DD-MM月－YY 10.Select * from emp where sal &gt; to_number(‘$1,200.00’,‘$9,999.99’); //求薪水大于1200的员工信息 &#42;11.nvl()函数用来处理空值，这个函数有两个参数：第一参数：字段名或表达式，如果这个参数值为null，就返回第二参数值，否则返回第一参数值1select ename, sal*12+nvl(comm,0) from emp //这样防止comm为空时，sal*12相加也为空的情况 第九课：Group function 组函数1.select max(sal) from emp; //最大值 2.select min(sal) from emp; //最小值 3.select to_char(avg(sal), &#39;$999,999,999.99&#39;) from emp; //平均值 4.select round(sum(sal),2) from emp; //求和 5.select count(*) from emp where sal &gt; 1500; //求记录数 6.select count(comm) from emp; //Count()可以对单独字段使用，得到的是所有非空记录的数量 7.select count(distinct deptno) from emp; //Count()可以和distinct一起使用，得到所有唯一值记录的数量 第十课：Group by语句1.select avg(sal) from emp group by deptno; //首先将现有数据按照部门进行分组，然后再计算每个组员工的平均薪水 2.select deptno,avg(sal) from emp group by deptno; 3.select deptno,job,max(sal) from emp group by deptno,job; //按照部门，和职位的最大薪水进行分组 4.求薪水值最高的人的名称select ename,max(sal) from emp; //出错，因为max只能有一个值，但是等于max的值可能有好几个，不能匹配。 可以写成select ename from emp where sal=(select max(sal) from emp);Group by 语句应注意，出现在select中的字段，如果没有出现在组函数中，必须出现在Group by语句中。 第十一课：Having对分组结果筛选1.where是对单条记录进行筛选,Having是对分组结果进行筛选select avg(sal),deptno from emp group by deptno having avg(sal) &gt; 2000; 2.查询工资大于2000的雇员,按照部门编号进行分组,分组后平均薪水大于1500,按工资倒序排列select deptno,avg(sal) from emp where sal &gt; 2000 group by deptno having avg(sal) &gt;1500 order by avg(sal) desc; ///////select-where-group by- having-order by//////// 第十二课:子查询1.select 语句中嵌套select 语句,求哪些人工资在平均工资之上.select ename,sal from emp where sal &gt; (select avg(sal) from emp); 2.查找每个部门挣钱最多的那个人的名字.select ename, deptno from emp where sal in (select max(sal) from emp group by deptno); 查询会多值.正确写法是: 应把select max(sal),deptno from emp group by deptno当成一个表,给这个表起名叫t,然后将两张表连接起来就可以了。语句如下:123select ename,sal from emp join (select max(sal) max_sal,deptno from emp group by deptno) t on (emp.sal = t.max_sal and emp.deptno = t.deptno); 第十三课:self_table_connection自连接：为同一张表起不同的别名，然后当成两张表来用1select e1.ename,e2.ename from emp e1,emp e2 where e1.mgr = e2.empno; //求这个人的名字和他经理人的名字(自连接) 第十四课:SQL1999_table_connection1.select ename,dname,grade from emp e,dept d,sqlgrade s where e.deptno=d.deptno and e.sal between s.losal and s.hisal and job &lt;&gt; &#39;CLERK&#39;;这种写法没有把过滤条件和连接条件分开来,由于这个原因,sql1999标准推出来了. 2.select ename,dname from emp,dept;(旧标准) select ename,dname from emp cross join dept;(1999标准) 3.等值连接 123select ename,dname from emp,dept where emp.deptno = dept.deptno;(旧) select ename,dname from emp join dept on (emp.deptno = dept.deptno);select ename , dname from emp join dept using (deptno); //不推荐使用 4.非等值连接： select ename,grade from emp e join salgrade s on(s.sal between s.losal and s.hisal); 5.select ename,dname,grade from emp e join dept d on(e.deptno = d.deptno) join salgrade s on (e.sal between s.losal and s.hisal) where ename not like &#39;_A%&#39;; 6.select e1.ename,e2.ename from emp e1 join emp e2 on (e1.mgr = e2.deptno); 7.select e1.ename,e2.ename from emp e1 left (outer) join emp e2 on (e1.mgr = e2.empno); //left outerjoin或者left join都可以！即为左连接。 8.select ename,dname from emp e right outer join dept d on (e.deptno = d.deptno); //右连接 9.select ename,dname from emp e full join dept d on (e.deptno = d.deptno); //全连接 第十六至二十三课:求部门平均薪水等级1.A.求部门平均薪水的等级select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal); 2.求部门平均的薪水等级select deptno,avg(grade) from (select deptno,ename,grade from emp e join salgrade s on (emp.sal between s.losal and s.hisal)) t group by deptno; 3.哪些人是经理select ename2 from (select e1.ename ,e1.mgr mgr1,e2.ename ename2 from emp e1 join emp e2 on (e1.mgr = e2.empno)) t join emp on (t.mgr1 = emp.empno) select ename from emp where empno in (select distinct mgr from emp) 4.不准用组函数,求薪水的最高值select distinct sal from emp where sal not in( select distinct e1.sal from emp e1 join emp e2 on (e1.sal &lt; e2.sal) ) ; 5.求平均薪水最高的部门编号123456789101112131415//方法1select deptno,avg_sal from ( select deptno,avg(sal) avg_sal from emp group by deptno ) where avg_sal = ( select max(avg_sal) from ( select deptno,avg(sal) avg_sal from emp group by deptno ) ) ;//方法2select deptno,avg_sal from (select deptno,avg(sal) avg_sal from emp group by deptno) where avg_sal = (select max(avg(sal)) from emp group by deptno) ; 6.求平均薪水最高的部门名称12345678910select dname from dept where deptno = ( select deptno from (select deptno,avg(sal) avg_sal from emp group by deptno) where avg_sal = ( select max(avg_sal) from (select deptno,avg(sal) avg_sal from emp group by deptno) ) ) ; 7.求平均薪水等级最低的部门的部门名称错误写法:1234567select min(avg_grade),deptno from ( select deptno,avg(grade) avg_grade ( select ename,deptno,grade from emp e join salgrade s on (e.sal between s.losal and s.hisal) ) group by deptno ) group by deptno 正确写法:123456789101112131415select dname,t1.deptno,grade,avg_sal from ( select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal) ) t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select min(grade) from ( select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal) ) ) ; 错误写法：1234567891011121314select dname,t1.deptno,grade,avg_sal from ( select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal) ) t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select min(grade) from ( t1) ) ;//报错：表或视图不存在。 8.视图:view就是一张虚表,一个子查询 conn sys/bjsxt as sysdba; grant create table,create view to scott; conn scott/tiger;创建视图1234create view v$_dept_avg_sal_info as select deptno,avg_sal,grade from (select deptno,avg(sal) avg_sal from emp group by deptno) t join salgrade s on (t.avg_sal between s.losal and s.hisal); 使用视图后可以简写123456select dname,t1.deptno,grade,avg_sal from v$_dept_avg_sal_info t1 join dept on (t1.deptno = dept.deptno) where t1.grade = ( select min(grade) from v$_dept_avg_sal_info ); 9.求比普通员工最高薪水还要高的经理人的名称先求普通员工的最高薪水12345678910select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null); select ename from emp where empno in (select distinct mgr from emp where mgr is not null) and sal &gt; ( select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null) ); 思考题： 求部门经理人中平均薪水最低的部门名称 求薪水最高的前五名雇员 求薪水最高的第6到第10名雇员（重点掌握） 练习：求最后入职的5名员工 面试题：比较效率select &#42; from emp where deptno = 10 and ename like ‘%A%’; （效率比较高）select &#42; from emp where ename like ‘%A%’ and deptno = 10;（Oracle可能会优化，直接把这条语句转换成上面那条，使效率提高）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（九） 接口]]></title>
    <url>%2F2017%2F10%2F14%2FThinkingInJava9%2F</url>
    <content type="text"><![CDATA[接口和内部类为我们提供了一种将接口与实现分离更加结构化的方法。 抽象类是类与接口之间的一种中庸之道。 9.1 抽象类和抽象方法Java提供了一个叫做抽象方法的机制，类似于C++中的纯虚函数，这种方法仅有声明而没有方法体：abstract void f();抽象类的特点： 如果一个类包含一个或多个抽象方法，则必须被限定为抽象类。（反过来，如果一个类被定义为abstract的，不一定要有抽象方法） 不能实例化抽象类。 继承抽象类，如果没有实现所有的抽象方法，那么还是抽象类。 9.2 接口接口被用来建立类与类之间的协议（某些面向对象编程语言使用关键字protocol来完成这个功能） interface产生一个完全抽象的类，允许创建者确定方法名、参数列表和返回类型。但只提供形式，不提供实现。（Java SE8提供了default关键字，可以定义默认的方法，该方法提供实现）。 接口可以有域，但这些域被隐式的声明为static 和final 可以在接口中显示的把方法声明为public，默认就是public，而且必须是public，方法不能是static和final的。 9.3 完全解耦创建一个能够根据所传递的参数对象的不同而具有不同行为的方法，被称为策略设计模式。这类方法包含所要执行的算法中固定不变的部分，而“策略”包含变化的部分。策略就是传递进去的参数对象，包含要执行的代码，可以根据传递的参数的对象产生不同的行为。 复用代码的第一种方式就是客户端程序员遵循该接口来编写他们的类；第二种方式：如果无法修改使用的类，则可以使用适配器设计模式。 9.4 多重继承接口可以实现多重继承，implements可以接多个接口，用逗号分开即可。 接口使用的核心原因：能向上转型为多个基类型（以及由此带来的灵活性）；与抽象基类相同，防止客户端程序员创建该类的对象。 应该使用接口还是抽象类：如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。事实上，如果知道某事物应该成为一个基类，那么第一选择应该是使它成为一个接口。 9.5 通过继承来扩展接口1234567891011interface Monster&#123; void menace();&#125;interface DangerousMonster extends Monster&#123; void destroy();&#125;interface Vampire extends DangerousMonster , Monster&#123; void drinkBlood();&#125; 在上面的例子中，在Vampire中使用的语法仅适用于接口继承。一般情况下，只可以将extends用于单一类，但是可以引用多个基类接口。就像所看到的那样，只需用逗号将接口名一一分割开即可。 9.5.1 组合接口时的名字冲突在打算组合不同接口中使用相同的方法名通常会造成代码可读性的混乱，应该尽量避免这种情况。 1234567891011interface I1&#123;void f();&#125;interface I2&#123;int f(int i);&#125;interface I3&#123;int f();&#125;class C2 implements I1,I2&#123; public void f()&#123;&#125; public int f(int i)&#123;return 1;&#125;&#125;//class C5 extends C implements I1 &#123;&#125; //出错//interface I4 extends I1 , I3 &#123;&#125; //出错 9.6 适配接口让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方式。这就是使用接口而不是类的强大之处。 9.7 接口中的域放入接口中的任何域都自动是static和final的，所以接口就成为了一种很便捷的创建常量组的工具（Java SE5出现了enum）。接口中的域是public的。 9.7.1 初始化接口中的域接口中定义的域不能是“空final”，但是可以被非常量表达式初始化。 如：1234public interface RandVals&#123; Random RAND = new Random(47); int RANDOM_INT = RAND.nextInt(10);&#125; 这个例子中，域不是接口的一部分，值存于静态存储区域内。 9.8 嵌套接口接口中成员默认就是public的，接口嵌套在接口中只能是public的。类中嵌套接口或类可以是4种访问权限。当实现某个接口时，并不需要实现嵌套在其内部的任何接口。而且，private接口不能在定义它的类之外被发现，返回private接口仅可以被定义它的类的方法使用。 9.9 接口与工厂生成遵循某个接口的对象的典型方式就是工厂方法设计模式。通过工厂方法模式，我们的代码将完全与接口的实现分离，这就使得我们可以透明地将某个实现替换为另一个实现。 优先选择类而不是接口，从类开始，如果接口的需要性变得非常明确，那么就进行重构。接口是一种重要的工具，但他们容易被滥用。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 默认方法（Default Methods）]]></title>
    <url>%2F2017%2F10%2F14%2FJavaSE8defaultMethod%2F</url>
    <content type="text"><![CDATA[Java 8 引入了新的语言特性——默认方法（Default Methods）。 Default methods enable new functionality to be added to the interfaces of libraries and ensure binary compatibility with code written for older versions of those interfaces.默认方法允许您添加新的功能到现有库的接口中，并能确保与采用旧版本接口编写的代码的二进制兼容性。默认方法是在接口中的方法签名前加上了 default关键字的实现方法。一个简单的例子123456789101112131415interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;class ClassA implements InterfaceA &#123;&#125;public class Test &#123; public static void main(String[] args) &#123; new ClassA().foo(); // 打印：“InterfaceA foo” &#125;&#125; ClassA 类并没有实现 InterfaceA 接口中的 foo 方法，InterfaceA 接口中提供了 foo 方法的默认实现，因此可以直接调用 ClassA 类的 foo 方法。 为什么要有默认方法在 java 8 之前，接口与其实现类之间的 耦合度 太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为 java 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。1234567String[] array = new String[] &#123; "hello", ", ", "world",&#125;;List&lt;String&gt; list = Arrays.asList(array);list.forEach(System.out::println); // 这是 jdk 1.8 新增的接口默认方法 这个 forEach 方法是 jdk 1.8 新增的接口默认方法，正是因为有了默认方法的引入，才不会因为 Iterable 接口中添加了 forEach 方法就需要修改所有 Iterable 接口的实现类。 下面的代码展示了 jdk 1.8 的 Iterable 接口中的 forEach 默认方法： 12345678910111213package java.lang;import java.util.Objects;import java.util.function.Consumer;public interface Iterable&lt;T&gt; &#123; default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125;&#125; 默认方法的继承和其它方法一样，接口默认方法也可以被继承。123456789101112131415161718192021222324252627282930313233343536interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;interface InterfaceB extends InterfaceA &#123;&#125;interface InterfaceC extends InterfaceA &#123; @Override default void foo() &#123; System.out.println("InterfaceC foo"); &#125;&#125;interface InterfaceD extends InterfaceA &#123; @Override void foo();&#125;public class Test &#123; public static void main(String[] args) &#123; new InterfaceB() &#123;&#125;.foo(); // 打印：“InterfaceA foo” new InterfaceC() &#123;&#125;.foo(); // 打印：“InterfaceC foo” new InterfaceD() &#123; @Override public void foo() &#123; System.out.println("InterfaceD foo"); &#125; &#125;.foo(); // 打印：“InterfaceD foo” // 或者使用 lambda 表达式 ((InterfaceD) () -&gt; System.out.println("InterfaceD foo")).foo(); &#125;&#125; 接口默认方法的继承分三种情况（分别对应上面的 InterfaceB 接口、InterfaceC 接口和 InterfaceD 接口）：&nbsp;&nbsp;• 不覆写默认方法，直接从父接口中获取方法的默认实现。&nbsp;&nbsp;• 覆写默认方法，这跟类与类之间的覆写规则相类似。&nbsp;&nbsp;• 覆写默认方法并将它重新声明为抽象方法，这样新接口的子类必须再次覆写并实现这个抽象方法。 默认方法的多继承Java 使用的是单继承、多实现的机制，为的是避免多继承带来的调用歧义的问题。当接口的子类同时拥有具有相同签名的方法时，就需要考虑一种解决冲突的方案。12345678910111213141516171819202122232425262728293031323334353637interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;interface InterfaceB &#123; default void bar() &#123; System.out.println("InterfaceB bar"); &#125;&#125;interface InterfaceC &#123; default void foo() &#123; System.out.println("InterfaceC foo"); &#125; default void bar() &#123; System.out.println("InterfaceC bar"); &#125;&#125;class ClassA implements InterfaceA, InterfaceB &#123;&#125;// 错误//class ClassB implements InterfaceB, InterfaceC &#123;//&#125;class ClassB implements InterfaceB, InterfaceC &#123; @Override public void bar() &#123; InterfaceB.super.bar(); // 调用 InterfaceB 的 bar 方法 InterfaceC.super.bar(); // 调用 InterfaceC 的 bar 方法 System.out.println("ClassB bar"); // 做其他的事 &#125;&#125; 在 ClassA 类中，它实现的 InterfaceA 接口和 InterfaceB 接口中的方法不存在歧义，可以直接多实现。 在 ClassB 类中，它实现的 InterfaceB 接口和 InterfaceC 接口中都存在相同签名的 foo 方法，需要手动解决冲突。覆写存在歧义的方法，并可以使用 InterfaceName.super.methodName(); 的方式手动调用需要的接口默认方法。 接口继承行为发生冲突时的解决规则值得注意的是这么一种情况：12345678910111213141516171819202122232425interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;interface InterfaceB extends InterfaceA &#123; @Override default void foo() &#123; System.out.println("InterfaceB foo"); &#125;&#125;// 正确class ClassA implements InterfaceA, InterfaceB &#123;&#125;class ClassB implements InterfaceA, InterfaceB &#123; @Override public void foo() &#123;// InterfaceA.super.foo(); // 错误 InterfaceB.super.foo(); &#125;&#125; 当 ClassA 类多实现 InterfaceA 接口和 InterfaceB 接口时，不会出现方法名歧义的错误。当 ClassB 类覆写 foo 方法时，无法通过 InterfaceA.super.foo(); 调用 InterfaceA 接口的 foo方法。 因为 InterfaceB 接口继承了 InterfaceA 接口，那么 InterfaceB 接口一定包含了所有 InterfaceA 接口中的字段方法，因此一个同时实现了 InterfaceA 接口和 InterfaceB 接口的类与一个只实现了 InterfaceB 接口的类完全等价。 这很好理解，就相当于 class SimpleDateFormat extends DateFormat 与 class SimpleDateFormat extends DateFormat, Object 等价（如果允许多继承）。 或者换种方式理解：1234567891011121314151617181920class ClassC &#123; public void foo() &#123; System.out.println("ClassC foo"); &#125;&#125;class ClassD extends ClassC &#123; @Override public void foo() &#123; System.out.println("ClassD foo"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; ClassC classC = new ClassD(); classC.foo(); // 打印：“ClassD foo” &#125;&#125; 这里的 classC.foo(); 同样调用的是 ClassD 类中的 foo 方法，打印结果为“ClassD foo”，因为 ClassC 类中的 foo 方法在 ClassD 类中被覆写了。 在上面的 ClassA 类中不会出现方法名歧义的原因是所谓“存在歧义”的方法其实都来自于 InterfaceA 接口，InterfaceB 接口中的“同名方法”只是继承自 InterfaceA 接口而来并对其进行了覆写。ClassA 类实现的两个接口不是两个毫不相干的接口，因此不存在同名歧义方法。 而覆写意味着对父类方法的屏蔽，这也是 Override 的设计意图之一。因此在实现了 InterfaceB 接口的类中无法访问已被覆写的 InterfaceA 接口中的 foo 方法。 这是当接口继承行为发生冲突时的规则之一，即 被其它类型所覆盖的方法会被忽略。 如果想要调用 InterfaceA 接口中的 foo 方法，只能通过自定义一个新的接口同样继承 InterfaceA 接口并显示地覆写 foo 方法，在方法中使用 InterfaceA.super.foo(); 调用 InterfaceA 接口的 foo 方法，最后让实现类同时实现 InterfaceB 接口和自定义的新接口，代码如下：12345678910111213141516171819202122232425262728interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125;interface InterfaceB extends InterfaceA &#123; @Override default void foo() &#123; System.out.println("InterfaceB foo"); &#125;&#125;interface InterfaceC extends InterfaceA &#123; @Override default void foo() &#123; InterfaceA.super.foo(); &#125;&#125;class ClassA implements InterfaceB, InterfaceC &#123; @Override public void foo() &#123; InterfaceB.super.foo(); InterfaceC.super.foo(); &#125;&#125; 注意！ 虽然 InterfaceC 接口的 foo 方法只是调用了一下父接口的默认实现方法，但是这个覆写 不能省略，否则 InterfaceC 接口中继承自 InterfaceA 接口的隐式的 foo 方法同样会被认为是被 InterfaceB 接口覆写了而被屏蔽，会导致调用 InterfaceC.super.foo() 时出错。 通过这个例子，应该注意到在使用一个默认方法前，一定要考虑它是否真的需要。因为 默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。滥用默认方法可能给代码带来意想不到、莫名其妙的错误。 接口与抽象类当接口继承行为发生冲突时的另一个规则是，类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的。 1234567891011121314151617181920212223242526272829303132interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125; default void bar() &#123; System.out.println("InterfaceA bar"); &#125;&#125;abstract class AbstractClassA &#123; public abstract void foo(); public void bar() &#123; System.out.println("AbstractClassA bar"); &#125;&#125;class ClassA extends AbstractClassA implements InterfaceA &#123; @Override public void foo() &#123; InterfaceA.super.foo(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; ClassA classA = new ClassA(); classA.foo(); // 打印：“InterfaceA foo” classA.bar(); // 打印：“AbstractClassA bar” &#125;&#125; ClassA 类中并不需要手动覆写 bar 方法，因为优先考虑到 ClassA 类继承了的 AbstractClassA抽象类中存在对 bar 方法的实现，同样的因为 AbstractClassA 抽象类中的 foo 方法是抽象的，所以在 ClassA 类中必须实现 foo 方法。 虽然 Java 8 的接口的默认方法就像抽象类，能提供方法的实现，但是他们俩仍然是 不可相互代替的：&nbsp;&nbsp;• 接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。&nbsp;&nbsp;• 接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法，无法保存 状态（state），抽象方法中可以。&nbsp;&nbsp;• 抽象类不能在 java 8 的 lambda 表达式中使用。&nbsp;&nbsp;• 从设计理念上，接口反映的是 “like-a” 关系，抽象类反映的是 “is-a” 关系。 接口静态方法除了默认方法，Java 8 还在允许在接口中定义静态方法。123456789101112131415interface InterfaceA &#123; default void foo() &#123; printHelloWorld(); &#125; static void printHelloWorld() &#123; System.out.println("hello, world"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; InterfaceA.printHelloWorld(); // 打印：“hello, world” &#125;&#125; 其他注意点&nbsp;&nbsp;• default 关键字只能在接口中使用（以及用在 switch 语句的 default 分支），不能用在抽象类中。&nbsp;&nbsp;• 接口默认方法不能覆写 Object 类的 equals、hashCode 和 toString 方法。&nbsp;&nbsp;• 接口中的静态方法必须是 public 的，public 修饰符可以省略，static 修饰符不能省略。&nbsp;&nbsp;• 即使使用了 java 8 的环境，一些 IDE 仍然可能在一些代码的实时编译提示时出现异常的提示（例如无法发现 java 8 的语法错误），因此不要过度依赖 IDE。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（八） 多态]]></title>
    <url>%2F2017%2F10%2F14%2FThinkingInJava8%2F</url>
    <content type="text"><![CDATA[在面向对象的程序设计语言当中，多态是继数据抽象和继承之后的第三种基本特征。 多态通过分离做什么和怎么做，从另一个角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能创建可扩展的程序。“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。而多态的作用则是消除类型之间的耦合关系。 多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出来而来的。这种区别是根据方法行为的不同来表现出来的，虽然这些方法都可以通过同一个基类来调用。 8.2 转机8.2.1 方法调用绑定将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定，叫做前期绑定。后期绑定，它的含义就是在运行时根据对象的类型进行绑定，后期绑定也叫动态绑定或者运行时绑定。编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体。 Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着通常情况下，我们不必去判定是否要进行后期绑定，因为它会自动发生。 8.2.3 可扩展性在一个设计良好的OOP程序中，大多数或者所有方法都只会与积累接口通信。这样的程序是可扩展的，因为可以从通用的基类及惩处新的数据类型，从而添加一些新的功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。 我们所做对的代码修改，不会对程序中其他不应受到影响的部分产生破坏。多态是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。 8.2.4 缺陷：“覆盖”私有方法只有非private方法才可以被覆盖；但是还需要密切注意覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切地说，在导出类中，对于基类中的private方法，最好采用不同的名字。 8.2.5 缺陷：域与静态方法只有普通方法的调用是多态的。 1234567891011121314151617181920212223class Super &#123; public int field = 0; public int getField()&#123;return field; &#125;&#125;class Sub extends Super&#123; public int field = 1; public int getField()&#123;return field;&#125; public int getSuperField()&#123;return super.field;&#125;&#125;public class FieldAccess&#123; public static void main(String[] args)&#123; Super sup = new Sub(); System.out.println("sup.field = " + sup.field + ", sup.getField() = " + sup.getField()); Sub sub = new Sub(); System.out.println("sub.field = " + sub.field + ",sub.getField() = " + sub.getField() + ",sub.getSuperField() = " + sub.getSuperField()); &#125;&#125;/*Output:sup.field = 0, sup.getField() = 1sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0*/ 上面的例子中，当Sub对象转型为Super引用的时候，任何域访问操作都将由编译器解析，因此不是多态。在本例中，为Super.field和Sub.field分配了不同的存储空间。这貌似是一个令人混淆的问题，但是在实际操作中从来都不会发生。首先通常会将所有的域都设置成private；其次也会将基类和导出类的域赋予不同的名称。 如果某个方法是静态的，它的行为就不具有多态性。 8.3 构造器和多态8.3.2 继承与清理第七章已经讲过了。然而，如果成员对象中存在于其它一个或多个对象共享的情况，问题就复杂了。这种情况下，也许就必须使用引用计数来跟踪仍旧访问着共享对象的对象数量了，当共享它的对象全部dispose，引用计数为0时，才会dispose。 8.3.3 构造器内部的多态方法的行为如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。然而这个调用的效果是难以预料的，因为被覆盖的方法在对象被完全构造之前就会被调用。这可能会造成一些难以发现的隐藏错误。 123456789101112131415161718192021222324class Glyph&#123; void draw()&#123;System.out.println("Glyph.draw()");&#125; Glyph()&#123; draw(); &#125;&#125;class RoundGlyph extends Glyph&#123; private int radius = 1; Roundglyph(int r)&#123; radius = r; System.out.println("Roundglyph.Roundglyph(),radius=" + radius); &#125; void draw()&#123; System.out.println("Roundglyph.draw(),radius=" + radius); &#125;&#125;public class PolyConstructors&#123; public static void main(String[] args)&#123; new RoundGlyph(5); &#125;&#125;/* output:Roundglyph.draw(),radius=0Roundglyph.RoundGlyph(),radius=5*/ 在上面的例子中，基类Glyph的构造器调用draw()方法时，radius还没有被初始化，不是1，而是0。这可能导致程序无法正常运转。 在编写构造器的时候有一条有效的准则：“用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法”。构造器中唯一能够安全调用的那些方法使基类中的final方法（也适用于private方法，它们自动属于final方法） 8.4协变返回类型Java 5中添加了协变返回类型，它表示在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。如：12345678910class Grain&#123;&#125;class Wheat extends Grain&#123;&#125;class Mill&#123; Grain process()&#123;return new Grain();&#125;&#125;class WheatMill extends Mill&#123; Wheat process()&#123;return new Wheat();&#125;&#125; 8.5 用继承进行设计组合更加灵活，因为它可以动态选择类型（因此也就选择了行为）；相反，继承在编译时就需要知道确切的类型。 12345678910111213141516171819202122class Actor&#123; public void act()&#123;&#125;&#125;class HappyActor extends Actor&#123; public void act()&#123;&#125;&#125;class SadActor extends Actor&#123; public void act()&#123;&#125;&#125;class Stage&#123; private Actor actor = new Happyactor(); public void change()&#123;actor=new SadActor();&#125; public void performPlay()&#123;actor.act();&#125;&#125;public class Transmogrify&#123; public static void main(String[] args)&#123; Stage stage = new Stage(); stage.performPlay(); stage.change(); stage.performPlay(); &#125;&#125; 上述代码用到了状态模式，可以在运行时将引用与不同的对象重新绑定在一起，然后产生不同的行为。 一条通用的准则就是：“用继承表达行为之间的差异，用字段表达状态之间的差异”。 8.5.1 纯继承与扩展在通常情况下，我们需要重新查明对象的确切类型，以便能够访问该类型所扩充的方法。 8.5.2 向下转型与运行时类型识别Java语言中，所有转型都会得到检查。Java会在运行期间对类型进行检查，这种行为称作“运行时类型识别”(RTTI) 例：1234567891011121314151617181920212223class Useful&#123; public void f()&#123;&#125; public void g()&#123;&#125;&#125;class MoreUserful extends Useful&#123; public void f()&#123;&#125; public void g()&#123;&#125; public void u()&#123;&#125;&#125;public class RTTI &#123; public static void main(String[] args)&#123; Useful[] x = &#123; new Useful(), new MoreUserful() &#125;; x[0].f(); x[1].g(); ((MoreUserful)x[1]).u(); //((MoreUserful)x[0]).u(); //错误，转型失败 &#125;&#125; 如果想要访问MoreUseful对象的扩展接口，就可以尝试向下转型。如果所转的类型是正确的类型，那么转型成功；否则就会返回一个ClassCastException的异常。 RTTI的内容不仅仅包括转型处理。例如它还提供一种方法，使你可以在试图向下转型之前，查看你要处理的类型。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（七） 复用类]]></title>
    <url>%2F2017%2F10%2F09%2FThinkingInJava7%2F</url>
    <content type="text"><![CDATA[有两种方法可以复用现有类，第一种，只需在新的类中产生现有类的对象，称为组合；第二种，按照现有类的类型来创建新类，称为继承。 7.2 继承语法即使一个程序中含有多个类，也只有命令行所调用的那个类的main()方法会被调用。即使一个类只具有包访问权限，其public main()仍然是可以访问的 为了继承，一般的规则是把所有的数据成员都指定为private，将所有方法都指定为public（稍后将会学到，protected成员也可以借助导出类来访问）。 7.2.1 初始化基类当创建了一个导出类的对象时，该对象包含了一个基类的子对象 Java会自动在导出类的构造器中插入对基类构造器的调用，可以显示地调用基类构造器，但是调用基类构造器必须是你在导出类构造器中要做的第一件事。 7.3 代理什么叫代理？代理是组合和继承之间的中庸之道，将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该成员对象的所有方法（就像继承）。 7.4 结合使用组合和继承7.4.1 确保正确清理如果想要某个类去清理一些东西，就必须得显式地编写一个特殊方法来做这件事，必须将这一清理动作置于fially子句之中，以预防异常的出现。 许多情况下，清理并不是问题，交给垃圾回收器就好了。但有时有些资源必须亲自去清理，如果必须这样，最好是编写自己的清理方法，但不要使用finalize()。执行清理的顺序：首先，执行类的所有特定的清理动作，其顺序同生成顺序相反（通常这就要求基类元素仍旧存货）；然后，调用基类的清理方法。 7.4.2 名称屏蔽如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（这一点和C++不同）。 Java SE5新增了@Override注解，虽然不是关键字，但是可以把它当做是关键字来使用。如果想要覆写一个方法，添加@Override注解，可以防止在不想重载时而意外地进行了重载，这种情况下会有错误信息。 7.5 在组合与继承之间选择组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地做。 组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情况(has-a关系)。在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某个特殊需要而将其特殊化(is-a关系)。 一个最清晰的判断方法就是问一问自己是否需要从新类向基类进行向上转型。一般优先考虑组合，只在确实必要时才使用继承。 7.6 protected关键字Protected域对子类是可见的 7.7 向上转型向上转型总是很安全的。 7.8 final关键字7.8.1 final数据使用场景：（1）一个永远不改变的编译时常量；（2）一个在运行时被初始化的值，而你不希望它被改变。 一个既是static又是final的域只占据一段不能改变的存储空间。 对于基本类型，final使数值恒定不变；而对于对象引用，final使引用恒定不变，一旦引用被初始化指向一个对象，就无法再把它指向另一个对象。对象自身却是可以被修改的，这一限制也适用于数组，因为它也是引用。 根据惯例，一个既是static又是final的域（即编译器常量）将用大写表示，并使用下划线来分割各个单词。 “空白final”是指被声明为final但是又没有给定初值的域，可以在每个构造器中用表达式来对final进行赋值，这样就提供了灵活性。 当基本类型被指明为final的时候出现的结果：你可以读参数，但却不能改变参数。 7.8.2 final方法使用final方法的原因：（1） 把方法锁定，以防任何继承类修改它的含义（2） 过去建议使用final方法的第二个原因就是效率 只有想要明确禁止覆盖时，才将方法设置为final。 类中所有的private方法都隐式地指定为是final的。如果某个方法是private的，它就不是基类的接口的一部分。如果这个时候以相同的名称生成一个public、protected或者是包访问权限的方法的话，此时你并没有覆盖该方法，仅是生成了一个新方法。 7.8.3 final类final类没有子类，final类中的域可以不为final，final类中的方法必须为final。 final类不能被继承。不论类是否为final的，相同的规则都适用于定义为final的域。然而，final类中所有方法都隐式指定为final的，因为无法覆盖它们。 7.9 初始化及类的加载“类的代码在初次使用的时候才加载。”这通常是指加载发生于创建类的第一个对象的时候，但是当访问static域或者static方法的时候，也会发生加载。当然，定义为static的东西只会被初始化一次。 加载及初始化顺序： 加载类的基类，如果基类还有基类，则继续加载，如此类推。其它任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。 根基类中的static初始化(static域和static块初始化)，然后下个导出类，以此类推。 根基类初始化：非static显示初始化，调用构造器。 导出类初始化，流程与基类类似。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（六） 访问控制权限]]></title>
    <url>%2F2017%2F10%2F09%2FThinkingInJava6%2F</url>
    <content type="text"><![CDATA[重构就是重写代码 访问权限控制的等级，从最大权限到最小权限依次是：public、protected、包访问权限（没有关键词）和private。 6.1 包：库单元包内包含有一组类，它们在单一的名字空间下被组织在了一起。 一个Java源代码文件（.java文件）通常称为编译单元。每个编译单元只能有一个public类，否则编译器就不会接受，而且该类的名字必须和文件的名称相同。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的。 Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，使用Java的jar文档生成器）的.class文件。Java解释器负责这些文件的查找、装载和解释。 CLASSPATH：对于.class文件，需要写出.class文件存放路径，.jar则需要写清楚.jar文件的名称。例如：CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar CLASSPATH中包含一个或者多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称并且将每一个句点转换成反斜杠，以便从CLASSPATH根中产生一个路径名称。 如果两个含有相同名称的类库都以“*”的形式同时导入，则需要在创建类的时候写明全称：1234import net.mindview.simple.*;import java.util.*;java.util.Vector v = new java.util.Vector(); 用import改变行为：c中有条件编译，java中没有相同功能，可以通过导入不同版本的包，来实现相同功能。调试功能就是这么实现的。 包必须放置在CLASSPATH中设置的目录之中，否则会由于找不到包而出错。 6.2 Java访问权限修饰词 修饰词 本类 同一个包的类 继承类 其他类 Private yes no no no 无（默认） yes yes no no protected yes yes yes no public yes yes yes yes 6.3 接口和实现为了清楚起见，可能会采用一种将public成员置于开头，后头跟着protected、包访问权限和private成员的创建类的形式，这样便于阅读。 6.4 类的访问权限 每个编译单元（文件）都只能有一个public类。 public类的名称必须完全与含有该编译单元的文件名相匹配，包括大小写。 虽然不是很常用，但编译单元内完全不带public类也是可能的。在这种情况下可以对文件随意命名，但是这会带来阅读和维护的混乱。 类的访问权限有两种：包访问权限和public(内部类可以是protected和private)。如果不希望其它任何人对该类拥有访问权限，可以把所有构造器都指定为private，从而阻止任何人创建该类对象，但是有一个例外，就是你在该类的static成员内部可以创建(单例模式就用到了这一点)。 单例设计模式代码：1234567class Soup &#123; private Soup()&#123;&#125; private static Soup ps1 = new Soup(); public static Soup access()&#123; return ps1; &#125;&#125; 如果不具有package声明，都被视作该目录下默认包的一部分。然而，如果该类的某个static成员是public的话，则客户端程序员仍旧可以调用该static成员，尽管他们不能生成该类的对象。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（五） 初始化与清理]]></title>
    <url>%2F2017%2F10%2F06%2FThinkingInJava5%2F</url>
    <content type="text"><![CDATA[5.1 用构造器确保初始化默认构造器（无参构造器）：不接受任何参数的构造器。 Ex2创建一个类,它包含一个在定义时就被初始化了的String域,以及另一个通过构造器初始化的String域。这两种方式有何差异？123456789101112131415161718public class E02_StringInitialization &#123; String s1 = "Initialized at definition"; String s2; public E02_StringInitialization(String s2i) &#123; s2 = s2i; &#125; public static void main(String args[]) &#123; E02_StringInitialization si = new E02_StringInitialization( "Initialized at construction"); System.out.println("si.s1 = " + si.s1); System.out.println("si.s2 = " + si.s2); &#125;&#125; /* Output:si.s1 = Initialized at definitionsi.s2 = Initialized at construction*///: 不同：s1的域在构造器初始化之前就已经被初始化了，s2的域这时候也被初始化为null，只不过在构造器中又被初始化了一次，即初始化2次。而且通过构造器初始化这种方式更加灵活。 5.2 方法重载区分重载的几个方法： 参数列表不同 参数顺序不同（不建议） 返回值不同（行不通） 5.3 默认构造器如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器。 例如：12345678910class Bird&#123; Bird(int i)&#123;&#125; Bird(double)&#123;&#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Bird b = new Bird(); //会报错，因为已经提供了构造器，所以编译器就不会帮你自动创建默认构造器。 &#125;&#125; 5.4 this关键字编译器会暗自把“所操作对象的引用”作为第一个参数传递给方法。this关键词只能在方法内部使用，表示对“调用方法的那个对象”的引用。this的用法和其他对象引用并无不同。 • 如果在方法内部调用同一类的另一个方法，不必使用this，直接调用即可。当方法需要返回当前对象的引用时才需要明确使用this，如需要返回当前对象时。• 如果要将当前对象传递给外部的方法，this关键词就很有用。• 可能为一个类写了多个构造器，想在一个构造其中调用另一个构造器，以避免重复代码。this关键字可以做到这一点。 尽管可以用this调用一个构造器，但不能调用两个。此外，必须将构造器置于最起始处，否则编译器会报错。 除了构造器外，编译器禁止在其他任何地方调用构造器。 static方法是属于类的，所以里面不能用this关键字。static方法的内部不能使用非静态方法，反过来倒是可以的。 5.5 清理：终结处理和垃圾回收1. 对象可能不被垃圾回收2. 垃圾回收并不等于“析构”3. 垃圾回收只与内存有关系 finalize() Java中finalize()的作用一主要是清理那些对象(并非使用new，比如调用了native方法)获得了一块“特殊”的内存区域。Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象(并非使用new)获得了一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块“特殊”内存区域，为了应对这种情况，java允许在类中定义一个名为finalize()的方法。它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()的方法。并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用finalize()，就能在垃圾回收时刻做一些重要的清理工作。注意这里的finalize()并不是C++里的析构.在C++中，对象一定会被销毁，而在Java里的对象却并非总是被垃圾回收。 垃圾回收只与内存有关。也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说(尤其是finalize()方法)，它们也必须同内存及其回收有关。 在C++中，所有对象都会被销毁，或者说，应该被销毁。但是在Java中，无论是“垃圾回收”还是“终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。 finalize()有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象终结条件的验证。 例如：123456789101112131415161718192021222324class Book&#123; boolean checkedOut = false; Book(boolean checkedOut)&#123; this.checkedOut = checkedOut; &#125; void checkIn() &#123; checkedOut = false; &#125; protected void finalize()&#123; if(checkedOut)&#123; System.out.println("Error : checked out"); &#125; &#125;&#125;public class TerminationCondition&#123; public static void main(String[] args)&#123; Book novel = new Book(true); novel.checkIn(); new Book(true); System.gc(); // 用于强制进行终结动作 &#125;&#125; 这个例子的终结条件是：所有的Book对象在被当做垃圾回收前都应该被签入（check in）。但在main()方法中，由于程序员的失误，有一本书没有被签入。要是没有finalize()来验证终结条件，就很难发现这个缺陷。 5.5.4 垃圾回收器如何工作垃圾回收器如何工作:举一个生活中的例子。你在一个屋子里生活一段时间之后会产生很多垃圾，使你必须清理。清理包括扔掉生活垃圾和自己几乎用不着的东西。 垃圾回收器最简单的方法就是引用计数：当有引用连接至对象的时候，引用计数加一。垃圾回收器遍历全部的对象。当发现有计数为0的对象时就释放。但是每当对象循环调用时会出现应该被回收，但是计数不为0的现象。这就像你收拾屋子时总觉得这个东西还有用其实它对于你没有什么用那样。显然这种方式是不可用的。实际上虚拟机采用的回收思想是;每一个活的对象都可以追溯到它存活的堆栈或者静态存储区的引用。因此从堆栈或者静态存储区开始遍历就可以找到所有活着的对象。在这种方式下采用了自适应的垃圾回收机制：1.停止–复制机制：先暂停程序的运行然后将活的对象从一个堆栈复制到另一个堆栈中，没有复制的都是垃圾将被回收。显然这种方式的缺点还是比较明显的，首先要暂停程序，另外在程序稳定之后几乎不产生垃圾的情况下仍旧会进行大量的复制。这是一种没有必要的浪费。2.标记–清扫：标记每一个活着的对象，在清理时不清理他们。但是这样做的缺点是存储空间不是相连成块的。虚拟机通常都把这两种方式结合来用，在没有新的垃圾产生的时候就从停止–复制模式切换到标记–清扫模式。这样避免了二者的缺点。在虚拟机中内存都以块的形式分配，在垃圾回收时停止–复制机制向已经废弃的块中拷贝新的对象，由于程序的进行，会出现更替，所以每个块都有自己的代数来记录它是否存活。每次回收之后都进行整理，这样垃圾回收就会对大量的短命的临时对象进行回收。因此现行的垃圾回收应该被称呼为“自适应的，分代的，停止–复制，标记–清扫”式垃圾回收器。有些时候我们可能会使用非new形成的内存，这时java中有一个方法为finalize()，每当垃圾回收器启动的时候，会首先调用这个方法，并且在下一次垃圾回收发生的时候才会真正回收对象。这个时候我们需要finalize()来验证终结条件并且调用system.gc()这个方法来进行终结动作。 5.6 成员初始化Java尽力保证：所有变量在使用前都能得到适当的初始化。对于方法的局部变量，如果没有被初始化，就会以异常的方式来提醒。 类的数据成员是基本类型时，就会有默认的初始值。 在类里定义一个对象引用时，如果没有对它进行初始化，此引用就会得到一个特殊值null。 5.7 构造器初始化 5.8 数组初始化int[] a1;这只是一个数组引用。 第一种初始化方法代码： 123Integer[] a = new Integer[2];//对于非基本类型，此时只是创建了一个引用数组，必须对数组中的每个元素创建对象a[0] = new Integer(1);a[1] = new Integer(2); 第二种初始化方法代码： 1Integer[] a = &#123;1,2,&#125;; 第三种初始化方法代码：1Integer[] a = new Integer[]&#123;1,2,&#125;; 第二、三种方法中最后一个逗号是可选的。在方法调用的内部都可以使用第三种方式： 1Other.main(new String[]&#123;"abc","efg"&#125;); 5.8.1 可变参数列表Java SE5中开始提供可变参数列表。代码如下：public void name(Object...args); 可变参数：1. 参数个数或者类型未知2. 必须位于参数列表末尾 当指定参数时，编译器实际上会为你去填充数组。可以直接将数组传递给可变参数列表。0个参数的可变参数列表也是可以的。 当方法重载时，如：12public void name(Integer... args)&#123;&#125;public void name(Long... args)&#123;&#125; 上述代码重载了name方法，当使用name()编译器无法知道调用哪个方法，无法编译。你应该总是只在重载方法的一个版本上使用可变参数列表，或者根本不使用 5.9 枚举类型Java SE5中添加了enum关键字，详细的enum用法在19章将会提到。 • toString()：获得某个enum实例的名字• ordinal()：获得某个enum实例的声明顺序• 静态方法values()：用来按照enum常量的声明顺序，产生由这些常量值构成的数组。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（四） 控制执行流程]]></title>
    <url>%2F2017%2F10%2F02%2FThinkingInJava4%2F</url>
    <content type="text"><![CDATA[4.3 迭代4.3.3 逗号操作符Java里唯一用到逗号操作符的地方就是for循环的控制表达式。 4.4 Foreach语法Java SE5引入了一种新的更加简洁的for语法用于数组和容器，就是foreach语法。如： for(float x : f){…}; Foreach还可以用到任何Iterable对象上。 4.6 break和continue在java中，标签起作用的唯一的地方刚好是在迭代语句之前。“刚好之前”的意思表明，在标签和迭代之间置入任何语句都不好。在迭代之前设置标签的唯一理由：我们希望在其中嵌套另一个迭代或者一个开关。这是由于break和continue关键词通常只中断当前循环（最内层的循环），但若随同标签一起使用，它们就会中断循环，直到标签所在的地方。 一般的continue会退回最内层循环的开头（顶部），继续执行。 带标签的continue会到达标签的位置，重新进入紧接在那个标签后面的循环。 一般的break会中断并跳出当前循环。 带标签的break会中断并跳出标签所指的循环。 4.8 switchswitch现在支持整数(int、short、byte)、char、字符串、枚举类型。 Ex10 吸血鬼问题首先解释一下吸血鬼数字：吸血鬼数字是指位数为偶数的数字，可由一对数字相乘而得到，这对数字各包含乘积的一半位数的数字，以两个0结尾的数字是不允许的。 四位数吸血鬼数字示例：1260=21&#42;60，1827=21&#42;87，2187=27&#42;81…… 先列出结果：一共7个：1260=21&#42;60，1395=15&#42;93，1435=41&#42;35，1530=51&#42;30，1827=87&#42;21，2187=27&#42;81，6880=86&#42;80 方法一：本方法是顺向思维，即先有四位数，再拆分，四个数字组合相乘，若乘积与原数相等，则输出，并计算为一个吸血鬼数字。算法效率较低，共比较107976次 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142/*解法1*/public class E10_Vampire_0 &#123; /*本方法是顺向思维，即先有四位数，再拆分，四个数字组合相乘，若乘积与原数相等，则输出，并计算为一个吸血鬼数字。 其实sum的结果为107976次，非常大，算法效率很低，并且出现了重复（6880 = 86 * 80，6880 = 80 * 86）。*/ static int sum=0;//记录调用判断的次数,TMJG添加此行并注释 static int a(int i) &#123; return i/1000; //求千位数字 &#125; static int b(int i) &#123; return (i%1000)/100; //求千位数字 &#125; static int c(int i) &#123; return ((i%1000)%100)/10; //求十位数字 &#125; static int d(int i) &#123; return ((i%1000)%100)%10; //求个位数字 &#125; static int com(int i, int j) &#123; //形成10~99的两位数 return (i * 10) + j; &#125; static void productTest (int i, int m, int n) &#123; sum++; if(m * n == i) System.out.println(i + " = " + m + " * " + n); &#125; public static void main(String[] args) &#123; for(int i = 1001; i &lt; 9999; i++) &#123; productTest(i, com(a(i), b(i)), com(c(i), d(i))); productTest(i, com(a(i), b(i)), com(d(i), c(i))); productTest(i, com(a(i), c(i)), com(b(i), d(i))); productTest(i, com(a(i), c(i)), com(d(i), b(i))); productTest(i, com(a(i), d(i)), com(b(i), c(i))); productTest(i, com(a(i), d(i)), com(c(i), b(i))); productTest(i, com(b(i), a(i)), com(c(i), d(i))); productTest(i, com(b(i), a(i)), com(d(i), c(i))); productTest(i, com(b(i), c(i)), com(d(i), a(i))); productTest(i, com(b(i), d(i)), com(c(i), a(i))); productTest(i, com(c(i), a(i)), com(d(i), b(i))); productTest(i, com(c(i), b(i)), com(d(i), a(i))); &#125; System.out.println("总共调用判断的次数为："+sum);//TMJG添加此行并注释 &#125;&#125; 方法二：本方法是对方法一的改进，跳过了一些数字（如1100这样末尾两个0的，如1010、1001这样明显不可能是吸血鬼数字的数字），并且避免了出现重复的可能性，但是效率仍然很低，需要判断104942次。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*解法2*/public class E10_Vampire_1 &#123; public static int count = 0;// 记录一共有多少个吸血鬼数字 public static int k = 0;//记录调用判断多少次 public static void main(String[] args) &#123; for (int i = 1001; i &lt; 10000; i++) &#123; // 如果数字是像1100这种末尾至少有2个0的，则跳过 if (i % 100 == 0) &#123; continue; &#125; // 获得数字四个数值位上的数字,这里我们假定四位数表示为abcd int a = i / 1000; int b = (i - a * 1000) / 100; int c = (i - a * 1000 - b * 100) / 10; int d = i - a * 1000 - b * 100 - c * 10; // 判断四个位置上是否有两个0存在的情况，如1010，并跳过这些数，由于千位不可能为0，因此只需要判断另外三位是否有2个0的情况 // 当3个数中有2个0时，必然存在“3个数之和等于其中某一个数”，以此作为判断依据，而后两位为0的也已经排除，其实只需要判断如1001，和1010这种情况即可 if (b + c + d == c || b + c + d == d) &#123; continue; &#125; // 排除掉各种情况后，可以开始真正的吸血鬼数字筛选了 // 那么一共有12种情况：abcd,abdc,acbd,acdb,adbc,adcb,bacd,badc,bcda,bdca,cadb,cbda if (search(i, a, b, c, d)) &#123; &#125; else if (search(i, a, b, d, c)) &#123; &#125; else if (search(i, a, c, b, d)) &#123; &#125; else if (search(i, a, c, d, b)) &#123; &#125; else if (search(i, a, d, b, c)) &#123; &#125; else if (search(i, a, d, c, b)) &#123; &#125; else if (search(i, b, a, c, d)) &#123; &#125; else if (search(i, b, a, d, c)) &#123; &#125; else if (search(i, b, c, d, a)) &#123; &#125; else if (search(i, b, d, c, a)) &#123; &#125; else if (search(i, c, a, d, b)) &#123; &#125; else if (search(i, c, b, d, a)) &#123; &#125; &#125; System.out.println("四位数的吸血鬼数字一共有" + count + "个。"); System.out.println("一共调用判断次数为" + k); &#125; //判断是否满足条件 static boolean search(int i, int a, int b, int c, int d) &#123; k++; if ((a * 10 + b) * (c * 10 + d) == i) &#123; searchfor(i,a,b,c,d);//如果满足条件，则打印结果 return true; &#125;else&#123; return false; &#125; &#125; //满足条件即打印，并且统计个数 static void searchfor(int i, int a, int b, int c, int d) &#123; count++; System.out.println(i + "=" + (a * 10 + b) + "*" + (c * 10 + d)); &#125;&#125; 方法三：该算法采用逆向思维，4位数字的吸血鬼数字只能拆分成两个2位数，因此遍历所有两个两位数相乘的情况，除去不符合的情况不用判断，其他挨个判断即可。该方法只需判断3721次。 代码如下： 12345678910111213141516171819202122232425262728293031/*解法三*/public class E10_Vampire &#123; /** * 代码来自网络，略作修改并添加了注释 * 该算法只需要执行3721次 */ public static void main(String[] args) &#123; String[] targetNum = null; String[] gunNum = null; //目标数字和枪数字（即对比数字） int sum = 0; //吸血鬼数字的总个数 int count = 0; //有效判断次数，那些乘积不是4位数的就排除了 for (int i = 10; i &lt; 100; i++) &#123; for (int j = i + 1; j &lt; 100; j++) &#123; //没有哪个两位数满足ab*ab=abab（不信可以编程验证），所以这里j从i+1开始就可以了 int i_target = i * j; if (i_target &lt; 1000 || i_target &gt; 9999) continue; // 积不是4位数则跳过 count++; targetNum = String.valueOf(i_target).split(""); //将其转换为一个字符串数组 gunNum = (String.valueOf(i) + String.valueOf(j)).split(""); java.util.Arrays.sort(targetNum); //升序排列，因为只有排列了再比较才能保证不遗漏abcd=ba*dc这样的情况 java.util.Arrays.sort(gunNum); if (java.util.Arrays.equals(targetNum, gunNum)) &#123; // 排序后比较,为真则找到一组 sum++; System.out.println("第" + sum + "个: " + i_target + "=" + i + "*" + j); &#125; &#125; &#125; System.out.println("共进行了" + count + "次判断，找到" + sum + "个吸血鬼数字。"); &#125;&#125;]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（三） 操作符]]></title>
    <url>%2F2017%2F10%2F02%2FThinkingInJava3%2F</url>
    <content type="text"><![CDATA[在最底层，Java是通过操作符来对数据进行操作的。 3.1 更简单的打印语句123456789101112131415161718//: operators/E01_PrintStatements.java/****************** Exercise 1 ****************** Write a program that uses the "short" and* normal form of print statement.***********************************************/package operators;import java.util.Date;import static net.mindview.util.Print.*;public class E01_PrintStatements &#123;public static void main(String[] args) &#123;Date currDate = new Date();System.out.println("Hello, it's: " + currDate);print("Hello, it's: " + currDate);&#125;&#125; /* Output: (Sample)Hello, it's: Wed Mar 30 17:39:26 CEST 2005Hello, it's: Wed Mar 30 17:39:26 CEST 2005*///:~ 上面的import static net.mindview.util.Print.*;简化了打印操作。 3.2 使用Java操作符几乎所有的操作符都只能操作基本类型。例外的操作符是“=”，“==”，“!=”。另外String支持“+”和“+=” 3.3 优先级先乘除后加减 3.4 赋值基本类型赋值是直接将一个地方的内容复制到另一个地方。而“将一个对象赋值给另一个对象”实际是将“引用”从一个地方复制到另一个地方。 3.5 算数操作符通过Random类的对象，程序可以生成许多不同类型的随机数字。只需要调用方法nextInt()和nextFloat()就可以了（或者nextLong()或nextDouble()）。 一元减号是用于转变数据的符号，一元加号只是为了与一元减号相对应，唯一的作用仅仅是将较小类型的操作符提升为int。 3.7 关系操作符对于对象==，!=比较的是引用。要比较对象的实际内容，应该使用equals()方法。默认equals()方法是比较引用（Object类中就是返回this==obj），所以要想实现自己想要的功能应该在自己的类中覆盖此方法。Java不允许普通数字作为布尔值使用。 基本类型直接使用==，!=比较内容即可。 3.8 逻辑操作符逻辑操作符“与”（&amp;&amp;）、“或”（||）、“非”（！ ）能根据参数的逻辑关系，生成一个boolean值。短路现象：一旦能明确无误地确定整个表达式的值，就不再计算表达式余下的值了。 直接常量后面的后缀字符标志了它的类型。&nbsp;&nbsp;&nbsp;&nbsp;• 若为大写（或小写）的L，代表long。&nbsp;&nbsp;&nbsp;&nbsp;• 若为大写（或小写）的F，代表float。&nbsp;&nbsp;&nbsp;&nbsp;• 若为大写（或小写）的D，代表double。对于long和float必须写出后缀字符。默认整型和浮点型是int和double。Integer和Long类的静态方法toBinaryString()可以得到二进制字符串。 3.9 指数计数法1.39e-43f代表1.39乘上10的-43次幂。 3.10 按位操作符我们将布尔类型作为一种单比特值对待。可以进行按位与(&amp;)、或(|)、异或(^)操作，但是不能进行按位非(~)操作。对于布尔值，按位操作符与逻辑操作符有相同的效果，只是不能中途“短路”。 3.11 移位操作符&nbsp;&nbsp;&nbsp;&nbsp;• &nbsp;&nbsp;左移位操作符（&lt;&lt;）：按操作符右边指定数值移位后，低位补0 。&nbsp;&nbsp;&nbsp;&nbsp;• “有符号”右移位操作符（&gt;&gt;）：按操作符右边指定数值移位后，使用符号扩展，补齐高位，若符号为正，则在高位插入0，若符号为负，则插入1 。&nbsp;&nbsp;&nbsp;&nbsp;• “无符号”右移位操作符（&gt;&gt;&gt;）：按操作符右边指定数值移位后，无论正负都在高位补0 。 char、byte、short类型的数值进行移位时，移位进行之前会先转为int，最后结果也是int型。只有右操作数的低5位才是有用的。这样可以防止我们移位超过int型值所具有的位数。 若对一个long类型的数值进行处理，最后结果也是long。此时只会用到数值右端的低6位，以防止移位超过long类型数值所具有的位数。 int是32位，所以50&lt;&lt;33相当于50&lt;&lt;(33%32)。 Java数字的二进制表示形式称为有符号的二进制补码 3.15 类型转换操作符窄化转换：将容纳更多信息的数据类型转换成无法容纳那么多信息的数据类型，可能面临信息丢失的危险。需要进行显式转换。扩展转换：不需要进行显式转换，因为新类型肯定会容纳原来类型的信息，不会造成任何信息的丢失。 3.15.1 截尾和舍去将float和double转型为整型值时，总是对该数值执行截尾。如果想要得到舍入结果，就需要使用java.lang.Math中的round()方法。 3.15.2 提升对于基本类型执行算术运算或位运算，只要类型比int小（char、byte、short），在运算之前会自动转成int，最终结果也是int。复合赋值（+=、-=等）并不需要类型转换，尽管它们执行类型提升，但也会获得与直接算术运算相同的结果。表达式中出现的最大的类型决定了表达式最终结果的数据类型。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（二） 一切都是对象]]></title>
    <url>%2F2017%2F09%2F30%2FThinkingInJava2%2F</url>
    <content type="text"><![CDATA[2.1 用引用操作对象尽管一切都看做对象，但是操纵的标识符实际上是对象的一个“引用”(reference)。可以将这个情形看做是遥控器（引用）来操纵电视机（对象）一种安全的做法是，创建一个引用的同时就对其进行初始化。String s = “hello”; 2.2 必须由你创建所有对象String s = new String(“hello”);一旦创建了一个引用，就能与一个对象相关联。 2.2.1 存储到什么地方程序运行时候有五个地方可以存储数据： 寄存器：处理器内部，最快的存储区，数量极其有限 堆栈：位于通用RAM，通过堆栈指针来分配和释放内存，速度仅次于寄存器。灵活性受限（必须知道存储其中的对象的确切生命周期）。对象引用存于此处。 堆：一种通用内存池，也位于RAM。灵活性大，分配与清理耗时，所有的Java对象存储于此。 常量存储：存放在程序内部，在嵌入式系统中，可以选择将其存放于ROM中。 非RAM存储：数据在程序没有运行时也可以存在，两个典型的例子就是流对象和持久化对象 2.2.2 特例：基本类型基本类型不需要new来创建对象，而是创建一个并非是引用的“自动”变量。这个变量直接存储值，并置于堆栈中。 Java中，没有无符号数，基本类型占用空间的大小也不会像其它语言随机器硬件架构变化。&rarr;（更具有可移植性） Java 每种基本类型都提供了包装器类型。同时提供了两个用于高精度计算的类：BigInteger（任意精度的整数）和BigDecimal（任意精度的定点数）。 2.2.3 Java中的数组C和C++的数组就是内存块，访问很危险Java则会确保数组会被初始化，而且不能再范围外访问。但是增加了检查开销。 Java中创建数组对象时，实际上就是创建引用数组（数组对象是由java虚拟机创建的），且每个引用都会自动被初始化为一个特定值（null）。编译器会把基本类型数组的内存全部置零。 2.3 永远不需要销毁对象2.3.1 作用域以花括号为例，说明与C、C++的作用域区别：123456&#123; int x = 12; &#123; int x = 96; //不合法，而在C、C++中外面花括号中的变量会被隐藏 &#125;&#125; 2.3.2 对象的作用域Java使用new创建的对象可以存活于作用域之外123&#123; String s = new String("a string");&#125; 上面例子中，引用s在作用域终点就消失了，s指向的String对象仍继续占用内存空间。 Java有一个垃圾回收器，用于监视new创建的所有对象，并辨别不再被引用的对象。 2.4 创建新的数据类型：类在Java中，所做的全部工作就是：定义类、产生类对象、发送消息给类对象。类中有两种类型的元素：字段（或数据成员）和方法（或成员函数）。 当变量成为类的字段使用时，Java确保给定其默认值（内存中填0），以确保其得到初始化（C++无此功能），对于局部变量，不做初始化，可能是任意值。 2.5 方法、参数和返回值方法：做某些事情的方式。基本组成包括：名称、参数、返回值和方法体。其中方法名和参数列表（参数类型及参数顺序），合起来称为“方法签名”，唯一标识出某个方法。 Java中的方法只能作为类的一部分来进行创建。方法只能通过对象才能被调用。 Java在参数列表中必须指定每个所传递对象的类型和名字。 关于方法的参数传递，这是一个被争议的话题。 • 先说说参数传递的几个术语：&nbsp;&nbsp;&nbsp;&nbsp;值调用(call by vale):表示方法接收的是调用者传递的值。&nbsp;&nbsp;&nbsp;&nbsp;引用调用(call by reference):表示方法接收的是调用者传递的变量地址。&nbsp;&nbsp;&nbsp;&nbsp;一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值； JAVA语言总是采用值调用，也就是说，JAVA方法得到的是所有参数值的一个拷贝，方法不能修改传递给他的任何参数变量的内容。例如：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package ch2;/*JAVA方法得到的是所有参数值的一个拷贝，方法不能修改传递给他的任何参数变量的内容。*/public class Parameter &#123; public static void swap(int a, int b)&#123; int tmp = a; a = b; b = tmp; System.out.println("a: "+a+" b: "+b); &#125; public static void swap(StringAddress a, StringAddress b)&#123; StringAddress tmp = a; a = b; b = tmp; System.out.println("a: "+a+" b: "+b); &#125; public static void change(StringAddress a)&#123; a.setS("hi"); System.out.println("a: "+a); &#125; public static void main(String[] args) &#123; int x = 1,y=20; StringAddress sax = new StringAddress("hello"),say = new StringAddress("world"); swap(x,y); System.out.println("x: "+x+" y: "+y); swap(sax,say); System.out.println("sax: "+sax+" say: "+say); change(sax); System.out.println("sax: "+sax); &#125;&#125;class StringAddress&#123; private String s; public StringAddress(String s)&#123; this.s = s; &#125; public String toString()&#123; return super.toString() + " " + s; &#125; public void setS(String s)&#123; this.s = s; &#125;&#125;/*a: 20 b: 1x: 1 y: 20a: ch2.StringAddress@1540e19d world b: ch2.StringAddress@677327b6 hellosax: ch2.StringAddress@677327b6 hello say: ch2.StringAddress@1540e19d worlda: ch2.StringAddress@677327b6 hisax: ch2.StringAddress@677327b6 hi*/ 通过以上实例,可以看出基本类型参数传递的是变量值的拷贝，对象参数传递的是对象引用的拷贝,对象引用及其他的拷贝同时引用同一个对象。 很多程序语言提供两种传递方式:值传递和引用传递(C++和Pascal)。有些程序员认为java语言对对象参数传递也是用的引用调用。实际上是理解错误，这种错误具有一定的普遍性。 上例中swap方法并没有改变存储在变量sax和say中的对象引用。swap方法的参数a和b被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。在方法结束时，参数变量a和b被丢弃了。原来的变量sax和say仍然引用这个方法调用之前所引用的对象。这个过程说明：java语言对对象采用的不是引用调用，实际上对象引用进行的是值传递。最后总结一下在JAVA中，方法参数的使用情况： &nbsp;&nbsp;•一个方法不能修改一个基本数据类型的参数；&nbsp;&nbsp;•一个方法可以改变一个对象参数的状态（属性）；&nbsp;&nbsp;•一个方法不能实现让对象参数引用一个新对象； C++有值调用和引用调用。引用参数标有&amp;符号。例如，void swap(int&amp; a,int&amp; b)。引用即可以当做变量的一个别名，仅此而已。而Java的引用，如果理解为像指针一样存的是对象地址，传递时都会把它拷贝一份，这样可能会好理解些。 2.6 构建一个Java程序2.6.1名字可见性为了解决命名冲突，Java程序员使用反写Internet域名来确保名字的独一无二。如：net.mindview.utility.foibles 2.6.2 运用其他构件想使用其他文件定义好的类，可以使用import。 2.6.3 static关键字static解决的两个需求：（1） 只想为某特定域分配单一的存储空间，而不去考虑究竟要创建多少对象。（2） 即使没有创建对象，也能调用这个方法 即使从未创建某个类的任何对象，也可以调用其static方法或访问static域。 对于static方法，不能简单地通过调用其它非static域或方法而没有指定某个命名对象，来直接访问非static域或方法。普通方法可以直接使用static域或方法。 使用类名是引用static变量的首选方法。语法形式为ClassName.method(); 2.7 Java的第一个程序一个独立运行的程序，文件中必须存在某个类与该文件同名，并且那个类必须包含一个名为main()的方法（事实上Java允许文件名和文件中的类不同命，但是类不能是public的）。 public static void main(String[] args){…}中args用来存储命令行参数。 2.8注释和嵌入式文档javadoc 只能为public和protected成员进行文档注释。 不要在嵌入式html中使用标题标签&lt;h1&gt;&lt;hr&gt;等。因为javadoc会插入这类标签，避免冲突。 一些标签示例• @see：引用其他类该标签允许用户引用其他类的文档 @see classname• {@link package.class#member label}该标签与@see相似，只是它用于行内• {@docRoot}该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接• {@inheritDoc}该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中• @version• @author• @since该标签允许你指定程序代码最早的使用版本• @param该标签用于方法文档中• @return• @throws• @deprecated该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要再使用这些旧特性，因为在不久的将来它们很可能会被删除2.9 编码风格驼峰风格：类名的首字母大写；如果类名由几个单词构成，那么把它们并在一起，其中每个内部单词的首字母都采用大写形式。如：AllTheColorsOfRainbow几乎其他所有内容－－方法、字段（成员变量）以及对象引用名称等，公认的风格与类的风格一样，只是标识符的第一个字母采用小写。如：allTheColorsOfRainbow]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程思想（一） 对象导论]]></title>
    <url>%2F2017%2F09%2F29%2FThinkinginJava1%2F</url>
    <content type="text"><![CDATA[1.1 抽象过程所有语言都提供抽象过程，汇编语言是对底层机器的轻微抽象，“命令式”语言（FORTRAN、BASIC、C等）是对汇编的抽象。 面向对象的五个基本特性：（1） 万物皆为对象（2） 程序是对象的集合，它们通过发送消息来告知彼此所要做的（3） 每个对象都有自己的由其他对象所构成的存储（4） 每个对象都有其类型（5） 某一特定类型的所有对象都可以接收同样的消息对象：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（它们给出了该对象的状态）和方法（它们产生行为），并且每一个对象都可以唯一地与其他对象区分开来。具体说来，就是每一个对象都在内存中有唯一的地址。 1.2 每一个对象都有一个接口类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。 必须有某种方式产生对对象的请求，使对象完成各种任务，如在屏幕上画图、打开开关等等。每个对象都只能满足某些请求，这些请求由对象的接口（interface）所定义，决定接口的便是类型。 1.3 每个对象都提供服务对象是服务提供者，这么看的好处是提高对象的内聚性。 人们在设计对象时面临的问题是，将过多的功能都塞到一个对象中。在良好的面向对象设计中，每个对象都可以很好地完成一件事，而不试图去做多个。 1.4被隐藏的具体实现程序开发人员分为类创建者和客户端程序员。类创建者只向客户端程序员暴露必要的部分。 访问控制的第一个存在原因就是让客户端程序员无法触及他们不应该触及的部分访问控制的第二个存在原因就是允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员 Java用三个关键字在类的内部设定边界：public，private，protected以及暗示性的friendly。若未明确指定其他关键字，则默认为后者。这些关键字的使用和含义都是相当直观的，它们决定了谁能使用后续的定义内容。 “public”（公共）意味着后续的定义任何人均可使用。而在另一方面。 “private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。private在您与客户程序员之间竖起了一堵墙。若有人试图访问私有成员，就会得到一个编译期错误。 “friendly”（友好的）涉及“包装”或“封装”（Package）的概念——即Java用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。 “protected”（受保护的）与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。继承的问题不久就要谈到。 1.5 复用的具体实现最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的对象放在一个新类中 组合：由任意数量、任意类型的其他对象以任意可以实现新的类中想要的功能的方式所组成。 如果组合是动态发生的，那么它通常称为“聚合”。 组合经常被视为”has-a”（拥有）关系，就像我们常说的”汽车拥有引擎”一样。在建立新类时，应该首先考虑组合，因为它更加简单灵活。 1.6 继承一个基类型包含其所有导出类型所共享的特性和行为。可以创建一个基类型来表示系统中某些对象的核心概念。 当继承一个现有类型的时候，也同时创建了新的类型。这个新的类型不光包括现有类型的所有成员（尽管private成员被隐藏起来，不可访问），而且更重要的是它复制了基类的接口。也就是说，所有可以发给基类的信息也可以发给导出类对象。 有两种方法可以使基类与导出类产生差异： 第一种方法非常直接：直接在导出类中添加新方法。应该仔细考虑是否存在基类也需要这些额外方法的可能性。 第二种也是更重要的一种使导出类和基类之间产生差异的方法是改变现有基类的方法的行为，这被称之为覆盖（overriding）那个方法。 如果继承只覆盖基类的方法（而并不添加在基类中没有的新方法），就意味着导出类和基类是完全相同的类型，因为它们具有完全相同的接口。结果可以用一个导出类对象来完全替代一个基类对象。这可以被视为纯粹替代，通常称之为替代原则。这种情况下的基类与导出类之间的关系称为is-a（是一个）关系，因为可以说”一个圆形就是一个几何形状”。判断是否继承，就是要确定是否可以用is-a来描述类之间的关系，并使之具有实际意义。有时必须在导出类型中添加新的接口元素，这样也就扩展了接口。这个新的类型仍然可以替代基类，但是这种替代并不完美，因为基类无法访问新添加的方法。这种情况可以描述为is-like-a（像是一个）关系。新类型具有旧类型的接口，但是它还包含其他方法，所以不能说它们完全相同。 1.7 伴随多态的可互换对象试图将导出类型的对象看做其泛化基类型的对象的时候（比如把自行车看做车），仍然存在问题：如果某个方法让泛化交通工具行驶，编译器编译的时候是不知道应该执行哪一段代码。 为了解决这个问题，面向对象程序直到运行时才能确定被调用的代码，这就是后期绑定。为了执行后期绑定，Java使用了一小段代码来替代绝对地址的调用。 在C++中，使用virtual关键字来实现后期绑定，因而不是动态的，而在Java中，默认就是动态绑定，因此也不需要添加额外的关键字来实现多态。 例如：12345void doSomething(Shape shape)&#123; shape.erase(); shape.draw();&#125; 这个方法才可以和任何Shape对话。如果其他程序也用到了dosomething()方法：1234Circle circle = new Circle();Line line = new Line();doSomething(circle);doSomething(line); 对doSomething的调用会自动地正确处理，而不管对象的确切类型。这种把导出类看成是基类的过程叫做向上转型（upcasting）。 1.8 单根继承结构除了C++以外的所有OOP语言都是单根继承。在Java中，终极基类就是Object。 1.9 容器容器：在任何需要的时候都可以扩充自己以容纳你置于其中的东西。因此不需要知道将来会把多少个对象置于容器中，只需要创建一个容器对象，然后让它去处理所有细节。 Java提供了List（用于存储序列），Map（也被称为关联数组，用来建立对象之间的关联），Set（每种对象类型只持有一个），以及诸如队列、树、堆栈等更多的构件。不同容器提供了不同类型的接口和外部行为；不同的容器对于某些操作具有不同的效率。例如ArrayList和LinkedList，选取元素时，LinkedList会比较低效，但是插入元素时，相对要高效。 在Java SE5出现之前，容器存储的对象都只具有Java中的通用类型：Object。所以由于容器只存储Object，所以当将对象引用置入容器时，它必须被向上转型为Object，当把它取回的时候，就获取了一个Object对象的引用，而不是对置入时那个对象的引用。 为了解决这个问题，可以采用向下转型的方法来解决。如果不是确切的知道对象的类型，向下转型是危险的。 Java SE5中加入了参数化类型，就是泛型。 1.10 对象的创建和生命期为了追求最大的执行效率，对象的存储空间和生命周期可以在编写程序的时候确定。这可以通过将对象置于堆栈（它们有时被称为自动变量或限域变量）或静态区域来实现。这种方式牺牲了灵活性，在编写程序的时候必须知道对象确切的数量、生命周期和类型。 第二种方式是在堆(heap)内存池中动态地创建对象。这种方式知道运行时才确切知道需要多少对象，生命周期如何，以及它们的具体类型是什么。 动态方式逻辑：对象趋于复杂，所以查找和释放存储空间的开销不会对对象的创建造成重大冲击。 Java完全采用了动态内存分配的方式，每当想创建一个新对象的时候，就直接new一个对象出来。 由于在堆上创建对象存活的时间，编译器一无所知，在C++中必须通过delete对象来销毁对象，这样很可能由于处理不当导致内存泄漏。而Java中提供了垃圾回收器机制，用来处理内存释放问题。 1.11 异常处理：处理错误异常是一种对象。异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。因为它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。这往往使得代码编写变得简单，因为不需要被迫定期检查错误。此外，被抛出的异常不像方法返回的错误值和方法设置的用来表示错误条件的标志位那样可以被忽略。异常不能被忽略，所以它保证一定会在某处得到处理。 1.12 并发编程隐患：共享资源。如果有多个并行任务都要访问同一项资源，那么就会出问题。对于共享资源，需要加锁。]]></content>
      <categories>
        <category>Java SE</category>
      </categories>
      <tags>
        <tag>Java SE</tag>
        <tag>Java编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向下一代光通信的VCSEL激光器仿真模型（数学建模）]]></title>
    <url>%2F2017%2F09%2F23%2Fgmcm%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;在2017年9月16日至20日参加“华为杯”全国数学建模竞赛，主要负责解题思路的讨论和论文的撰写。主要解题思路如下：&emsp;&emsp;针对题目中给出的四个问题，分别利用数学方法提出我们自己的解决方案，并在matlab仿真环境下求解验证。 &emsp;&emsp;针对问题一，我们的主要目标就是利用附件提供的1402组测试数据，来对题中给出的L-I模型中各个未知参数进行求解，并根据求出的数学模型，画出不同温度下的L-I曲线，再对激光器在直流输出时平均光功率为2mW这样的临界条件下求解用户正常使用网络的临界温度值。我们的基本思路是：对附件中给出的经验公式进行联立移项，构造出一个残差r。由于附件中给出的数据I，V，P 均为向量数据，所以可以构造一个线性回归方程中的成本函数(Cost function)来求出使系统稳定的未知参数。该成本函数设为J,这样问题就转换成求解J的极小值。我们便可以使用基于Nelder-Mead的fminsearch函数，带入初值，便可以在系统收敛的情况下求出模型中各个参数。在求出模型之后，我们还需要对其稳定性进行检验。检验的方法就是对P_0进行循环迭代，如果系统是稳定的，那么在给P_0赋一个初值后，经过有限步的循环迭代，就可以得到一个稳定收敛的值。假设系统是稳定的，我们便可以利用模型，通过输入不同的T值，就可以描绘出不同温度下的L-I曲线。 &emsp;&emsp;针对问题二，我们的目标是对问题一求出的模型进行评估并对其进行优化。我们可以通过将模型在20℃情况下的L-I曲线与实测画出的L-I曲线进行比对分析。如果二者存在误差，那么可以判断我们求出的模型还不够优化，就可以通过调整模型参数值来继续观察其L-I曲线与实测曲线的差异性。如果调参之后的曲线与实际更加接近，那么这样的模型就是我们想要的优化模型。 &emsp;&emsp;针对问题三，我们分别针对四个小问题给出我们的解决方案： &emsp;&emsp;a. 问题三主要是建立带宽模型，也称作小信号响应模型。题目中的幅度（dB）首先要转换成响应H(f)，根据公式dB=20*〖log〗_10 H(f),将其进行归一化。然后根据附录中的公式进行推导，求出频率f与H(f)之间的关系，代入公式，通过matlab进行非线性拟合，最后求出所需要的参数。然后画出仿真输出曲线； &emsp;&emsp;b. 从带宽模型中可以得知3dB带宽的频率以及10dB带宽的频率，之后通过改变初试电流以及初始温度，测出不同的环境温度以及不同偏置电流的曲线，从画出的曲线中就能看出两者对VCSEL带宽的影响； &emsp;&emsp;c. 首先通过b中以及后面的分析，可以通过改变模型参数的方法获得更大的带宽；其次可以考虑对谐振腔的腔长进行优化的方案，也就是除了温度和电流之外的影响，通过查阅资料，该方案可以提升带宽60%； &emsp;&emsp;d. 首先通过a）中得出的模型参数分别进行敏捷度测试，检验哪些参数会对高于0的位置产生影响，通过增大模型参数以及减小参数并且和原图像对比的方式，我们可以分析参数对其影响； &emsp;&emsp;针对问题四，我们通过对问题三的分析，已知了某些参数会对曲线的带宽产生较大影响，对所有的参数进行敏捷度测试即可发现参数的调节上对于带宽的影响，增大参数与减小参数如何才能获得更宽的带宽。 &emsp;&emsp;下面给出论文全文：]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo从0搭建教程]]></title>
    <url>%2F2017%2F08%2F28%2Fhexo%E4%BB%8E0%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最开始有开博客的想法还是上个学期，因为学东西要去记一些笔记，便觉得为什么不顺便开一个博客，也便于管理。后来发现事实并没有想象中那么简单，网上流行的一些博客如CSDN之类的，在发布文章的时候大多需要审核（有时候只是想单纯的自言自语。。。），很麻烦。而一些非技术免费博客，如新浪博客之类的，界面难看不说，还没有分类（这样和记流水账有什么区别）。所以在熟悉了一定前端知识之后，我开始学着自己搭博客。那么现在，终于有一个界面美观，功能齐全的个人博客问世了！下面我就介绍一下完整的搭博客过程。 1. 安装Git Bash如果你不太喜欢在cmd中的各种操作，那么可以选择使用Git Bash，由于我是windows环境，所以下载windows版本并安装即可。 下载链接 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本： 命令：git version 2. 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧 下载链接(说明：LTS为长期支持版，Current为当前最新版) 安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按win + r快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。 查看版本： 1命令：node -v 3. 安装hexo看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：1npm i -g hexo 安装完成后，查看版本：) 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件： 解释一下： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 做好这些前置工作之后接下来的就是各种配配配置了。 4. 搭桥到github没账号的创建账号，有账号的看下面。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下： 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）： UserName: Email: 创建SSH 在gitbash中输入：ssh-keygen -t rsa -C &quot;youremail@example.com，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。 ssh: 将上面获取的ssh放到github中： 添加一个 New SSH key ，title随便取，key就填刚刚那一段。 在gitbash中验证是否添加成功：ssh -T git@github.com 完成下一步你就成功啦！ 5. 一步之遥用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到gitbash中，进入你的blog目录，分别执行以下命令：123hexo cleanhexo generatehexo server 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。 打开浏览器输入：http://localhost:4000(如果没有反应，就到文件根目录下执行 hexo s -p 5000，换一个端口号就好了) 接着你就可以遇见天使的微笑了~ 6. 上传到github先安装一波：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 执行命令(建议每次都按照如下步骤部署)：123hexo cleanhexo generatehexo deploy 注意deploy的过程中要输入你的username及passward。如下： 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！ 感觉gitbash中东西太多的时候输入clear命令清空。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假期间改过的一些网页小游戏代码]]></title>
    <url>%2F2017%2F08%2F20%2Fevergames%2F</url>
    <content type="text"><![CDATA[暑假期间在创业公司实习，负责修改一些网页小游戏的代码并进行优化，下面是曾经修改过的一些游戏的入口地址，直接点击图片即可进入 1.2048游戏入口： 2.数独游戏入口： 3.Visiontest游戏入口： 4.Eyetest游戏入口：]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
